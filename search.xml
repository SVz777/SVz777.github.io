<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k8s安装</title>
      <link href="/p/357679683.html"/>
      <url>/p/357679683.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h1><h2 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h2><h3 id="临时关闭"><a href="#临时关闭" class="headerlink" title="临时关闭"></a>临时关闭</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure><h3 id="永久关闭"><a href="#永久关闭" class="headerlink" title="永久关闭"></a>永久关闭</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br><span class="line"><span class="comment"># 注释掉/swapfile</span></span><br></pre></td></tr></table></figure><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe overlay</span><br><span class="line"></span><br><span class="line">vim /etc/sysctl.conf </span><br><span class="line"><span class="comment"># 开启 net.ipv4.ip_forward = 1</span></span><br></pre></td></tr></table></figure><h1 id="安装containerd-也可使用docker"><a href="#安装containerd-也可使用docker" class="headerlink" title="安装containerd(也可使用docker)"></a>安装containerd(也可使用docker)</h1>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install containerd</span><br></pre></td></tr></table></figure><h1 id="安装k8s"><a href="#安装k8s" class="headerlink" title="安装k8s"></a>安装k8s</h1><h2 id="添加k8s-镜像源"><a href="#添加k8s-镜像源" class="headerlink" title="添加k8s 镜像源"></a>添加k8s 镜像源</h2>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阿里</span></span><br><span class="line"><span class="comment"># 需要安装 gnupg</span></span><br><span class="line">apt install gnupg</span><br><span class="line">curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"><span class="comment"># 腾讯</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb http://mirrors.cloud.tencent.com/kubernetes/apt/ kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d</span><br><span class="line">/kubernetes.list</span><br><span class="line">apt update</span><br></pre></td></tr></table></figure><h2 id="安装-版本对上就行"><a href="#安装-版本对上就行" class="headerlink" title="安装(版本对上就行)"></a>安装(版本对上就行)</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install kubeadm=1.25.3-00 kubelet=1.25.3-00 kubectl=1.25.3-00</span><br></pre></td></tr></table></figure><h2 id="镜像源问题"><a href="#镜像源问题" class="headerlink" title="镜像源问题"></a>镜像源问题</h2><h3 id="生成配置"><a href="#生成配置" class="headerlink" title="生成配置"></a>生成配置</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">containerd config default &gt; /etc/containerd/config.toml  </span><br></pre></td></tr></table></figure><h3 id="修改相关镜像"><a href="#修改相关镜像" class="headerlink" title="修改相关镜像"></a>修改相关镜像</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim  /etc/containerd/config.toml</span><br><span class="line">修改 sandbox_image 为 registry.aliyuncs.com/google_containers/pause</span><br></pre></td></tr></table></figure><p>  配置镜像源<br>  <figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors]</span></span><br><span class="line">  下面加上</span><br><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;docker.io&quot;]</span></span><br><span class="line">    <span class="attr">endpoint</span> = [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.registry.mirrors.&quot;k8s.gcr.io&quot;]</span></span><br><span class="line">    <span class="attr">endpoint</span> = [<span class="string">&quot;https://registry.aliyuncs.com/google_containers&quot;</span>]</span><br></pre></td></tr></table></figure></p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><h4 id="启动containerd"><a href="#启动containerd" class="headerlink" title="启动containerd"></a>启动containerd</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> containerd</span><br><span class="line">systemctl start containerd</span><br></pre></td></tr></table></figure><h4 id="启动kubelet"><a href="#启动kubelet" class="headerlink" title="启动kubelet"></a>启动kubelet</h4>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> kubelet.service</span><br><span class="line">systemctl start kubelet.service</span><br></pre></td></tr></table></figure><h4 id="crictl配置"><a href="#crictl配置" class="headerlink" title="crictl配置"></a>crictl配置</h4><p>  修改<code>/etc/crictl.yaml</code><br>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">runtime-endpoint:</span> <span class="string">unix:///var/run/containerd/containerd.sock</span></span><br><span class="line"><span class="attr">image-endpoint:</span> <span class="string">unix:///var/run/containerd/containerd.sock</span></span><br><span class="line"><span class="attr">timeout:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">debug:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">pull-image-on-create:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h1 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h1><h2 id="主节点"><a href="#主节点" class="headerlink" title="主节点"></a>主节点</h2><h3 id="kubeadm-安装"><a href="#kubeadm-安装" class="headerlink" title="kubeadm 安装"></a>kubeadm 安装</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.25.3 \</span><br><span class="line">--apiserver-advertise-address 10.0.4.14 \</span><br><span class="line">--pod-network-cidr=10.244.0.0/16 \</span><br><span class="line">--token-ttl 0 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里</span></span><br><span class="line"><span class="comment"># apiserver-advertise-address 是绑定ip</span></span><br><span class="line"><span class="comment"># pod-network-cidr k8s内网ip</span></span><br></pre></td></tr></table></figure><h3 id="cni安装"><a href="#cni安装" class="headerlink" title="cni安装"></a>cni安装</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 flannel</span></span><br><span class="line">kubectl apply -f https://raw.githubusercontent.com/flannel-io/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p>  这里如果 <code>kubeadm  --pod-network-cidr</code> 不是默认的<code>10.244.0.0/16</code> 就要把yml里面的subnet改成上面配置的</p><h2 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h2><p>  主节点安装后会有一行命令 <code>kubeadm join xxxx</code>  子节点上执行</p><p>  如果忘记了可以在主节点上 <code>kubeadm token create --print-join-command</code> 重新生成</p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="ingress-nginx"><a href="#ingress-nginx" class="headerlink" title="ingress-nginx"></a>ingress-nginx</h2><h3 id="镜像问题"><a href="#镜像问题" class="headerlink" title="镜像问题"></a>镜像问题</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">crictl pull registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20220916-gd32f8c343</span><br><span class="line">crictl pull registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.5.1</span><br><span class="line"></span><br><span class="line">ctr -n k8s.io images tag registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.5.1 registry.k8s.io/ingress-nginx/controller:v1.5.1</span><br><span class="line">ctr -n k8s.io images tag registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v20220916-gd32f8c343 registry.k8s.io/ingress-nginx/kube-webhook-certgen:v20220916-gd32f8c343</span><br></pre></td></tr></table></figure><h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><p>  没有LoadBalancer的话， service修改为NodePort，采用daemonset部署， 先给node打标 <code>kubectl label nodes node-name hasIngress=true</code>, 然后配置daemonset选择器</p><h3 id="后端服务是https时，需配置对应ingress注解"><a href="#后端服务是https时，需配置对应ingress注解" class="headerlink" title="后端服务是https时，需配置对应ingress注解"></a>后端服务是https时，需配置对应ingress注解</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx.ingress.kubernetes.io/backend-protocol: <span class="string">&quot;HTTPS&quot;</span></span><br></pre></td></tr></table></figure><h2 id="集群跨界点网络不通问题"><a href="#集群跨界点网络不通问题" class="headerlink" title="集群跨界点网络不通问题"></a>集群跨界点网络不通问题</h2><p>  需要开放udp端口，flannel要用udp</p><h2 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h2><p>  启动失败 错误 Failed to create pod sandbox: open /run/systemd/resolve/resolv.conf: no such file or directory</p><p>  需要启动 systemd-resolved 服务</p><h2 id="containerd-CRI-v1-image-API-is-not-implemented-for-endpoint"><a href="#containerd-CRI-v1-image-API-is-not-implemented-for-endpoint" class="headerlink" title="containerd CRI v1 image API is not implemented for endpoint"></a>containerd CRI v1 image API is not implemented for endpoint</h2><p>  crictl 版本(cri-tools)得跟containerd 对上</p><h2 id="从节点连接不上问题"><a href="#从节点连接不上问题" class="headerlink" title="从节点连接不上问题"></a>从节点连接不上问题</h2><p>  可以先从节点上 kubeadm init 一下初始一下基础环境， 然后 kubeadm reset 再 kubeadm join 主节点</p><h2 id="pod起不起来"><a href="#pod起不起来" class="headerlink" title="pod起不起来"></a>pod起不起来</h2><p>  可以通过以下命令查看原因</p><p>  <code>kubectl describe pod -n namespace-name pod-name</code> </p><h2 id="网络重置"><a href="#网络重置" class="headerlink" title="网络重置"></a>网络重置</h2><h3 id="删除cni0"><a href="#删除cni0" class="headerlink" title="删除cni0"></a>删除cni0</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig cni0 down</span><br><span class="line">ip <span class="built_in">link</span> delete cni0</span><br><span class="line"><span class="built_in">rm</span> -rf /var/lib/cni/</span><br></pre></td></tr></table></figure><h3 id="删除flannel网络"><a href="#删除flannel网络" class="headerlink" title="删除flannel网络"></a>删除flannel网络</h3>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifconfig flannel.1 down</span><br><span class="line">ip <span class="built_in">link</span> delete flannel.1</span><br><span class="line"><span class="built_in">rm</span> -f /etc/cni/net.d/*</span><br></pre></td></tr></table></figure><h2 id="k8s证书过期"><a href="#k8s证书过期" class="headerlink" title="k8s证书过期"></a>k8s证书过期</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kubeadm certs check-expiration # 查看证书过期时间</span><br><span class="line">kubeadm certs renew all # 重新申请证书</span><br><span class="line"></span><br><span class="line"># 然后更新一下kubeadm配置</span><br><span class="line">rm -rf /etc/kubernetes/*.conf # 删除旧配置</span><br><span class="line">kubeadm init phase kubeconfig all # 生成新配置</span><br><span class="line"></span><br><span class="line"># 重启 kubelet</span><br><span class="line">systemctl restart kubelet.service</span><br><span class="line"></span><br><span class="line"># 检查下证书是否更新</span><br><span class="line">openssl x509 -in /var/lib/kubelet/pki/kubelet-client-current.pem -noout -text |grep Not</span><br></pre></td></tr></table></figure><h2 id="节点notReady"><a href="#节点notReady" class="headerlink" title="节点notReady"></a>节点notReady</h2><p>  报错 Network plugin returns error: cni plugin not initialized</p><p>  去主节点上将 /etc/cni/net.d 内文件拷贝过来即可</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wireshark不显示vxlan协议</title>
      <link href="/p/402035249.html"/>
      <url>/p/402035249.html</url>
      
        <content type="html"><![CDATA[<h1 id="vxlan封包-wireshark查看不了"><a href="#vxlan封包-wireshark查看不了" class="headerlink" title="vxlan封包 wireshark查看不了"></a>vxlan封包 wireshark查看不了</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>  Wireshark 默认 Vxlan 协议数据包使用的 UDP 端口为 4789，而 Linux Kernel 默认 vxlan 协议端口为 8472/udp 端口，所以无法解析<br>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/402035249/unkonwn.png" class="" title="未解析情况"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>选中端口为 udp 8472 的任意数据包 —&gt; 右键  —&gt; Decode As<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/402035249/selection.png" class="" title="选项"></li><li>第二列设置为 8472 -&gt; 最后一列设置为 VXLAN<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/402035249/set.png" class="" title="设置"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Net </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-asm-基础</title>
      <link href="/p/3903621862.html"/>
      <url>/p/3903621862.html</url>
      
        <content type="html"><![CDATA[<p>了解底层才能理解程序的运作方式，哪怕只懂一点点汇编，也便于更好地理解计算机底层原理。</p><span id="more"></span><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="程序的编译阶段"><a href="#程序的编译阶段" class="headerlink" title="程序的编译阶段"></a>程序的编译阶段</h2><p>从源码到最终可执行文件的整体流程如下：</p><p>源程序-&gt;编译预处理-&gt;编译-&gt;汇编-&gt;链接-&gt;可执行文件。</p><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>编译器即编译这一步干活的程序。</p><p>编译器粗略分为</p><p>词法分析，语法分析，类型检查，中间代码生成，代码优化，目标代码生成，目标代码优化。</p><p>以 中间代码生成 区分为前端/后端</p><h2 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h2><p>目前市面上存在两种指令集架构类型:</p><ol><li><strong>Reduced Instruction Set Computing (RISC) 精简指令集，比如ARM,MIPS等</strong></li><li><strong>Complex Instruction Set Computing (CISC) 复杂指令集，比如Intel的X86及优化指令集SSE/AVX等</strong></li></ol><p>linux 可以 <code>cat /proc/cpuinfo</code>查看支持指令集</p><p>macos 可以 <code>sysctl machdep.cpu</code>查看支持指令集</p><p>go也可以通过cpu.X86查看X86当前支持的指令集</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">_ <span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CacheLinePad <span class="keyword">struct</span>&#123; _ [<span class="number">64</span>]<span class="type">byte</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">struct</span> &#123;</span><br><span class="line">_            CacheLinePad</span><br><span class="line">HasAES       <span class="type">bool</span></span><br><span class="line">HasADX       <span class="type">bool</span></span><br><span class="line">HasAVX       <span class="type">bool</span></span><br><span class="line">HasAVX2      <span class="type">bool</span></span><br><span class="line">HasBMI1      <span class="type">bool</span></span><br><span class="line">HasBMI2      <span class="type">bool</span></span><br><span class="line">HasERMS      <span class="type">bool</span></span><br><span class="line">HasFMA       <span class="type">bool</span></span><br><span class="line">HasOSXSAVE   <span class="type">bool</span></span><br><span class="line">HasPCLMULQDQ <span class="type">bool</span></span><br><span class="line">HasPOPCNT    <span class="type">bool</span></span><br><span class="line">HasSSE2      <span class="type">bool</span></span><br><span class="line">HasSSE3      <span class="type">bool</span></span><br><span class="line">HasSSSE3     <span class="type">bool</span></span><br><span class="line">HasSSE41     <span class="type">bool</span></span><br><span class="line">HasSSE42     <span class="type">bool</span></span><br><span class="line">_            CacheLinePad</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname X86 internal/cpu.X86</span></span><br><span class="line"><span class="keyword">var</span> X86 Set</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(X86)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go汇编语言并没有支持全部的CPU指令。<br>完整的X86指令定义看<a href="https://github.com/golang/arch/blob/master/x86/x86.csv">这里</a>。<br>同时Go汇编还正对一些指令定义了别名，具体可以参考<a href="https://golang.org/src/cmd/internal/obj/x86/anames.go">这里</a>。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>rax(al,ah,ax,eax)，rbx,rcx,rdx,rdi,rsi,r8-r15</p><p>Go汇编精简为</p><p>AX,BX,CX…..</p><h3 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h3><p>bp:指向栈底</p><p>sp:指向栈顶</p><h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>cs——代码段寄存器(Code Segment Register)，其值为代码段的段值</p><p>ds——数据段寄存器(Data Segment Register)，其值为数据段的段值</p><p>es——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值</p><p>ss——堆栈段寄存器(Stack Segment Register)，其值为堆栈段的段值</p><p>fs——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值</p><p>gs——附加段寄存器(Extra Segment Register)，其值为附加数据段的段值</p><h3 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h3><p>rip: instruction pointer指令指针寄存器</p><p>cs:ip 一般也称为PC(programme counter程序计数器),指向下一条要执行的指令</p><h3 id="伪寄存器"><a href="#伪寄存器" class="headerlink" title="伪寄存器"></a>伪寄存器</h3><p> Go汇编为了简化汇编代码的编写，工具链维持出来了<code>FP、PC、SB、SP四个伪寄存器</code>。</p><ol><li>FP: frame pointer, 帧指针,参数和局部变量</li><li>PC: program counter: 程序计数器,跳转和分支</li><li>SB: static base pointer: 静态基址指针,全局符号</li><li>SP: stack pointer: 栈指针,栈的顶端</li></ol><p>FP:寄存器指向函数参数。0(FP)是第一个参数，8(FP)是第二个参数(64-bit machine). first_arg+0(FP)表示把第一个参数地址绑定到符号 first_arg, 这个与SB的含义不同。</p><p>PC:程序计数器，指下一步要执行的程序，伪寄存器PC和硬件寄存器PC作用差不多。</p><p>SB:寄存器表示全局内存起点，foo(SB) 表示 符号foo作为内存地址使用。这种形式用于命名 全局函数，数据。&lt;&gt;限制符号只能在当前源文件使用，类似 C 中的 static。foo+4(SB)表示foo 往后 4字节的地址。</p><p>SP:寄存器表示栈指针，指向当前栈顶， 所以 offset 都是负数，范围在 [ -framesize, 0 ), 例如 x-8(SP). 对于硬件寄存器名称为SP的架构，x-8(SP) 表示虚拟栈指针寄存器(实际上是当前栈帧的 BP 位置)， -8(SP) 表示硬件 SP 寄存器(与虚拟SP相隔当前栈帧大小).<strong>如果使用SP时有一个临时标识符前缀就是伪SP，否则就是真SP寄存器,所有生成的汇编代码都是真实SP寄存器，与手写汇编不一致</strong></p><p>下方给个参考图示，1.17后会有区别见下方调用规约相关。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">高地址位</span><br><span class="line">          ┼───────────┼</span><br><span class="line">          │  返回值2   │</span><br><span class="line">          ┼───────────┼</span><br><span class="line">          │  返回值1   │</span><br><span class="line">          ┼───────────┼</span><br><span class="line">          │  参数值2   │</span><br><span class="line">          ┼───────────┼</span><br><span class="line">          │  参数值1   │</span><br><span class="line">          ┼───────────┼    &lt;-- 伪FP</span><br><span class="line">          │ 函数返回地址│</span><br><span class="line">          ┼───────────┼</span><br><span class="line">          │ CALLER BP │</span><br><span class="line">          ┼───────────┼    &lt;-- 伪SP(BP)</span><br><span class="line">          │  变量值m   │    </span><br><span class="line">          ┼───────────┼    &lt;-- m-8(SP)</span><br><span class="line">          │  变量值n   │    </span><br><span class="line">          ┼───────────┼    &lt;-- 硬件SP &lt;-- n-16(SP)</span><br><span class="line">低地址位</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>其他寄存器,比如cf,xmm等可以自己查看相关文献</p><h2 id="汇编风格比较"><a href="#汇编风格比较" class="headerlink" title="汇编风格比较"></a>汇编风格比较</h2><div class="table-container"><table><thead><tr><th style="text-align:left">Intel</th><th style="text-align:left">AT&amp;T</th><th style="text-align:left">Go</th></tr></thead><tbody><tr><td style="text-align:left"><code>mov eax, 1</code></td><td style="text-align:left"><code>movl $1, %eax</code></td><td style="text-align:left"><code>MOVQ $1, AX</code></td></tr><tr><td style="text-align:left"><code>mov rbx, 0ffh</code></td><td style="text-align:left"><code>movl $0xff, %rbx</code></td><td style="text-align:left"><code>MOVQ $0xff, BX</code></td></tr><tr><td style="text-align:left"><code>mov ecx, [ebx+3]</code></td><td style="text-align:left"><code>movl 3(%ebx), %ecx</code></td><td style="text-align:left"><code>MOVQ 2(BX), CX</code></td></tr></tbody></table></div><p>整体风格与AT&amp;T类似</p><ol><li>以$符号表示常量，但是寄存器并没有%前缀</li><li>以命令来区分操作长度比如 MOVB MOVW MOVL MOVQ</li></ol><p>Go汇编命令绝大大多与AT&amp;T一致 <code>op src dst</code>，比如 <code>MOVQ $1, AX</code> 表示把1赋值给AX，也有一部分是不一样的，比如CMP相关</p><h2 id="程序段-section"><a href="#程序段-section" class="headerlink" title="程序段(section)"></a>程序段(section)</h2><p>程序编译以后会分为不同的段，一般来说会分为</p><ol><li>.text 代码段 存放程序代码,通常是只读的</li><li>.data 数据段 存放初始化了的全局变量和初始化了的静态变量</li><li>.bss 全局变量段 存放未初始化的全局变量和未初始化的静态变量</li></ol><p>名字都是历史定的，也没啥特殊硬记就完事。主要就是把数据按照不同的分类放在一起。也就是说可以自定义段信息来区分，能找到对应的数据就行。</p><h1 id="Go汇编基础语法"><a href="#Go汇编基础语法" class="headerlink" title="Go汇编基础语法"></a>Go汇编基础语法</h1><p><code>symbol</code>为变量在汇编语言中对应的标识符,当前包中Go语言定义的符号<code>symbol</code>，在汇编代码中对应<code>·symbol</code>,在符号后的&lt;&gt;作用是限制数据在当前文件使用。</p><p><code>offset</code>是符号开始地址的偏移量</p><p><code>width</code>是要初始化内存的宽度大小</p><p><code>value</code>是要初始化的值</p><p><code>(SB)</code>表示符号相对于<code>SB伪寄存器</code>的偏移量，二者组合在一起最终是绝对地址</p><h2 id="DATA-用于初始化包变量"><a href="#DATA-用于初始化包变量" class="headerlink" title="DATA:用于初始化包变量"></a>DATA:用于初始化包变量</h2><p>语法为: <code>DATA symbol+offset(SB)/width, value</code></p><h2 id="GLOBL-用于将符号导出"><a href="#GLOBL-用于将符号导出" class="headerlink" title="GLOBL:用于将符号导出"></a>GLOBL:用于将符号导出</h2><p>语法为: <code>GLOBL symbol(SB), width</code></p><h2 id="TEXT-用于定义符号-一般就是函数"><a href="#TEXT-用于定义符号-一般就是函数" class="headerlink" title="TEXT:用于定义符号(一般就是函数)"></a>TEXT:用于定义符号(一般就是函数)</h2><p>语法为: <code>TEXT symbol(SB), [flags,] $framesize[-argsize]</code></p><p>其中函数名(symbol)中当前包的路径可以省略</p><p><code>flags</code>用于指示函数的一些特殊行为，标志在<a href="https://github.com/golang/go/blob/master/src/runtime/textflag.h">textlags.h</a>文件中定义，常见的<code>NOSPLIT</code>主要用于标记函数不进行栈分裂。</p><p><code>framesize</code>表示栈帧大小，其中包含局部变量+调用其它函数时准备调用参数的隐式栈空间。</p><p><code>argsize</code>参数及返回值大小，之所以可以省略是因为编译器可以从Go语言的函数声明中推导出函数参数的大小。</p><h2 id="PCDATA和FUNCDATA"><a href="#PCDATA和FUNCDATA" class="headerlink" title="*PCDATA和FUNCDATA"></a>*PCDATA和FUNCDATA</h2><blockquote><p>Go里有一个函数叫做<code>runtime.Caller</code>,可以获取当前的PC寄存器值，以及文件和行号。然后根据PC寄存器表示的指令位置，通过<code>runtime.FuncForPC</code>函数获取函数的基本信息，这种功能是如何实现的？</p><p>Go语言作为一门静态编译型语言，在执行时每个函数的地址都是固定的，函数的每条指令也是固定的。如果针对每个函数和函数的每个指令生成一个地址表格（也叫PC表格），那么在运行时我们就可以根据PC寄存器的值轻松查询到指令当时对应的函数和位置信息。而Go语言也是采用类似的策略，只不过地址表格经过裁剪，舍弃了不必要的信息。因为要在运行时获取任意一个地址的位置，必然是要有一个函数调用，因此我们只需要为函数的开始和结束位置，以及每个函数调用位置生成地址表格就可以了。同时地址是有大小顺序的，在排序后可以通过只记录增量来减少数据的大小；在查询时可以通过二分法加快查找的速度。</p></blockquote><p>这两命令就是标记地址表格和函数表格的指令</p><p>两者语法也一致,语法为: <code>PCDATA/FUNCDATA tableid, tableoffset</code></p><p><code>tableid</code>: 表格的类型</p><p>​    PCDATA有两种类型<code>PCDATA_StackMapIndex</code>,<code>PCDATA_InlTreeIndex</code>,两种类型类似，后者为内联函数的表格</p><p>​    FUNCDATA有3种类型</p><pre><code> 1. `FUNCDATA_ArgsPointerMaps`: 函数参数的指针信息表 2. `FUNCDATA_LocalsPointerMaps`: 局部指针信息表 3. `FUNCDATA_InlTree`: 被内联展开的指针信息表</code></pre><p><code>tableoffset</code>: 表格的地址</p><p>通过FUNC表格，Go语言的垃圾回收器可以跟踪全部指针的生命周期，同时根据指针指向的地址是否在被移动的栈范围来确定是否要进行指针移动。</p><p>一般来说都是由编译器自动生成，手动实现不太现实</p><h1 id="手写汇编"><a href="#手写汇编" class="headerlink" title="手写汇编"></a>手写汇编</h1><p>一般来说，就看下汇编生成就行了，手写汇编意义不大，当然，真想写也不是不行。。。</p><h3 id="简单计算"><a href="#简单计算" class="headerlink" title="简单计算"></a>简单计算</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//add.s</span></span><br><span class="line">TEXT ·Add(SB), $<span class="number">0</span><span class="number">-24</span></span><br><span class="line">    MOVQ a+<span class="number">0</span>(FP), AX</span><br><span class="line">    MOVQ b+<span class="number">8</span>(FP), BX</span><br><span class="line">    ADDQ BX,AX</span><br><span class="line">    MOVQ AX,ret+<span class="number">16</span>(FP)</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line">TEXT ·Neg(SB), $<span class="number">0</span></span><br><span class="line">    MOVQ     x+<span class="number">0</span>(FP), AX</span><br><span class="line">    NEGQ     AX</span><br><span class="line">    MOVQ     AX, ret+<span class="number">8</span>(FP)</span><br><span class="line">    RET</span><br><span class="line"><span class="comment">//add.go</span></span><br><span class="line"><span class="keyword">package</span> add</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="type">int64</span>, b <span class="type">int64</span>)</span></span> <span class="type">int64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Neg</span><span class="params">(x <span class="type">uint64</span>)</span></span> <span class="type">int64</span></span><br></pre></td></tr></table></figure><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.s</span></span><br><span class="line">GLOBL str(SB),RODATA,$<span class="number">17</span></span><br><span class="line">DATA  str+<span class="number">0x00</span>(SB)/<span class="number">8</span>, $<span class="string">&quot;aaaaaaaa&quot;</span></span><br><span class="line">DATA  str+<span class="number">0x08</span>(SB)/<span class="number">8</span>, $<span class="string">&quot;bbbbcccc&quot;</span></span><br><span class="line">DATA  str+<span class="number">0x10</span>(SB)/<span class="number">1</span>, $<span class="number">0x0a</span></span><br><span class="line"></span><br><span class="line">GLOBL ·foo(SB), RODATA, $<span class="number">16</span></span><br><span class="line">DATA  ·foo+<span class="number">0</span>(SB)/<span class="number">8</span>,$str(SB)</span><br><span class="line">DATA  ·foo+<span class="number">8</span>(SB)/<span class="number">8</span>,$<span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"><span class="keyword">var</span> foo <span class="type">string</span></span><br></pre></td></tr></table></figure><h3 id="获取goid"><a href="#获取goid" class="headerlink" title="获取goid"></a>获取goid</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//goid.s</span></span><br><span class="line">#include <span class="string">&quot;textflag.h&quot;</span></span><br><span class="line"></span><br><span class="line">TEXT ·GetGoID(SB),NOSPLIT,$<span class="number">0</span><span class="number">-8</span></span><br><span class="line">    MOVQ (TLS),AX</span><br><span class="line">    MOVQ ·offset(SB),BX</span><br><span class="line">    MOVQ (AX)(BX*<span class="number">1</span>),CX</span><br><span class="line">    MOVQ CX,g+<span class="number">0</span>(FP)</span><br><span class="line">    RET</span><br><span class="line"></span><br><span class="line"><span class="comment">//goid.go</span></span><br><span class="line"><span class="keyword">package</span> goid</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> offset = <span class="number">152</span> <span class="comment">//go1.16</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetGoID</span><span class="params">()</span></span> <span class="type">int</span></span><br></pre></td></tr></table></figure><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.s</span></span><br><span class="line">TEXT ·helloWorld(SB), NOSPLIT, $<span class="number">0</span></span><br><span class="line">    MOVL     $(<span class="number">0x2000000</span>+<span class="number">4</span>), AX     <span class="comment">// syscall write</span></span><br><span class="line">    MOVQ     $<span class="number">1</span>, DI             <span class="comment">// arg 1 fd</span></span><br><span class="line">    LEAQ     str(SB), SI         <span class="comment">// arg 2 buf</span></span><br><span class="line">    MOVL     $<span class="number">24</span>, DX         <span class="comment">// arg 3 count</span></span><br><span class="line">    SYSCALL</span><br><span class="line">    RET</span><br><span class="line"><span class="comment">//a.go</span></span><br><span class="line"><span class="keyword">package</span> hello</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloWorld</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h1 id="函数调用规约"><a href="#函数调用规约" class="headerlink" title="函数调用规约"></a>函数调用规约</h1><p>传统的调用规约中，一般会区分为</p><ol><li>caller saved registers 调用方保存现场 </li><li>callee saved registers 被调方保存现场</li></ol><h2 id="1-16及以前"><a href="#1-16及以前" class="headerlink" title="1.16及以前"></a>1.16及以前</h2><p>要求所有参数和返回值都通过从右至左压栈来传递</p><p>看一个示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 <span class="type">int</span>)</span></span> (r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11 <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a11, a10, a9, a8, a7, a6, a5, a4, a3, a2, a1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;&quot;.add STEXT nosplit size=132 args=0xb0 locals=0x0 funcid=0x0</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:4)TEXT&quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-176</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:4)FUNCDATA$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:4)FUNCDATA$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:5)MOVQ&quot;&quot;.a11+88(SP), AX</span></span><br><span class="line"><span class="comment">0x0005 00005 (test.go:5)MOVQAX, &quot;&quot;.r1+96(SP)</span></span><br><span class="line"><span class="comment">0x000a 00010 (test.go:5)MOVQ&quot;&quot;.a10+80(SP), AX</span></span><br><span class="line"><span class="comment">0x000f 00015 (test.go:5)MOVQAX, &quot;&quot;.r2+104(SP)</span></span><br><span class="line"><span class="comment">0x0014 00020 (test.go:5)MOVQ&quot;&quot;.a9+72(SP), AX</span></span><br><span class="line"><span class="comment">0x0019 00025 (test.go:5)MOVQAX, &quot;&quot;.r3+112(SP)</span></span><br><span class="line"><span class="comment">0x001e 00030 (test.go:5)MOVQ&quot;&quot;.a8+64(SP), AX</span></span><br><span class="line"><span class="comment">0x0023 00035 (test.go:5)MOVQAX, &quot;&quot;.r4+120(SP)</span></span><br><span class="line"><span class="comment">0x0028 00040 (test.go:5)MOVQ&quot;&quot;.a7+56(SP), AX</span></span><br><span class="line"><span class="comment">0x002d 00045 (test.go:5)MOVQAX, &quot;&quot;.r5+128(SP)</span></span><br><span class="line"><span class="comment">0x0035 00053 (test.go:5)MOVQ&quot;&quot;.a6+48(SP), AX</span></span><br><span class="line"><span class="comment">0x003a 00058 (test.go:5)MOVQAX, &quot;&quot;.r6+136(SP)</span></span><br><span class="line"><span class="comment">0x0042 00066 (test.go:5)MOVQ&quot;&quot;.a5+40(SP), AX</span></span><br><span class="line"><span class="comment">0x0047 00071 (test.go:5)MOVQAX, &quot;&quot;.r7+144(SP)</span></span><br><span class="line"><span class="comment">0x004f 00079 (test.go:5)MOVQ&quot;&quot;.a4+32(SP), AX</span></span><br><span class="line"><span class="comment">0x0054 00084 (test.go:5)MOVQAX, &quot;&quot;.r8+152(SP)</span></span><br><span class="line"><span class="comment">0x005c 00092 (test.go:5)MOVQ&quot;&quot;.a3+24(SP), AX</span></span><br><span class="line"><span class="comment">0x0061 00097 (test.go:5)MOVQAX, &quot;&quot;.r9+160(SP)</span></span><br><span class="line"><span class="comment">0x0069 00105 (test.go:5)MOVQ&quot;&quot;.a2+16(SP), AX</span></span><br><span class="line"><span class="comment">0x006e 00110 (test.go:5)MOVQAX, &quot;&quot;.r10+168(SP)</span></span><br><span class="line"><span class="comment">0x0076 00118 (test.go:5)MOVQ&quot;&quot;.a1+8(SP), AX</span></span><br><span class="line"><span class="comment">0x007b 00123 (test.go:5)MOVQAX, &quot;&quot;.r11+176(SP)</span></span><br><span class="line"><span class="comment">0x0083 00131 (test.go:5)RET</span></span><br><span class="line"><span class="comment">0x0000 48 8b 44 24 58 48 89 44 24 60 48 8b 44 24 50 48  H.D$XH.D$`H.D$PH</span></span><br><span class="line"><span class="comment">0x0010 89 44 24 68 48 8b 44 24 48 48 89 44 24 70 48 8b  .D$hH.D$HH.D$pH.</span></span><br><span class="line"><span class="comment">0x0020 44 24 40 48 89 44 24 78 48 8b 44 24 38 48 89 84  D$@H.D$xH.D$8H..</span></span><br><span class="line"><span class="comment">0x0030 24 80 00 00 00 48 8b 44 24 30 48 89 84 24 88 00  $....H.D$0H..$..</span></span><br><span class="line"><span class="comment">0x0040 00 00 48 8b 44 24 28 48 89 84 24 90 00 00 00 48  ..H.D$(H..$....H</span></span><br><span class="line"><span class="comment">0x0050 8b 44 24 20 48 89 84 24 98 00 00 00 48 8b 44 24  .D$ H..$....H.D$</span></span><br><span class="line"><span class="comment">0x0060 18 48 89 84 24 a0 00 00 00 48 8b 44 24 10 48 89  .H..$....H.D$.H.</span></span><br><span class="line"><span class="comment">0x0070 84 24 a8 00 00 00 48 8b 44 24 08 48 89 84 24 b0  .$....H.D$.H..$.</span></span><br><span class="line"><span class="comment">0x0080 00 00 00 c3                                      ....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以简单的看出来就是把a11-a1移动到了r1-r11上</p><h2 id="1-17"><a href="#1-17" class="headerlink" title="1.17+"></a>1.17+</h2><p>改成caller saved registers,通过寄存器来调用，但是与c不一样的是，使用9个寄存器来进行交互，依次是 AX，BX，CX，DI，SI，R8，R9，R10，R11，超出部分还是通过栈来传递</p><p>所以1.17在性能及内存使用上会提升很多</p><p>同样看示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 <span class="type">int</span>)</span></span> (r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11 <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> a11, a10, a9, a8, a7, a6, a5, a4, a3, a2, a1</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&quot;&quot;.add STEXT nosplit size=48 args=0x68 locals=0x0 funcid=0x0</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:4)TEXT&quot;&quot;.add(SB), NOSPLIT|ABIInternal, $0-104</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:4)FUNCDATA$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:4)FUNCDATA$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:4)FUNCDATA$5, &quot;&quot;.add.arginfo1(SB)</span></span><br><span class="line"><span class="comment">0x0000 00000 (test.go:5)MOVQBX, &quot;&quot;.r10+24(SP)</span></span><br><span class="line"><span class="comment">0x0005 00005 (test.go:5)MOVQAX, &quot;&quot;.r11+32(SP)</span></span><br><span class="line"><span class="comment">0x000a 00010 (test.go:5)MOVQ&quot;&quot;.a11+16(SP), AX</span></span><br><span class="line"><span class="comment">0x000f 00015 (test.go:5)MOVQ&quot;&quot;.a10+8(SP), BX</span></span><br><span class="line"><span class="comment">0x0014 00020 (test.go:5)MOVQCX, DX</span></span><br><span class="line"><span class="comment">0x0017 00023 (test.go:5)MOVQR11, CX</span></span><br><span class="line"><span class="comment">0x001a 00026 (test.go:5)MOVQDI, R12</span></span><br><span class="line"><span class="comment">0x001d 00029 (test.go:5)MOVQR10, DI</span></span><br><span class="line"><span class="comment">0x0020 00032 (test.go:5)MOVQSI, R13</span></span><br><span class="line"><span class="comment">0x0023 00035 (test.go:5)MOVQR9, SI</span></span><br><span class="line"><span class="comment">0x0026 00038 (test.go:5)MOVQR13, R9</span></span><br><span class="line"><span class="comment">0x0029 00041 (test.go:5)MOVQR12, R10</span></span><br><span class="line"><span class="comment">0x002c 00044 (test.go:5)MOVQDX, R11</span></span><br><span class="line"><span class="comment">0x002f 00047 (test.go:5)RET</span></span><br><span class="line"><span class="comment">0x0000 48 89 5c 24 18 48 89 44 24 20 48 8b 44 24 10 48  H.\$.H.D$ H.D$.H</span></span><br><span class="line"><span class="comment">0x0010 8b 5c 24 08 48 89 ca 4c 89 d9 49 89 fc 4c 89 d7  .\$.H..L..I..L..</span></span><br><span class="line"><span class="comment">0x0020 49 89 f5 4c 89 ce 4d 89 e9 4d 89 e2 49 89 d3 c3  I..L..M..M..I...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到先将超出9个的BX(a2),AX(a1)移动到r10,r11上，然后交换对应的寄存器的值最后返回</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://9p.io/sys/doc/asm.pdf">asm.pdf (9p.io)</a></p><p><a href="https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master">MacOS系统调用</a></p><p><a href="https://draveness.me/golang/docs/part1-prerequisite/ch02-compile/golang-compile-intro/">Go 语言设计与实现</a></p><p><a href="https://www.cnblogs.com/binHome/p/13027712.html">GO汇编变量</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> asm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-asm-反汇编</title>
      <link href="/p/2525441379.html"/>
      <url>/p/2525441379.html</url>
      
        <content type="html"><![CDATA[<p>了解底层才能理解程序的运作方式，了解汇编是深入了解Go的必经之路。</p><span id="more"></span><p>平台: mac intel</p><p>Go: 1.17</p><p>文中所用代码见附录</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="段-section"><a href="#段-section" class="headerlink" title="段(section)"></a>段(section)</h2><p>程序编译以后会分为不同的段，一般来说会分为</p><ol><li>.text 代码段 存放程序代码,通常是只读的</li><li>.data 数据段 存放初始化了的全局变量和初始化了的静态变量</li><li>.bss 全局变量段 存放未初始化的全局变量和未初始化的静态变量</li></ol><p>名字都是历史定的，也没啥特殊硬记就完事。主要就是把数据按照不同的分类放在一起。也就是说可以自定义段信息来区分，能找到对应的数据就行。</p><h2 id="查看段信息"><a href="#查看段信息" class="headerlink" title="查看段信息"></a>查看段信息</h2><p>查看段信息有几种方式</p><h3 id="readelf"><a href="#readelf" class="headerlink" title="readelf"></a>readelf</h3><p>readelf -S 这个只支持elf格式的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux go build -gcflags=<span class="string">&quot;-B -N -l&quot;</span> main.go // 编译linux平台 // -B不开启越界检测 -N关闭优化 -l关闭内联</span><br><span class="line">readelf -S main</span><br></pre></td></tr></table></figure><p>可以得到以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">There are 23 section headers, starting at offset 0x1c8:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type             Address           Offset</span><br><span class="line">       Size              EntSize          Flags  Link  Info  Align</span><br><span class="line">  [ 0]                   NULL             0000000000000000  00000000</span><br><span class="line">       0000000000000000  0000000000000000           0     0     0</span><br><span class="line">  [ 1] .text             PROGBITS         0000000000401000  00001000</span><br><span class="line">       000000000007ec6d  0000000000000000  AX       0     0     32</span><br><span class="line">  [ 2] .rodata           PROGBITS         0000000000480000  00080000</span><br><span class="line">       0000000000035209  0000000000000000   A       0     0     32</span><br><span class="line">  [ 3] .shstrtab         STRTAB           0000000000000000  000b5220</span><br><span class="line">       000000000000017a  0000000000000000           0     0     1</span><br><span class="line">  [ 4] .typelink         PROGBITS         00000000004b53a0  000b53a0</span><br><span class="line">       00000000000004d8  0000000000000000   A       0     0     32</span><br><span class="line">  [ 5] .itablink         PROGBITS         00000000004b5880  000b5880</span><br><span class="line">       0000000000000058  0000000000000000   A       0     0     32</span><br><span class="line">  [ 6] .gosymtab         PROGBITS         00000000004b58d8  000b58d8</span><br><span class="line">       0000000000000000  0000000000000000   A       0     0     1</span><br><span class="line">  [ 7] .gopclntab        PROGBITS         00000000004b58e0  000b58e0</span><br><span class="line">       000000000005a1f0  0000000000000000   A       0     0     32</span><br><span class="line">  [ 8] .go.buildinfo     PROGBITS         0000000000510000  00110000</span><br><span class="line">       0000000000000020  0000000000000000  WA       0     0     16</span><br><span class="line">  [ 9] .noptrdata        PROGBITS         0000000000510020  00110020</span><br><span class="line">       00000000000105e0  0000000000000000  WA       0     0     32</span><br><span class="line">  [10] .data             PROGBITS         0000000000520600  00120600</span><br><span class="line">       0000000000007810  0000000000000000  WA       0     0     32</span><br><span class="line">  [11] .bss              NOBITS           0000000000527e20  00127e20</span><br><span class="line">       000000000002ef28  0000000000000000  WA       0     0     32</span><br><span class="line">  [12] .noptrbss         NOBITS           0000000000556d60  00156d60</span><br><span class="line">       0000000000005360  0000000000000000  WA       0     0     32</span><br><span class="line">  [13] .zdebug_abbrev    PROGBITS         000000000055d000  00128000</span><br><span class="line">       0000000000000119  0000000000000000           0     0     1</span><br><span class="line">  [14] .zdebug_line      PROGBITS         000000000055d119  00128119</span><br><span class="line">       000000000001b3c6  0000000000000000           0     0     1</span><br><span class="line">  [15] .zdebug_frame     PROGBITS         00000000005784df  001434df</span><br><span class="line">       00000000000054a7  0000000000000000           0     0     1</span><br><span class="line">  [16] .debug_gdb_s[...] PROGBITS         000000000057d986  00148986</span><br><span class="line">       000000000000003e  0000000000000000           0     0     1</span><br><span class="line">  [17] .zdebug_info      PROGBITS         000000000057d9c4  001489c4</span><br><span class="line">       000000000003146c  0000000000000000           0     0     1</span><br><span class="line">  [18] .zdebug_loc       PROGBITS         00000000005aee30  00179e30</span><br><span class="line">       0000000000019635  0000000000000000           0     0     1</span><br><span class="line">  [19] .zdebug_ranges    PROGBITS         00000000005c8465  00193465</span><br><span class="line">       0000000000008e9e  0000000000000000           0     0     1</span><br><span class="line">  [20] .note.go.buildid  NOTE             0000000000400f9c  00000f9c</span><br><span class="line">       0000000000000064  0000000000000000   A       0     0     4</span><br><span class="line">  [21] .symtab           SYMTAB           0000000000000000  0019c308</span><br><span class="line">       000000000000c420  0000000000000018          22   120     8</span><br><span class="line">  [22] .strtab           STRTAB           0000000000000000  001a8728</span><br><span class="line">       000000000000b07c  0000000000000000           0     0     1</span><br></pre></td></tr></table></figure><h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>objdump -h  支持各种目标文件 这个mac需要<code>brew install binutils</code>安装一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go build -gcflags=<span class="string">&quot;-B -N -l&quot;</span> main.go </span><br><span class="line">objdump -h main // -h 查看段头信息</span><br></pre></td></tr></table></figure><p>可以得到以下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">main:     file format mach-o-x86-64</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA               LMA               File off  Algn</span><br><span class="line">  0 .text         0008a9ed  0000000001001000  0000000001001000  00001000  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, CODE</span><br><span class="line">  1 __TEXT.__symbol_stub1 00000102  000000000108ba00  000000000108ba00  0008ba00  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  2 __TEXT.__rodata 000383f6  000000000108bb20  000000000108bb20  0008bb20  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  3 __TEXT.__typelink 00000538  00000000010c3f20  00000000010c3f20  000c3f20  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  4 __TEXT.__itablink 00000070  00000000010c4460  00000000010c4460  000c4460  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  5 __TEXT.__gosymtab 00000000  00000000010c44d0  00000000010c44d0  000c44d0  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  6 __TEXT.__gopclntab 00061090  00000000010c44e0  00000000010c44e0  000c44e0  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  7 __DATA.__go_buildinfo 00000020  0000000001126000  0000000001126000  00126000  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  8 __DATA.__nl_symbol_ptr 00000158  0000000001126020  0000000001126020  00126020  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  9 __DATA.__noptrdata 00010640  0000000001126180  0000000001126180  00126180  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 10 .data         00007470  00000000011367c0  00000000011367c0  001367c0  2**5</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 11 .bss          0002f048  000000000113dc40  000000000113dc40  00000000  2**5</span><br><span class="line">                  ALLOC</span><br><span class="line"> 12 __DATA.__noptrbss 000051c0  000000000116cca0  000000000116cca0  00000000  2**5</span><br><span class="line">                  ALLOC</span><br><span class="line"> 13 __DWARF.__zdebug_abbrev 00000117  0000000001172000  0000000001172000  0013e000  2**0</span><br><span class="line">                  CONTENTS, DEBUGGING</span><br><span class="line"> 14 __DWARF.__zdebug_line 0001d1ec  0000000001172117  0000000001172117  0013e117  2**0</span><br><span class="line">                  CONTENTS, DEBUGGING</span><br><span class="line"> 15 __DWARF.__zdebug_frame 00005acf  000000000118f303  000000000118f303  0015b303  2**0</span><br><span class="line">                  CONTENTS, DEBUGGING</span><br><span class="line"> 16 .debug_gdb_scripts 0000003e  0000000001194dd2  0000000001194dd2  00160dd2  2**0</span><br><span class="line">                  CONTENTS, DEBUGGING</span><br><span class="line"> 17 __DWARF.__zdebug_info 0003378d  0000000001194e10  0000000001194e10  00160e10  2**0</span><br><span class="line">                  CONTENTS, DEBUGGING</span><br><span class="line"> 18 __DWARF.__zdebug_loc 0001a2d5  00000000011c859d  00000000011c859d  0019459d  2**0</span><br><span class="line">                  CONTENTS, DEBUGGING</span><br><span class="line"> 19 __DWARF.__zdebug_ranges 000082a2  00000000011e2872  00000000011e2872  001ae872  2**0</span><br><span class="line">                  CONTENTS, DEBUGGING</span><br><span class="line"> 20 LC_THREAD.x86_THREAD_STATE64.0 000000a8  0000000000000000  0000000000000000  000007f0  2**0</span><br><span class="line">                  CONTENTS</span><br></pre></td></tr></table></figure><h1 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h1><p>go查看汇编有几种方式:</p><ol><li>go tool compile -S xxx.go</li><li>go build -gcflags=”-S” xxx.go -gcflags其实就是把参数传给compile</li><li>先go build 编译，然后 go tool objdump -S xxx </li><li>objdump -d</li></ol><p>1/2 都是直接编译为汇编，生成的是过程中的机器码汇编。</p><p>3/4属于反汇编，生成是最终机器码汇编。</p><p><em>注意不管是生成的还是反汇编的，SP都是硬件SP，与手写汇编不一致。</em></p><p>这里我们以查看使用的string具体怎么存储，怎么读取的为例。</p><h2 id="过程中的汇编"><a href="#过程中的汇编" class="headerlink" title="过程中的汇编"></a>过程中的汇编</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool compile -B -N -l -S main.go </span><br></pre></td></tr></table></figure><p>裁掉不关注信息可以得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;.main STEXT size=397 args=0x0 locals=0xc0 funcid=0x0</span><br><span class="line">0x0000 00000 (main.go:21)TEXT&quot;&quot;.main(SB), ABIInternal, $192-0</span><br><span class="line">0x0000 00000 (main.go:21)LEAQ-64(SP), R12</span><br><span class="line">0x0005 00005 (main.go:21)CMPQR12, 16(R14)</span><br><span class="line">0x0009 00009 (main.go:21)PCDATA$0, $-2</span><br><span class="line">0x0009 00009 (main.go:21)JLS387</span><br><span class="line">0x000f 00015 (main.go:21)PCDATA$0, $-1</span><br><span class="line">0x000f 00015 (main.go:21)SUBQ$192, SP</span><br><span class="line">0x0016 00022 (main.go:21)MOVQBP, 184(SP)</span><br><span class="line">0x001e 00030 (main.go:21)LEAQ184(SP), BP</span><br><span class="line">0x0026 00038 (main.go:21)FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)</span><br><span class="line">0x0026 00038 (main.go:21)FUNCDATA$1, gclocals·3d3dda67601e66e262180dc10a49f372(SB)</span><br><span class="line">0x0026 00038 (main.go:21)FUNCDATA$2, &quot;&quot;.main.stkobj(SB)</span><br><span class="line">0x0026 00038 (main.go:22)LEAQ&quot;&quot;.svz(SB), DX</span><br><span class="line">0x002d 00045 (main.go:22)MOVQDX, &quot;&quot;..autotmp_1+80(SP)</span><br><span class="line">0x0032 00050 (main.go:22)MOVUPSX15, &quot;&quot;..autotmp_2+88(SP)</span><br><span class="line">0x0038 00056 (main.go:22)LEAQ&quot;&quot;..autotmp_2+88(SP), AX</span><br><span class="line">0x003d 00061 (main.go:22)MOVQAX, &quot;&quot;..autotmp_5+72(SP)</span><br><span class="line">0x0042 00066 (main.go:22)TESTBAL, (AX)</span><br><span class="line">0x0044 00068 (main.go:22)MOVQ&quot;&quot;..autotmp_1+80(SP), DX</span><br><span class="line">0x0049 00073 (main.go:22)LEAQtype.*string(SB), SI</span><br><span class="line">0x0050 00080 (main.go:22)MOVQSI, &quot;&quot;..autotmp_2+88(SP)</span><br><span class="line">0x0055 00085 (main.go:22)MOVQDX, &quot;&quot;..autotmp_2+96(SP)</span><br><span class="line">0x005a 00090 (main.go:22)TESTBAL, (AX)</span><br><span class="line">0x005c 00092 (main.go:22)MOVQAX, &quot;&quot;..autotmp_4+128(SP)</span><br><span class="line">0x0064 00100 (main.go:22)MOVQ$1, &quot;&quot;..autotmp_4+136(SP)</span><br><span class="line">0x0070 00112 (main.go:22)MOVQ$1, &quot;&quot;..autotmp_4+144(SP)</span><br><span class="line">0x007c 00124 (main.go:22)MOVL$1, BX</span><br><span class="line">0x0081 00129 (main.go:22)MOVQBX, CX</span><br><span class="line">0x0084 00132 (main.go:22)PCDATA$1, $0</span><br><span class="line">0x0084 00132 (main.go:22)CALLfmt.Println(SB)</span><br><span class="line">0x0089 00137 (main.go:23)LEAQ&quot;&quot;.svz(SB), DX</span><br><span class="line">0x0090 00144 (main.go:23)TESTBAL, (DX)</span><br><span class="line">0x0092 00146 (main.go:23)MOVQ&quot;&quot;.svz(SB), DX</span><br><span class="line">0x0099 00153 (main.go:23)MOVQDX, &quot;&quot;.trueV+40(SP)</span><br><span class="line">0x009e 00158 (main.go:24)LEAQ&quot;&quot;..autotmp_3+152(SP), DX</span><br><span class="line">0x00a6 00166 (main.go:24)MOVUPSX15, (DX)</span><br><span class="line">0x00aa 00170 (main.go:24)LEAQ&quot;&quot;..autotmp_3+168(SP), DX</span><br><span class="line">0x00b2 00178 (main.go:24)MOVUPSX15, (DX)</span><br><span class="line">0x00b6 00182 (main.go:24)LEAQ&quot;&quot;..autotmp_3+152(SP), DX</span><br><span class="line">0x00be 00190 (main.go:24)MOVQDX, &quot;&quot;..autotmp_7+64(SP)</span><br><span class="line">0x00c3 00195 (main.go:24)MOVQ&quot;&quot;.trueV+40(SP), AX</span><br><span class="line">0x00c8 00200 (main.go:24)PCDATA$1, $1</span><br><span class="line">0x00c8 00200 (main.go:24)CALLruntime.convT64(SB)</span><br><span class="line">0x00cd 00205 (main.go:24)MOVQAX, &quot;&quot;..autotmp_8+56(SP)</span><br><span class="line">0x00d2 00210 (main.go:24)MOVQ&quot;&quot;..autotmp_7+64(SP), DX</span><br><span class="line">0x00d7 00215 (main.go:24)TESTBAL, (DX)</span><br><span class="line">0x00d9 00217 (main.go:24)LEAQtype.uintptr(SB), SI</span><br><span class="line">0x00e0 00224 (main.go:24)MOVQSI, (DX)</span><br><span class="line">0x00e3 00227 (main.go:24)LEAQ8(DX), DI</span><br><span class="line">0x00e7 00231 (main.go:24)PCDATA$0, $-2</span><br><span class="line">0x00e7 00231 (main.go:24)CMPLruntime.writeBarrier(SB), $0</span><br><span class="line">0x00ee 00238 (main.go:24)JEQ242</span><br><span class="line">0x00f0 00240 (main.go:24)JMP248</span><br><span class="line">0x00f2 00242 (main.go:24)MOVQAX, 8(DX)</span><br><span class="line">0x00f6 00246 (main.go:24)JMP255</span><br><span class="line">0x00f8 00248 (main.go:24)CALLruntime.gcWriteBarrier(SB)</span><br><span class="line">0x00fd 00253 (main.go:24)JMP255</span><br><span class="line">0x00ff 00255 (main.go:24)PCDATA$0, $-1</span><br><span class="line">0x00ff 00255 (main.go:24)MOVQ&quot;&quot;.trueV+40(SP), AX</span><br><span class="line">0x0104 00260 (main.go:24)CALLruntime.convT64(SB)</span><br><span class="line">0x0109 00265 (main.go:24)MOVQAX, &quot;&quot;..autotmp_9+48(SP)</span><br><span class="line">0x010e 00270 (main.go:24)MOVQ&quot;&quot;..autotmp_7+64(SP), CX</span><br><span class="line">0x0113 00275 (main.go:24)TESTBAL, (CX)</span><br><span class="line">0x0115 00277 (main.go:24)LEAQtype.uintptr(SB), DX</span><br><span class="line">0x011c 00284 (main.go:24)MOVQDX, 16(CX)</span><br><span class="line">0x0120 00288 (main.go:24)LEAQ24(CX), DI</span><br><span class="line">0x0124 00292 (main.go:24)PCDATA$0, $-2</span><br><span class="line">0x0124 00292 (main.go:24)CMPLruntime.writeBarrier(SB), $0</span><br><span class="line">0x012b 00299 (main.go:24)JEQ303</span><br><span class="line">0x012d 00301 (main.go:24)JMP309</span><br><span class="line">0x012f 00303 (main.go:24)MOVQAX, 24(CX)</span><br><span class="line">0x0133 00307 (main.go:24)JMP316</span><br><span class="line">0x0135 00309 (main.go:24)CALLruntime.gcWriteBarrier(SB)</span><br><span class="line">0x013a 00314 (main.go:24)JMP316</span><br><span class="line">0x013c 00316 (main.go:24)PCDATA$0, $-1</span><br><span class="line">0x013c 00316 (main.go:24)MOVQ&quot;&quot;..autotmp_7+64(SP), CX</span><br><span class="line">0x0141 00321 (main.go:24)TESTBAL, (CX)</span><br><span class="line">0x0143 00323 (main.go:24)MOVQCX, &quot;&quot;..autotmp_6+104(SP)</span><br><span class="line">0x0148 00328 (main.go:24)MOVQ$2, &quot;&quot;..autotmp_6+112(SP)</span><br><span class="line">0x0151 00337 (main.go:24)MOVQ$2, &quot;&quot;..autotmp_6+120(SP)</span><br><span class="line">0x015a 00346 (main.go:24)LEAQgo.string.&quot;0x%x | %v\n&quot;(SB), AX</span><br><span class="line">0x0161 00353 (main.go:24)MOVL$10, BX</span><br><span class="line">0x0166 00358 (main.go:24)MOVL$2, DI</span><br><span class="line">0x016b 00363 (main.go:24)MOVQDI, SI</span><br><span class="line">0x016e 00366 (main.go:24)PCDATA$1, $0</span><br><span class="line">0x016e 00366 (main.go:24)CALLfmt.Printf(SB)</span><br><span class="line">0x0173 00371 (main.go:25)MOVQ184(SP), BP</span><br><span class="line">0x017b 00379 (main.go:25)ADDQ$192, SP</span><br><span class="line">0x0182 00386 (main.go:25)RET</span><br><span class="line">0x0183 00387 (main.go:25)NOP</span><br><span class="line">0x0183 00387 (main.go:21)PCDATA$1, $-1</span><br><span class="line">0x0183 00387 (main.go:21)PCDATA$0, $-2</span><br><span class="line">0x0183 00387 (main.go:21)CALLruntime.morestack_noctxt(SB)</span><br><span class="line">0x0188 00392 (main.go:21)PCDATA$0, $-1</span><br><span class="line">0x0188 00392 (main.go:21)JMP0</span><br><span class="line">0x0000 4c 8d 64 24 c0 4d 3b 66 10 0f 86 74 01 00 00 48  L.d$.M;f...t...H</span><br><span class="line">0x0010 81 ec c0 00 00 00 48 89 ac 24 b8 00 00 00 48 8d  ......H..$....H.</span><br><span class="line">0x0020 ac 24 b8 00 00 00 48 8d 15 00 00 00 00 48 89 54  .$....H......H.T</span><br><span class="line">0x0030 24 50 44 0f 11 7c 24 58 48 8d 44 24 58 48 89 44  $PD..|$XH.D$XH.D</span><br><span class="line">0x0040 24 48 84 00 48 8b 54 24 50 48 8d 35 00 00 00 00  $H..H.T$PH.5....</span><br><span class="line">0x0050 48 89 74 24 58 48 89 54 24 60 84 00 48 89 84 24  H.t$XH.T$`..H..$</span><br><span class="line">0x0060 80 00 00 00 48 c7 84 24 88 00 00 00 01 00 00 00  ....H..$........</span><br><span class="line">0x0070 48 c7 84 24 90 00 00 00 01 00 00 00 bb 01 00 00  H..$............</span><br><span class="line">0x0080 00 48 89 d9 e8 00 00 00 00 48 8d 15 00 00 00 00  .H.......H......</span><br><span class="line">0x0090 84 02 48 8b 15 00 00 00 00 48 89 54 24 28 48 8d  ..H......H.T$(H.</span><br><span class="line">0x00a0 94 24 98 00 00 00 44 0f 11 3a 48 8d 94 24 a8 00  .$....D..:H..$..</span><br><span class="line">0x00b0 00 00 44 0f 11 3a 48 8d 94 24 98 00 00 00 48 89  ..D..:H..$....H.</span><br><span class="line">0x00c0 54 24 40 48 8b 44 24 28 e8 00 00 00 00 48 89 44  T$@H.D$(.....H.D</span><br><span class="line">0x00d0 24 38 48 8b 54 24 40 84 02 48 8d 35 00 00 00 00  $8H.T$@..H.5....</span><br><span class="line">0x00e0 48 89 32 48 8d 7a 08 83 3d 00 00 00 00 00 74 02  H.2H.z..=.....t.</span><br><span class="line">0x00f0 eb 06 48 89 42 08 eb 07 e8 00 00 00 00 eb 00 48  ..H.B..........H</span><br><span class="line">0x0100 8b 44 24 28 e8 00 00 00 00 48 89 44 24 30 48 8b  .D$(.....H.D$0H.</span><br><span class="line">0x0110 4c 24 40 84 01 48 8d 15 00 00 00 00 48 89 51 10  L$@..H......H.Q.</span><br><span class="line">0x0120 48 8d 79 18 83 3d 00 00 00 00 00 74 02 eb 06 48  H.y..=.....t...H</span><br><span class="line">0x0130 89 41 18 eb 07 e8 00 00 00 00 eb 00 48 8b 4c 24  .A..........H.L$</span><br><span class="line">0x0140 40 84 01 48 89 4c 24 68 48 c7 44 24 70 02 00 00  @..H.L$hH.D$p...</span><br><span class="line">0x0150 00 48 c7 44 24 78 02 00 00 00 48 8d 05 00 00 00  .H.D$x....H.....</span><br><span class="line">0x0160 00 bb 0a 00 00 00 bf 02 00 00 00 48 89 fe e8 00  ...........H....</span><br><span class="line">0x0170 00 00 00 48 8b ac 24 b8 00 00 00 48 81 c4 c0 00  ...H..$....H....</span><br><span class="line">0x0180 00 00 c3 e8 00 00 00 00 e9 73 fe ff ff           .........s...</span><br><span class="line">rel 3+0 t=24 type.*string+0</span><br><span class="line">rel 3+0 t=24 type.uintptr+0</span><br><span class="line">rel 3+0 t=24 type.uintptr+0</span><br><span class="line">rel 41+4 t=15 &quot;&quot;.svz+0</span><br><span class="line">rel 76+4 t=15 type.*string+0</span><br><span class="line">rel 133+4 t=7 fmt.Println+0</span><br><span class="line">rel 140+4 t=15 &quot;&quot;.svz+0</span><br><span class="line">rel 149+4 t=15 &quot;&quot;.svz+0</span><br><span class="line">rel 201+4 t=7 runtime.convT64+0</span><br><span class="line">rel 220+4 t=15 type.uintptr+0</span><br><span class="line">rel 233+4 t=15 runtime.writeBarrier+-1</span><br><span class="line">rel 249+4 t=7 runtime.gcWriteBarrier+0</span><br><span class="line">rel 261+4 t=7 runtime.convT64+0</span><br><span class="line">rel 280+4 t=15 type.uintptr+0</span><br><span class="line">rel 294+4 t=15 runtime.writeBarrier+-1</span><br><span class="line">rel 310+4 t=7 runtime.gcWriteBarrier+0</span><br><span class="line">rel 349+4 t=15 go.string.&quot;0x%x | %v\n&quot;+0</span><br><span class="line">rel 367+4 t=7 fmt.Printf+0</span><br><span class="line">rel 388+4 t=7 runtime.morestack_noctxt+0</span><br><span class="line">go.string.&quot;svz-svz&quot; SRODATA dupok size=7</span><br><span class="line">0x0000 73 76 7a 2d 73 76 7a                             svz-svz</span><br><span class="line">go.string.&quot;0x%x | %v\n&quot; SRODATA dupok size=10</span><br><span class="line">0x0000 30 78 25 78 20 7c 20 25 76 0a                    0x%x | %v.</span><br><span class="line">&quot;&quot;.svz SDATA size=16</span><br><span class="line">0x0000 00 00 00 00 00 00 00 00 07 00 00 00 00 00 00 00  ................</span><br><span class="line">rel 0+8 t=1 go.string.&quot;svz-svz&quot;+0</span><br><span class="line">runtime.gcbits.02 SRODATA dupok size=1</span><br><span class="line">0x0000 02                                               .</span><br><span class="line">runtime.gcbits.0a SRODATA dupok size=1</span><br><span class="line">0x0000 0a                                               .</span><br><span class="line">type..importpath.fmt. SRODATA dupok size=5</span><br><span class="line">0x0000 00 03 66 6d 74                                   ..fmt</span><br><span class="line">type..importpath.reflect. SRODATA dupok size=9</span><br><span class="line">0x0000 00 07 72 65 66 6c 65 63 74                       ..reflect</span><br><span class="line">type..importpath.unsafe. SRODATA dupok size=8</span><br><span class="line">0x0000 00 06 75 6e 73 61 66 65                          ..unsafe</span><br><span class="line">gclocals·69c1753bd5f81501d95132d08af04464 SRODATA dupok size=8</span><br><span class="line">0x0000 02 00 00 00 00 00 00 00                          ........</span><br><span class="line">gclocals·3d3dda67601e66e262180dc10a49f372 SRODATA dupok size=14</span><br><span class="line">0x0000 02 00 00 00 11 00 00 00 00 00 00 04 00 00        ..............</span><br><span class="line">&quot;&quot;.main.stkobj SRODATA static size=56</span><br><span class="line">0x0000 02 00 00 00 00 00 00 00 a0 ff ff ff 10 00 00 00  ................</span><br><span class="line">0x0010 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................</span><br><span class="line">0x0020 e0 ff ff ff 20 00 00 00 20 00 00 00 00 00 00 00  .... ... .......</span><br><span class="line">0x0030 00 00 00 00 00 00 00 00                          ........</span><br><span class="line">rel 24+8 t=1 runtime.gcbits.02+0</span><br><span class="line">rel 48+8 t=1 runtime.gcbits.0a+0</span><br></pre></td></tr></table></figure><blockquote><p>S(ymbol)开头的表示符号类型 具体可见<a href="https://github.com/golang/go/blob/master/src/cmd/link/internal/sym/symkind.go#L42">SymbolKind</a></p><p>DATA 表示数据，RODATA 表示只读数据</p><p>TEXT 表示符号</p><p>dupok 表示数据只有一份</p></blockquote><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>挑重点看一下</p><ol><li><p>符号定义</p><p><code>&quot;&quot;.main STEXT size=397 args=0x0 locals=0xc0 funcid=0x0</code></p><p>“”.main 是符号名</p><p>STEXT 表示符号是函数</p><p>size为占用大小</p><p>args参数大小</p><p>locals局部变量大小</p><p>funcid表示函数类型0为普通函数,具体可见<a href="https://github.com/golang/go/blob/master/src/cmd/internal/objabi/funcid.go#L26">funcid</a></p></li></ol><p>   下方跟了一段反编译代码</p><p>   反编译代码后为原始二进制编码</p><p>   再下方为引用的数据,简单看一个</p><p>   <code>rel 140+4 t=15 &quot;&quot;.svz+0</code></p><p>   分别为 rel 偏移+长度 t=重定位类型(具体定义见<a href="https://github.com/golang/go/blob/master/src/cmd/internal/objabi/reloctype.go#L37">RelocType</a>) 符号名+偏移量</p><p>   140号位置也就是(0x8c)长度为4字节的空间为””.svz+0的数据引用</p><p>   可以具体位置<code>0x0080 00 48 89 d9 e8 00 00 00 00 48 8d 15 00 00 00 00  .H.......H......</code>最后四子节全为0，因为是引用数据</p><ol><li><p>字符串定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go.string.&quot;svz-svz&quot; SRODATA dupok size=7</span><br><span class="line">0x0000 73 76 7a 2d 73 76 7a                             svz-svz</span><br></pre></td></tr></table></figure><p>go.string.”svz-svz” 符号名</p><p>SRODATA 表示符号是只读数据</p><p>dupok 表示只有一份</p><p>size 为占用大小</p></li><li><p>变量定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  &quot;&quot;.svz SDATA size=16</span><br><span class="line">  0x0000 00 00 00 00 00 00 00 00 07 00 00 00 00 00 00 00  ................</span><br><span class="line">rel 0+8 t=1 go.string.&quot;svz-svz&quot;+0</span><br></pre></td></tr></table></figure><p>“”.svz  符号名</p><p>SDATA 表示符号是数据</p><p>size 为占用大小 16是因为字符串底层为 data指针+长度</p><p>先看后8字节  07 00 00 00 00 00 00 00 因为是小端，实际为00 00 00 00 00 00 00 07 也就是7</p><p>再看下方的rel</p><p>0号位置长度为8字节的空间 为go.string.”svz-svz”+0的数据引用</p></li></ol><p>过程中的就只能看到这么多信息了。</p><h2 id="最终的汇编"><a href="#最终的汇编" class="headerlink" title="最终的汇编"></a>最终的汇编</h2><p>先看go tool的版本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go tool objdump -gnu -s main.main main // -gnu 同时输出gnu风格的汇编 -s 匹配指定符号名</span><br></pre></td></tr></table></figure><p>裁出来main函数汇编如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">TEXT main.main(SB) /Users/svz/code/test/test/main.go</span><br><span class="line">  main.go:210x108b8604c8d6424c0LEAQ -0x40(SP), R12                  // lea -0x40(%rsp),%r12</span><br><span class="line">  main.go:210x108b8654d3b6610CMPQ 0x10(R14), R12                  // cmp 0x10(%r14),%r12</span><br><span class="line">  main.go:210x108b8690f8674010000JBE 0x108b9e3                        // jbe 0x108b9e3</span><br><span class="line">  main.go:210x108b86f4881ecc0000000SUBQ $0xc0, SP                       // sub $0xc0,%rsp</span><br><span class="line">  main.go:210x108b8764889ac24b8000000MOVQ BP, 0xb8(SP)                    // mov %rbp,0xb8(%rsp)</span><br><span class="line">  main.go:210x108b87e488dac24b8000000LEAQ 0xb8(SP), BP                    // lea 0xb8(%rsp),%rbp</span><br><span class="line">  main.go:220x108b886488d1503b70a00LEAQ main.svz(SB), DX                // lea 0xab703(%rip),%rdx</span><br><span class="line">  main.go:220x108b88d4889542450MOVQ DX, 0x50(SP)                    // mov %rdx,0x50(%rsp)</span><br><span class="line">  main.go:220x108b892440f117c2458MOVUPS X15, 0x58(SP)                 // movups %xmm15,0x58(%rsp)</span><br><span class="line">  main.go:220x108b898488d442458LEAQ 0x58(SP), AX                    // lea 0x58(%rsp),%rax</span><br><span class="line">  main.go:220x108b89d4889442448MOVQ AX, 0x48(SP)                    // mov %rax,0x48(%rsp)</span><br><span class="line">  main.go:220x108b8a28400TESTB AL, 0(AX)                      // test %al,(%rax)</span><br><span class="line">  main.go:220x108b8a4488b542450MOVQ 0x50(SP), DX                    // mov 0x50(%rsp),%rdx</span><br><span class="line">  main.go:220x108b8a9488d35105d0000LEAQ runtime.types+23200(SB), SI     // lea 0x5d10(%rip),%rsi</span><br><span class="line">  main.go:220x108b8b04889742458MOVQ SI, 0x58(SP)                    // mov %rsi,0x58(%rsp)</span><br><span class="line">  main.go:220x108b8b54889542460MOVQ DX, 0x60(SP)                    // mov %rdx,0x60(%rsp)</span><br><span class="line">  main.go:220x108b8ba8400TESTB AL, 0(AX)                      // test %al,(%rax)</span><br><span class="line">  main.go:220x108b8bc4889842480000000MOVQ AX, 0x80(SP)                    // mov %rax,0x80(%rsp)</span><br><span class="line">  main.go:220x108b8c448c784248800000001000000MOVQ $0x1, 0x88(SP)                  // movq $0x1,0x88(%rsp)</span><br><span class="line">  main.go:220x108b8d048c784249000000001000000MOVQ $0x1, 0x90(SP)                  // movq $0x1,0x90(%rsp)</span><br><span class="line">  main.go:220x108b8dcbb01000000MOVL $0x1, BX                        // mov $0x1,%ebx</span><br><span class="line">  main.go:220x108b8e14889d9MOVQ BX, CX                          // mov %rbx,%rcx</span><br><span class="line">  main.go:220x108b8e4e8d795ffffCALL fmt.Println(SB)                 // callq 0x1084ec0</span><br><span class="line">  main.go:230x108b8e9488d15a0b60a00LEAQ main.svz(SB), DX                // lea 0xab6a0(%rip),%rdx</span><br><span class="line">  main.go:230x108b8f08402TESTB AL, 0(DX)                      // test %al,(%rdx)</span><br><span class="line">  main.go:230x108b8f2488b1597b60a00MOVQ main.svz(SB), DX                // mov 0xab697(%rip),%rdx</span><br><span class="line">  main.go:230x108b8f94889542428MOVQ DX, 0x28(SP)                    // mov %rdx,0x28(%rsp)</span><br><span class="line">  main.go:240x108b8fe488d942498000000LEAQ 0x98(SP), DX                    // lea 0x98(%rsp),%rdx</span><br><span class="line">  main.go:240x108b906440f113aMOVUPS X15, 0(DX)                    // movups %xmm15,(%rdx)</span><br><span class="line">  main.go:240x108b90a488d9424a8000000LEAQ 0xa8(SP), DX                    // lea 0xa8(%rsp),%rdx</span><br><span class="line">  main.go:240x108b912440f113aMOVUPS X15, 0(DX)                    // movups %xmm15,(%rdx)</span><br><span class="line">  main.go:240x108b916488d942498000000LEAQ 0x98(SP), DX                    // lea 0x98(%rsp),%rdx</span><br><span class="line">  main.go:240x108b91e4889542440MOVQ DX, 0x40(SP)                    // mov %rdx,0x40(%rsp)</span><br><span class="line">  main.go:240x108b923488b442428MOVQ 0x28(SP), AX                    // mov 0x28(%rsp),%rax</span><br><span class="line">  main.go:240x108b928e893d8f7ffCALL runtime.convT64(SB)             // callq 0x10091c0</span><br><span class="line">  main.go:240x108b92d4889442438MOVQ AX, 0x38(SP)                    // mov %rax,0x38(%rsp)</span><br><span class="line">  main.go:240x108b932488b542440MOVQ 0x40(SP), DX                    // mov 0x40(%rsp),%rdx</span><br><span class="line">  main.go:240x108b9378402TESTB AL, 0(DX)                      // test %al,(%rdx)</span><br><span class="line">  main.go:240x108b939488d35007b0000LEAQ runtime.types+31008(SB), SI     // lea 0x7b00(%rip),%rsi</span><br><span class="line">  main.go:240x108b940488932MOVQ SI, 0(DX)                       // mov %rsi,(%rdx)</span><br><span class="line">  main.go:240x108b943488d7a08LEAQ 0x8(DX), DI                     // lea 0x8(%rdx),%rdi</span><br><span class="line">  main.go:240x108b947833dd2150e0000CMPL $0x0, runtime.writeBarrier(SB)  // cmpl $0x0,0xe15d2(%rip)</span><br><span class="line">  main.go:240x108b94e7402JE 0x108b952                         // je 0x108b952</span><br><span class="line">  main.go:240x108b950eb06JMP 0x108b958                        // jmp 0x108b958</span><br><span class="line">  main.go:240x108b95248894208MOVQ AX, 0x8(DX)                     // mov %rax,0x8(%rdx)</span><br><span class="line">  main.go:240x108b956eb07JMP 0x108b95f                        // jmp 0x108b95f</span><br><span class="line">  main.go:240x108b958e8c3f7fcffCALL runtime.gcWriteBarrier(SB)      // callq 0x105b120</span><br><span class="line">  main.go:240x108b95deb00JMP 0x108b95f                        // jmp 0x108b95f</span><br><span class="line">  main.go:240x108b95f488b442428MOVQ 0x28(SP), AX                    // mov 0x28(%rsp),%rax</span><br><span class="line">  main.go:240x108b964e857d8f7ffCALL runtime.convT64(SB)             // callq 0x10091c0</span><br><span class="line">  main.go:240x108b9694889442430MOVQ AX, 0x30(SP)                    // mov %rax,0x30(%rsp)</span><br><span class="line">  main.go:240x108b96e488b4c2440MOVQ 0x40(SP), CX                    // mov 0x40(%rsp),%rcx</span><br><span class="line">  main.go:240x108b9738401TESTB AL, 0(CX)                      // test %al,(%rcx)</span><br><span class="line">  main.go:240x108b975488d15c47a0000LEAQ runtime.types+31008(SB), DX     // lea 0x7ac4(%rip),%rdx</span><br><span class="line">  main.go:240x108b97c48895110MOVQ DX, 0x10(CX)                    // mov %rdx,0x10(%rcx)</span><br><span class="line">  main.go:240x108b980488d7918LEAQ 0x18(CX), DI                    // lea 0x18(%rcx),%rdi</span><br><span class="line">  main.go:240x108b984833d95150e0000CMPL $0x0, runtime.writeBarrier(SB)  // cmpl $0x0,0xe1595(%rip)</span><br><span class="line">  main.go:240x108b98b7402JE 0x108b98f                         // je 0x108b98f</span><br><span class="line">  main.go:240x108b98deb06JMP 0x108b995                        // jmp 0x108b995</span><br><span class="line">  main.go:240x108b98f48894118MOVQ AX, 0x18(CX)                    // mov %rax,0x18(%rcx)</span><br><span class="line">  main.go:240x108b993eb07JMP 0x108b99c                        // jmp 0x108b99c</span><br><span class="line">  main.go:240x108b995e886f7fcffCALL runtime.gcWriteBarrier(SB)      // callq 0x105b120</span><br><span class="line">  main.go:240x108b99aeb00JMP 0x108b99c                        // jmp 0x108b99c</span><br><span class="line">  main.go:240x108b99c488b4c2440MOVQ 0x40(SP), CX                    // mov 0x40(%rsp),%rcx</span><br><span class="line">  main.go:240x108b9a18401TESTB AL, 0(CX)                      // test %al,(%rcx)</span><br><span class="line">  main.go:240x108b9a348894c2468MOVQ CX, 0x68(SP)                    // mov %rcx,0x68(%rsp)</span><br><span class="line">  main.go:240x108b9a848c744247002000000MOVQ $0x2, 0x70(SP)                  // movq $0x2,0x70(%rsp)</span><br><span class="line">  main.go:240x108b9b148c744247802000000MOVQ $0x2, 0x78(SP)                  // movq $0x2,0x78(%rsp)</span><br><span class="line">  main.go:240x108b9ba488d053d840100LEAQ go.string.*+3230(SB), AX        // lea 0x1843d(%rip),%rax</span><br><span class="line">  main.go:240x108b9c1bb0a000000MOVL $0xa, BX                        // mov $0xa,%ebx</span><br><span class="line">  main.go:240x108b9c6bf02000000MOVL $0x2, DI                        // mov $0x2,%edi</span><br><span class="line">  main.go:240x108b9cb4889feMOVQ DI, SI                          // mov %rdi,%rsi</span><br><span class="line">  main.go:240x108b9cee84d93ffffCALL fmt.Printf(SB)                  // callq 0x1084d20</span><br><span class="line">  main.go:250x108b9d3488bac24b8000000MOVQ 0xb8(SP), BP                    // mov 0xb8(%rsp),%rbp</span><br><span class="line">  main.go:250x108b9db4881c4c0000000ADDQ $0xc0, SP                       // add $0xc0,%rsp</span><br><span class="line">  main.go:250x108b9e2c3RET                                  // retq</span><br><span class="line">  main.go:210x108b9e3e858d7fcffCALL runtime.morestack_noctxt.abi0(SB) // callq 0x1059140</span><br><span class="line">  main.go:210x108b9e8e973feffffJMP main.main(SB)                    // jmpq 0x108b860</span><br></pre></td></tr></table></figure><p>这里生成的就带上了具体地址信息了</p><p>把使用字符串的挑出来看</p><p>  main.go:22        0x108b886        488d1503b70a00            LEAQ main.svz(SB), DX                // lea 0xab703(%rip),%rdx        </p><p>可以看到把main.svz(SB)的地址放到了DX，1.17之后为寄存器传参</p><p>对应的gnu汇编则是将0xab703(%rip)地址放到了%rdx,0xab703(%rip)换算过来就是0x1136f90，对比运行结果就是变量svz的地址</p><p>对于go tool来说，也只能看到这一层了，想要再深一点就得上objdump了</p><p>下面来用objdump来看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -d -j .text  main</span><br></pre></td></tr></table></figure><p>截取main.main部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">000000000108b860 &lt;_main.main&gt;:</span><br><span class="line"> 108b860:4c 8d 64 24 c0       lea    -0x40(%rsp),%r12</span><br><span class="line"> 108b865:4d 3b 66 10          cmp    0x10(%r14),%r12</span><br><span class="line"> 108b869:0f 86 74 01 00 00    jbe    108b9e3 &lt;_main.main+0x183&gt;</span><br><span class="line"> 108b86f:48 81 ec c0 00 00 00 sub    $0xc0,%rsp</span><br><span class="line"> 108b876:48 89 ac 24 b8 00 00 mov    %rbp,0xb8(%rsp)</span><br><span class="line"> 108b87d:00 </span><br><span class="line"> 108b87e:48 8d ac 24 b8 00 00 lea    0xb8(%rsp),%rbp</span><br><span class="line"> 108b885:00 </span><br><span class="line"> 108b886:48 8d 15 03 b7 0a 00 lea    0xab703(%rip),%rdx        # 1136f90 &lt;_main.svz&gt;</span><br><span class="line"> 108b88d:48 89 54 24 50       mov    %rdx,0x50(%rsp)</span><br><span class="line"> 108b892:44 0f 11 7c 24 58    movups %xmm15,0x58(%rsp)</span><br><span class="line"> 108b898:48 8d 44 24 58       lea    0x58(%rsp),%rax</span><br><span class="line"> 108b89d:48 89 44 24 48       mov    %rax,0x48(%rsp)</span><br><span class="line"> 108b8a2:84 00                test   %al,(%rax)</span><br><span class="line"> 108b8a4:48 8b 54 24 50       mov    0x50(%rsp),%rdx</span><br><span class="line"> 108b8a9:48 8d 35 10 5d 00 00 lea    0x5d10(%rip),%rsi        # 10915c0 &lt;_runtime.rodata+0x5aa0&gt;</span><br><span class="line"> 108b8b0:48 89 74 24 58       mov    %rsi,0x58(%rsp)</span><br><span class="line"> 108b8b5:48 89 54 24 60       mov    %rdx,0x60(%rsp)</span><br><span class="line"> 108b8ba:84 00                test   %al,(%rax)</span><br><span class="line"> 108b8bc:48 89 84 24 80 00 00 mov    %rax,0x80(%rsp)</span><br><span class="line"> 108b8c3:00 </span><br><span class="line"> 108b8c4:48 c7 84 24 88 00 00 movq   $0x1,0x88(%rsp)</span><br><span class="line"> 108b8cb:00 01 00 00 00 </span><br><span class="line"> 108b8d0:48 c7 84 24 90 00 00 movq   $0x1,0x90(%rsp)</span><br><span class="line"> 108b8d7:00 01 00 00 00 </span><br><span class="line"> 108b8dc:bb 01 00 00 00       mov    $0x1,%ebx</span><br><span class="line"> 108b8e1:48 89 d9             mov    %rbx,%rcx</span><br><span class="line"> 108b8e4:e8 d7 95 ff ff       call   1084ec0 &lt;_fmt.Println&gt;</span><br><span class="line"> 108b8e9:48 8d 15 a0 b6 0a 00 lea    0xab6a0(%rip),%rdx        # 1136f90 &lt;_main.svz&gt;</span><br><span class="line"> 108b8f0:84 02                test   %al,(%rdx)</span><br><span class="line"> 108b8f2:48 8b 15 97 b6 0a 00 mov    0xab697(%rip),%rdx        # 1136f90 &lt;_main.svz&gt;</span><br><span class="line"> 108b8f9:48 89 54 24 28       mov    %rdx,0x28(%rsp)</span><br><span class="line"> 108b8fe:48 8d 94 24 98 00 00 lea    0x98(%rsp),%rdx</span><br><span class="line"> 108b905:00 </span><br><span class="line"> 108b906:44 0f 11 3a          movups %xmm15,(%rdx)</span><br><span class="line"> 108b90a:48 8d 94 24 a8 00 00 lea    0xa8(%rsp),%rdx</span><br><span class="line"> 108b911:00 </span><br><span class="line"> 108b912:44 0f 11 3a          movups %xmm15,(%rdx)</span><br><span class="line"> 108b916:48 8d 94 24 98 00 00 lea    0x98(%rsp),%rdx</span><br><span class="line"> 108b91d:00 </span><br><span class="line"> 108b91e:48 89 54 24 40       mov    %rdx,0x40(%rsp)</span><br><span class="line"> 108b923:48 8b 44 24 28       mov    0x28(%rsp),%rax</span><br><span class="line"> 108b928:e8 93 d8 f7 ff       call   10091c0 &lt;_runtime.convT64&gt;</span><br><span class="line"> 108b92d:48 89 44 24 38       mov    %rax,0x38(%rsp)</span><br><span class="line"> 108b932:48 8b 54 24 40       mov    0x40(%rsp),%rdx</span><br><span class="line"> 108b937:84 02                test   %al,(%rdx)</span><br><span class="line"> 108b939:48 8d 35 00 7b 00 00 lea    0x7b00(%rip),%rsi        # 1093440 &lt;_runtime.rodata+0x7920&gt;</span><br><span class="line"> 108b940:48 89 32             mov    %rsi,(%rdx)</span><br><span class="line"> 108b943:48 8d 7a 08          lea    0x8(%rdx),%rdi</span><br><span class="line"> 108b947:83 3d d2 15 0e 00 00 cmpl   $0x0,0xe15d2(%rip)        # 116cf20 &lt;_runtime.writeBarrier&gt;</span><br><span class="line"> 108b94e:74 02                je     108b952 &lt;_main.main+0xf2&gt;</span><br><span class="line"> 108b950:eb 06                jmp    108b958 &lt;_main.main+0xf8&gt;</span><br><span class="line"> 108b952:48 89 42 08          mov    %rax,0x8(%rdx)</span><br><span class="line"> 108b956:eb 07                jmp    108b95f &lt;_main.main+0xff&gt;</span><br><span class="line"> 108b958:e8 c3 f7 fc ff       call   105b120 &lt;_runtime.gcWriteBarrier&gt;</span><br><span class="line"> 108b95d:eb 00                jmp    108b95f &lt;_main.main+0xff&gt;</span><br><span class="line"> 108b95f:48 8b 44 24 28       mov    0x28(%rsp),%rax</span><br><span class="line"> 108b964:e8 57 d8 f7 ff       call   10091c0 &lt;_runtime.convT64&gt;</span><br><span class="line"> 108b969:48 89 44 24 30       mov    %rax,0x30(%rsp)</span><br><span class="line"> 108b96e:48 8b 4c 24 40       mov    0x40(%rsp),%rcx</span><br><span class="line"> 108b973:84 01                test   %al,(%rcx)</span><br><span class="line"> 108b975:48 8d 15 c4 7a 00 00 lea    0x7ac4(%rip),%rdx        # 1093440 &lt;_runtime.rodata+0x7920&gt;</span><br><span class="line"> 108b97c:48 89 51 10          mov    %rdx,0x10(%rcx)</span><br><span class="line"> 108b980:48 8d 79 18          lea    0x18(%rcx),%rdi</span><br><span class="line"> 108b984:83 3d 95 15 0e 00 00 cmpl   $0x0,0xe1595(%rip)        # 116cf20 &lt;_runtime.writeBarrier&gt;</span><br><span class="line"> 108b98b:74 02                je     108b98f &lt;_main.main+0x12f&gt;</span><br><span class="line"> 108b98d:eb 06                jmp    108b995 &lt;_main.main+0x135&gt;</span><br><span class="line"> 108b98f:48 89 41 18          mov    %rax,0x18(%rcx)</span><br><span class="line"> 108b993:eb 07                jmp    108b99c &lt;_main.main+0x13c&gt;</span><br><span class="line"> 108b995:e8 86 f7 fc ff       call   105b120 &lt;_runtime.gcWriteBarrier&gt;</span><br><span class="line"> 108b99a:eb 00                jmp    108b99c &lt;_main.main+0x13c&gt;</span><br><span class="line"> 108b99c:48 8b 4c 24 40       mov    0x40(%rsp),%rcx</span><br><span class="line"> 108b9a1:84 01                test   %al,(%rcx)</span><br><span class="line"> 108b9a3:48 89 4c 24 68       mov    %rcx,0x68(%rsp)</span><br><span class="line"> 108b9a8:48 c7 44 24 70 02 00 movq   $0x2,0x70(%rsp)</span><br><span class="line"> 108b9af:00 00 </span><br><span class="line"> 108b9b1:48 c7 44 24 78 02 00 movq   $0x2,0x78(%rsp)</span><br><span class="line"> 108b9b8:00 00 </span><br><span class="line"> 108b9ba:48 8d 05 3d 84 01 00 lea    0x1843d(%rip),%rax        # 10a3dfe &lt;_go.string.*+0xc9e&gt;</span><br><span class="line"> 108b9c1:bb 0a 00 00 00       mov    $0xa,%ebx</span><br><span class="line"> 108b9c6:bf 02 00 00 00       mov    $0x2,%edi</span><br><span class="line"> 108b9cb:48 89 fe             mov    %rdi,%rsi</span><br><span class="line"> 108b9ce:e8 4d 93 ff ff       call   1084d20 &lt;_fmt.Printf&gt;</span><br><span class="line"> 108b9d3:48 8b ac 24 b8 00 00 mov    0xb8(%rsp),%rbp</span><br><span class="line"> 108b9da:00 </span><br><span class="line"> 108b9db:48 81 c4 c0 00 00 00 add    $0xc0,%rsp</span><br><span class="line"> 108b9e2:c3                   ret    </span><br><span class="line"> 108b9e3:e8 58 d7 fc ff       call   1059140 &lt;_runtime.morestack_noctxt.abi0&gt;</span><br><span class="line"> 108b9e8:e9 73 fe ff ff       jmp    108b860 &lt;_main.main&gt;</span><br></pre></td></tr></table></figure><p>还是捞出使用string的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">108b886:   48 8d 15 03 b7 0a 00    lea    0xab703(%rip),%rdx        # 1136f90 &lt;_main.svz&gt;</span><br></pre></td></tr></table></figure><p>可以看到和go tool的地址一致，也就是0x1136f90，这里直接帮忙计算出来了，免得自己算</p><p>通过上方头信息可以得知1136f90在data段</p><p>再来看data段信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -s -j .data  main</span><br></pre></td></tr></table></figure><p>截取<code>1136f90</code>的部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1136f90 ae380a01 00000000 07000000 00000000  .8..............</span><br></pre></td></tr></table></figure><p>可以看到16字节内容，其实就是变量svz的内容</p><p>拆成两段，</p><p><code>ae380a01 00000000</code> 小端模式转换出来就是 <code>010a38ae</code> 对比程序输出就是实际字符位置</p><p><code>07000000 00000000</code> 小端模式转换出来就是<code>7</code>，也就是长度</p><p>通过上方头信息得知<code>010a38ae</code>在 <code>__TEXT.__rodata</code> 段</p><p>再来看<code>__TEXT.__rodata</code>段信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -s -j __TEXT.__rodata main</span><br></pre></td></tr></table></figure><p>裁出来<code>010a38ae</code>部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10a38a0 72756e6e 696e6773 69676e61 6c207376  runningsignal sv</span><br><span class="line">10a38b0 7a2d7376 7a737973 63616c6c 75696e74  z-svzsyscalluint</span><br></pre></td></tr></table></figure><p>可以看到<code>010a38ae</code>部分为<code>svz-svz</code>即我们给的值</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ol><li><p>示例代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file    main.go</span></span><br><span class="line"><span class="comment"> * @author  903943711@qq.com</span></span><br><span class="line"><span class="comment"> *  ___  _  _  ____</span></span><br><span class="line"><span class="comment"> * / __)( \/ )(_   )</span></span><br><span class="line"><span class="comment"> * \__ \ \  /  / /_</span></span><br><span class="line"><span class="comment"> * (___/  \/  (____)</span></span><br><span class="line"><span class="comment"> * @date    2021/9/8</span></span><br><span class="line"><span class="comment"> * @desc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> svz = <span class="string">&quot;svz-svz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(&amp;svz)</span><br><span class="line">trueV := (*reflect.StringHeader)(unsafe.Pointer(&amp;svz)).Data</span><br><span class="line">fmt.Printf(<span class="string">&quot;0x%x | %v\n&quot;</span>, trueV, trueV)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> asm </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-base-gomod</title>
      <link href="/p/363974412.html"/>
      <url>/p/363974412.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>gomod 是官方在go1.11推出的包管理器，并且从Go1.13版本开始，gomod是Go语言默认的依赖管理工具。</p><span id="more"></span><p>首先我们得了解一下，在引入gomod前，Go中包导入的顺序：</p><ol><li>首先查看当前目录有无vendor目录，如果有，先搜寻vendor中；</li><li>然后去GOROOT中搜寻；</li><li>最后去GOPATH中搜寻；</li></ol><p>这也是为什么你的项目一定是要放在GOPATH中。而引入了gomod之后，流程就不一样了。开启gomod后，所有的依赖包会存放在<code>GOPATH/pkg</code>下面，所以多个项目都可以共享同一份，而不用每个项目拉取一份。</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>主要是有几个环境变量：</p><h3 id="GO111MODULE"><a href="#GO111MODULE" class="headerlink" title="GO111MODULE"></a>GO111MODULE</h3><p>就是gomod的开关</p><ul><li><p><code>off</code></p><p>关闭gomodule功能，流程与原来一致。</p></li><li><p><code>on</code></p><p>go命令行会使用modules，并且不会去GOPATH目录下查找。</p></li><li><p><code>auto</code></p><p>默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：</p><ul><li>当前目录在GOPATH/src之外且该目录包含go.mod文件</li><li>当前文件在包含go.mod文件的目录下面。</li></ul></li></ul><h3 id="GOPROXY"><a href="#GOPROXY" class="headerlink" title="GOPROXY"></a>GOPROXY</h3><p>配置的代理，由于众所周知的原因，想访问一些仓库访问不到，就得走代理配置了</p><ul><li><p><code>&lt;url&gt;[,&lt;url&gt;][,direct]</code> </p><p>  默认值是<code>https://proxy.golang.org,direct</code>，配置多个会依次去寻找，最后的<code>direct</code>则是如果都没找到就去源地址</p></li><li><p><code> </code></p><p>  置空则是不走代理</p></li></ul><h3 id="GOPRIVATE"><a href="#GOPRIVATE" class="headerlink" title="GOPRIVATE"></a>GOPRIVATE</h3><p>配置在这里的表示是私有仓库，不会走proxy下载也不会做校验</p><ul><li><p><code>&lt;url&gt;[,&lt;url&gt;]</code></p><p>  举个例子</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOPRIVATE=*.corp.example.com,rsc.io/private</span><br></pre></td></tr></table></figure><p>  就是git.corp.example.com abc.corp.example.com rsc.io/private   rsc.io/private/abc 都不会走proxy下载也不会做校验了</p></li></ul><h3 id="GOSUMDB"><a href="#GOSUMDB" class="headerlink" title="GOSUMDB"></a>GOSUMDB</h3><p>在对依赖进行变动（更新/添加）操作时会自动维护一个go.sum,然后去这个服务器做校验,防止模块被篡改。</p><ul><li><p><code>&lt;db_name&gt;+&lt;publickey&gt;+&lt;url&gt;</code> </p><p>  默认值是 <code>sum.golang.org</code>，这是google的校验服务器，下面这几种写法都可</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GOSUMDB=<span class="string">&quot;sum.golang.org&quot;</span></span><br><span class="line">GOSUMDB=<span class="string">&quot;sum.golang.org+&lt;publickey&gt;&quot;</span></span><br><span class="line">GOSUMDB=<span class="string">&quot;sum.golang.org+&lt;publickey&gt; https://sum.golang.org&quot;</span></span><br></pre></td></tr></table></figure><p>  因为对于 <a href="http://sum.golang.org，Go">http://sum.golang.org，Go</a> 自己知道其对应的 publickey 和 url，所以我们只要配置一个名字即可。除此之外的，都需要指明 publickey，url 默认是 https://\<db_name></p></li><li><p><code>off</code> </p><p>  关闭校验，国内基本只能关闭了</p></li></ul><h3 id="GONOSUMDB"><a href="#GONOSUMDB" class="headerlink" title="GONOSUMDB"></a>GONOSUMDB</h3><p>关闭校验的部分</p><ul><li><p><code>&lt;url&gt;[,&lt;url&gt;]</code></p><p>  举个例子</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GONOSUMDB=*.corp.example.com,rsc.io/private</span><br></pre></td></tr></table></figure><p>   就是git.corp.example.com abc.corp.example.com rsc.io/private   rsc.io/private/abc 都不会做校验了</p></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="go-mod-init"><a href="#go-mod-init" class="headerlink" title="go mod init"></a>go mod init</h3><p>初始化仓库，会在当前目录创建一个go.mod</p><h3 id="go-mod-download"><a href="#go-mod-download" class="headerlink" title="go mod download"></a>go mod download</h3><p>下载当前go.mod中的依赖</p><h3 id="go-mod-edit"><a href="#go-mod-edit" class="headerlink" title="go mod edit"></a>go mod edit</h3><p>编辑go.mod，具体可以查看<code>go help mod edit</code></p><h3 id="go-mod-tidy"><a href="#go-mod-tidy" class="headerlink" title="go mod tidy"></a>go mod tidy</h3><p>检查依赖，删除有问题的或者无用的依赖，下载没有的依赖</p><h3 id="go-mod-vendor"><a href="#go-mod-vendor" class="headerlink" title="go mod vendor"></a>go mod vendor</h3><p>生成vendor目录并将依赖放入其中</p><h3 id="go-mod-verify"><a href="#go-mod-verify" class="headerlink" title="go mod verify"></a>go mod verify</h3><p>校验依赖</p><h3 id="go-mod-why"><a href="#go-mod-why" class="headerlink" title="go mod why"></a>go mod why</h3><p>查看依赖原因</p><h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go.mod"></a>go.mod</h2><p>这里我们看一个<code>go.mod</code>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module example.com/test</span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">  golang.org/x/test1 v0<span class="number">.3</span><span class="number">.0</span></span><br><span class="line">  gopkg.in/x/test2 v2<span class="number">.1</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">  golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190313024323</span>-a1f597ede03a <span class="comment">// indirect</span></span><br><span class="line">  test v0<span class="number">.0</span><span class="number">.1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">replace (</span><br><span class="line">  golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190313024323</span>-a1f597ede03a =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190313024323</span>-a1f597ede03a</span><br><span class="line"> test =&gt; ../test</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>里面一共分3块</p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>最开始的module表示的是本模块路径。</p><h3 id="module-1"><a href="#module-1" class="headerlink" title="module"></a>module</h3><p>表示的是依赖的模块</p><p>第一项为路径</p><p>第二项为版本,go module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit，所以会有crypto后面的这种版本格式,</p><p>后面的注释indirect则代表是间接引用,没有则是直接引用</p><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>这里可以将某些get不到的库替换成别的位置的库或者本地的库</p><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>举个例子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">go-test</span><br><span class="line"></span><br><span class="line">├── go.mod</span><br><span class="line">├── test</span><br><span class="line">│   └── test1</span><br><span class="line">│       └── test2</span><br><span class="line">│           └── test3</span><br><span class="line">│               ├── a.go</span><br><span class="line">│               └── go.mod</span><br><span class="line">├── test1</span><br><span class="line">│   └── a.go</span><br><span class="line">└── test2</span><br><span class="line">    ├── b.go</span><br><span class="line">    └── go.mod</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这么一个结构如果想按tag引入的话怎么引入？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//引入v0.0.1的go-test</span><br><span class="line">git tag v0.0.1</span><br><span class="line">go get github.com/SVz777/go-test@v0.0.1</span><br><span class="line"></span><br><span class="line">//引入v0.0.1的go-test/test2</span><br><span class="line">git tag test2/v0.0.1</span><br><span class="line">go get github.com/SVz777/go-test/test2@v0.0.1</span><br><span class="line"></span><br><span class="line">//引入v0.0.1的go-test/test/test1/test2/test3</span><br><span class="line">git tag test/test1/test2/test3/v0.0.1</span><br><span class="line">go get github.com/SVz777/go-test/test/test1/test2/test3@v0.0.1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也就是tag得打成对应module的相对路径@版本号</p><h2 id="go工具链"><a href="#go工具链" class="headerlink" title="go工具链"></a>go工具链</h2><h3 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h3><p><code>go get</code>做的操作都会同步影响到go.mod</p><h3 id="go-build-go-run"><a href="#go-build-go-run" class="headerlink" title="go build / go run"></a>go build / go run</h3><p>如果发现依赖不存在会先去下载</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-reflect</title>
      <link href="/p/8e84ce49.html"/>
      <url>/p/8e84ce49.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p><code>Go</code>中的反射使用的就是官方提供的<code>reflect</code>这个包</p><span id="more"></span><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h3 id="类型reflect-Type"><a href="#类型reflect-Type" class="headerlink" title="类型reflect.Type"></a>类型<code>reflect.Type</code></h3><p>主要是使用<code>reflect.Typeof()</code>获取到变量的类型信息(<code>reflect.Type</code>)，再通过里面一些方法拿到想要的属性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a/a.go</span></span><br><span class="line"><span class="keyword">package</span> a</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.go</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;./a&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := a.A&#123;</span><br><span class="line">Name: <span class="string">&quot;hello reflect&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">v := reflect.TypeOf(a)</span><br><span class="line">fmt.Println(<span class="string">&quot;string\t&quot;</span>, v.String())         <span class="comment">//全名称：[包名.]类型名</span></span><br><span class="line">fmt.Println(<span class="string">&quot;kind\t&quot;</span>, v.Kind())             <span class="comment">//类型</span></span><br><span class="line">fmt.Println(<span class="string">&quot;pkgpath\t&quot;</span>, v.PkgPath())       <span class="comment">//包名 包名可能为空</span></span><br><span class="line">fmt.Println(<span class="string">&quot;name\t&quot;</span>, v.Name())             <span class="comment">//类型名 可能为空</span></span><br><span class="line">fmt.Println(<span class="string">&quot;comparable\t&quot;</span>, v.Comparable()) <span class="comment">//是否可以比较</span></span><br><span class="line">fmt.Println(<span class="string">&quot;size\t&quot;</span>, v.Size())             <span class="comment">// 占用字节</span></span><br><span class="line">fmt.Println(<span class="string">&quot;align\t&quot;</span>, v.Align())           <span class="comment">// 对齐字节 一般没啥用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="type">string</span>   a.A</span><br><span class="line">kind     <span class="keyword">struct</span></span><br><span class="line">pkgpath  .../a <span class="comment">//省略了前面的路径</span></span><br><span class="line">name     A</span><br><span class="line">comparable       <span class="literal">true</span></span><br><span class="line">size     <span class="number">16</span></span><br><span class="line">align    <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>reflect.Type</code>的方法很多，但是可不可以使用取决于变量本身的类型，比如<code>Len()</code>方法<code>string</code>是使用不了的，这里整理了一个表格供大家参考</p><p>示例代码位于:</p><div class="table-container"><table><thead><tr><th>类型</th><th>可用方法列表</th><th>用途</th><th></th></tr></thead><tbody><tr><td>通用</td><td>String</td><td>全名称：[包名.]类型名</td><td></td></tr><tr><td></td><td>Kind</td><td>类型</td><td></td></tr><tr><td></td><td>Name</td><td>类型名 可能为空</td><td></td></tr><tr><td></td><td>PkgPath</td><td>包名 包名可能为空</td><td></td></tr><tr><td></td><td>Comparable</td><td>是否可以比较</td><td></td></tr><tr><td></td><td>Size</td><td>占用字节</td><td></td></tr><tr><td></td><td>Align</td><td>对齐字节</td><td></td></tr><tr><td>Struct</td><td>FieldAlign</td><td>字段内存对齐字节</td><td></td></tr><tr><td></td><td>NumField</td><td>字段数</td><td></td></tr><tr><td></td><td>Field</td><td>根据索引获取字段</td><td></td></tr><tr><td></td><td>FieldByName</td><td>根据名称获取字段</td><td></td></tr><tr><td></td><td>NumMethod</td><td>导出的方法数</td><td></td></tr><tr><td></td><td>Method</td><td>根据索引获取方法，只能访问导出的方法(大写的)</td><td></td></tr><tr><td></td><td>MethodByName</td><td>根据名称获取方法，只能访问导出的方法(大写的)</td><td></td></tr><tr><td></td><td>FieldByIndex</td><td>当struct是嵌套的，这个方法可以找到内嵌的字段,第0个字段的第0个字段</td><td></td></tr><tr><td></td><td>FieldByNameFunc</td><td>根据所给的方法查找,如果多个匹配返回第一个匹配的</td><td></td></tr><tr><td>Func</td><td>NumIn</td><td>入参个数</td><td></td></tr><tr><td></td><td>NumOut</td><td>返回值个数</td><td></td></tr><tr><td></td><td>In</td><td>获取入参索引位置的类型</td><td></td></tr><tr><td></td><td>Out</td><td>获取返回值索引位置的类型</td><td></td></tr><tr><td></td><td>IsVariadic</td><td>是否有可变参数 比如… float64</td><td></td></tr><tr><td>Channel</td><td>ChanDir</td><td>channel方向</td><td></td></tr><tr><td>Array</td><td>Len</td><td>长度</td><td></td></tr><tr><td>Slice</td><td>无</td><td></td><td></td></tr><tr><td>Map</td><td>Key</td><td>key的类型</td><td></td></tr><tr><td>Array,Slice,Channel,Map,Pinter</td><td>Elem</td><td>内部元素的类型</td><td></td></tr><tr><td>数字类型</td><td>Bits</td><td>占用bit数</td></tr></tbody></table></div><p>还有几个特殊方法</p><h3 id="AssignableTo-v-interface"><a href="#AssignableTo-v-interface" class="headerlink" title="AssignableTo(v interface{})"></a><code>AssignableTo(v interface&#123;&#125;)</code></h3><p>判断能不能把v赋值给自己</p><h3 id="ConvertibleTo-v-interface"><a href="#ConvertibleTo-v-interface" class="headerlink" title="ConvertibleTo(v interface{})"></a><code>ConvertibleTo(v interface&#123;&#125;)</code></h3><p>判断能不能和v进行比较</p><h3 id="Implements-v-interface"><a href="#Implements-v-interface" class="headerlink" title="Implements(v interface{})"></a><code>Implements(v interface&#123;&#125;)</code></h3><p>v只能传接口,判断有没有实现这个接口,使用起来会比较复杂，下面给出示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Empty <span class="keyword">interface</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">v := reflect.TypeOf(a)</span><br><span class="line">fmt.Println(v.Implements(reflect.TypeOf((*Empty)(<span class="literal">nil</span>)).Elem()))<span class="comment">// true</span></span><br><span class="line">  fmt.Println(v.Implements(reflect.TypeOf((*Test)(<span class="literal">nil</span>)).Elem()))<span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值reflect-Value"><a href="#值reflect-Value" class="headerlink" title="值reflect.Value"></a>值<code>reflect.Value</code></h2><p>上文所有的操作都是和类型相关的，那么如何对实际的值进行操作呢?</p><p>首先得明确一点，那就是<code>Go</code>的参数传递都是值传递的，所以想要修改本身，得传递自身的指针.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;a)</span><br><span class="line">fmt.Println(v.CanSet())<span class="comment">// false</span></span><br><span class="line">fmt.Println(v.Elem().CanSet())<span class="comment">// true</span></span><br><span class="line">v.Elem().Set(reflect.ValueOf(<span class="number">5</span>))</span><br><span class="line">fmt.Println(a)<span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到,<code>v</code>本身是不能修改的，而<code>v.Elem()</code>v的元素是可以修改的，这是什么意思呢?其实就是 指针的指向是不能修改的，但是指针指向的值可以修改的。</p><p>同样，下面整理了一份表格以供查阅</p><p>示例代码位于:</p><h1 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h1><h1 id="进阶理解"><a href="#进阶理解" class="headerlink" title="进阶理解"></a>进阶理解</h1>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reflect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome_unsafe</title>
      <link href="/p/3070668180.html"/>
      <url>/p/3070668180.html</url>
      
        <content type="html"><![CDATA[<p>chrome经常会碰到 您的链接不是私密连接 不让访问，有时候自己内部搭的站点访问不上就很蛋疼，这里给一个可行的解决方案</p><span id="more"></span><p>在被拦截页面用键盘输入<code>thisisunsafe</code>，就是用键盘敲出来就行， 页面即会自动刷新进入网页</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-RWmutex</title>
      <link href="/p/2476363181.html"/>
      <url>/p/2476363181.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>使用互斥锁，可以避免多个 Go 协程同时访问修改共享资源的代码。但是对于多个协程同时读的操作，没有修改共享资源，不需要添加互斥锁，互斥锁在这种场景下，会大幅度降低程序性能。</p><p>在这种场景下，我们真正需要具有读并发、互斥写、读写互斥等特点的逻辑，读写锁是其中的一种实现。</p><span id="more"></span><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>声明一个读写锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m *sync.RWMutex</span><br></pre></td></tr></table></figure><p>读加锁和读解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.RLock()</span><br><span class="line">m.RUnlock()</span><br></pre></td></tr></table></figure><p>写加锁和写解锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.Lock()</span><br><span class="line">m.Unlock()</span><br></pre></td></tr></table></figure><p>读写锁拥有以下特点：</p><ol><li>并发读；可以同时加多个读锁</li><li>互斥写；写逻辑互斥，在任何一个时间点都一个协程获取到写锁。</li><li>读写互斥；当写锁加锁成功时，获取读锁的协程休眠，等待写锁释放。 当存在读加锁时，获取写锁的协程休眠，等待所有读锁释放。</li></ol><p>来看一个完整的case：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m *sync.RWMutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m = <span class="built_in">new</span>(sync.RWMutex)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> read(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">go</span> write(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> read(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">2</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(i,<span class="string">&quot;read start&quot;</span>)</span><br><span class="line"></span><br><span class="line">    m.RLock()</span><br><span class="line">    <span class="built_in">println</span>(i,<span class="string">&quot;reading&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">    m.RUnlock()    </span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(i,<span class="string">&quot;read over&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">write</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">println</span>(i,<span class="string">&quot;write start&quot;</span>)</span><br><span class="line"></span><br><span class="line">    m.Lock()</span><br><span class="line">    <span class="built_in">println</span>(i,<span class="string">&quot;writing&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">    m.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println</span>(i,<span class="string">&quot;write over&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h1><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>互斥源码所在位置：go/src/sync/rwmutex.go， RWMutex结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">w           Mutex  <span class="comment">// 互斥锁</span></span><br><span class="line">writerSem   <span class="type">uint32</span> <span class="comment">// 写锁信号</span></span><br><span class="line">readerSem   <span class="type">uint32</span> <span class="comment">// 读锁信号（当写锁加上时，所有获取读锁的goutinue都会监听该信号，进行休眠等待。 写锁释放时，唤醒所有监听该信号的goroutinue）</span></span><br><span class="line">readerCount <span class="type">int32</span>  <span class="comment">// 获取到读锁的数量</span></span><br><span class="line">readerWait  <span class="type">int32</span>  <span class="comment">// 等待释放读锁的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h2><h3 id="写锁加锁"><a href="#写锁加锁" class="headerlink" title="写锁加锁"></a>写锁加锁</h3><p>写锁加锁逻辑：</p><ol><li><p>获取读写锁的读锁数量，将读锁数量置为一个负数，准确值是：readerCount-rwmutexMaxReaders</p></li><li><p>如果读锁数量不为0，更新readerWait字段，将当前协程（获取写锁的线程）进行休眠，监听writerSem信号，等待所有读锁数量释放。</p></li></ol><p>在读锁解锁逻辑里面，我们可以看到readerWait为0时，发出writerSem信号，唤醒获取写锁的协程。</p><p>代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Lock() &#123;</span><br><span class="line">    <span class="keyword">if</span> race.Enabled &#123;  <span class="comment">// 竞态分析，忽略</span></span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line">rw.w.Lock()  <span class="comment">// 真实上锁，如果这里获取不到，在这里就会休眠。（见metux锁实现）</span></span><br><span class="line"><span class="comment">// Announce to readers there is a pending writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders   <span class="comment">// 获取读锁数量，且将读锁数量置为一个负数，这里为什么要置为一个负数？见后续</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;  <span class="comment">// 如果读锁数量不为0， 将读锁数量累加到readerWait待释放读锁数量中，进行休眠（等待所有读锁数量释放，再进行后续操作）</span></span><br><span class="line">runtime_SemacquireMutex(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; <span class="comment">// 竞态分析，忽略</span></span><br><span class="line">race.Enable()</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="写锁解锁"><a href="#写锁解锁" class="headerlink" title="写锁解锁"></a>写锁解锁</h3><p>写锁解锁逻辑：</p><ol><li>将读锁数量恢复正常，即负数-&gt;正数唤醒</li><li>发出readerSem信号，唤醒所有监听该信号的协程</li><li>执行解锁逻辑</li></ol><p>代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> Unlock() &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;  <span class="comment">// 竞态分析，忽略</span></span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Release(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Announce to readers there is no active writer.</span></span><br><span class="line">    r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)  <span class="comment">// 将读锁数量加上rwmutexMaxReaders，恢复正常数量，获取读锁数量</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> r &gt;= rwmutexMaxReaders &#123;                         <span class="comment">// 读锁加锁数量如果大于最大读数量，抛出异常</span></span><br><span class="line">race.Enable()</span><br><span class="line">throw(<span class="string">&quot;sync: Unlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(r); i++ &#123;                       <span class="comment">// 唤醒所有等待读锁的goroutinue（一旦写锁加上后，所有获取读锁的操作都会休眠）</span></span><br><span class="line">runtime_Semrelease(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Allow other writers to proceed.</span></span><br><span class="line">rw.w.Unlock()                                       <span class="comment">// 真实解锁，这里会唤醒其他等待写锁的goroutinue（见metux锁实现）</span></span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;  <span class="comment">// 竞态分析，忽略</span></span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h2><h3 id="读锁加锁"><a href="#读锁加锁" class="headerlink" title="读锁加锁"></a>读锁加锁</h3><p>读锁加锁逻辑：</p><ol><li>将读锁数量加一</li><li>如果读锁数量为负数时，即存在获取写锁的操作，将当前goroutinue休眠，监听readerSem信号，等待写锁释放时唤醒</li></ol><p>代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RLock() &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;  <span class="comment">// 竞态分析，忽略</span></span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;  <span class="comment">// 读锁数量+1，如果读锁数量为负(某个routinue获取写锁，后面所有读锁只能休眠，等待写锁的完成)，休眠当前gouroutinue</span></span><br><span class="line">runtime_SemacquireMutex(&amp;rw.readerSem, <span class="literal">false</span>, <span class="number">0</span>) <span class="comment">// 这里readerSem 数量为自增1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;  <span class="comment">// 竞态分析，忽略</span></span><br><span class="line">race.Enable()</span><br><span class="line">race.Acquire(unsafe.Pointer(&amp;rw.readerSem))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="读锁解锁"><a href="#读锁解锁" class="headerlink" title="读锁解锁"></a>读锁解锁</h3><p>读锁写锁逻辑：</p><ol><li>将读锁数量减一</li><li>读锁数量为负数，即当前存在获取写锁的goroutinue逻辑，将readerWait减一。</li><li>readerWait == 0 即：获取所有人都释放读锁，发出writerSem信号，唤醒获取写锁的goroutinue。</li></ol><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> RUnlock() &#123;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; <span class="comment">// 竞态分析，忽略</span></span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;   <span class="comment">// 读锁数量-1；小于0情况有两种，1.为加读锁，直接解锁。2. 某个线程将要获取写锁</span></span><br><span class="line">rw.rUnlockSlow(r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123; <span class="comment">// 竞态分析，忽略</span></span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *RWMutex)</span></span> rUnlockSlow(r <span class="type">int32</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> r+<span class="number">1</span> == <span class="number">0</span> || r+<span class="number">1</span> == -rwmutexMaxReaders &#123;   <span class="comment">// 如果r+1 == 0, 即r == -1, 未加读锁，直接解锁。 异常</span></span><br><span class="line">race.Enable()                            <span class="comment">// 如果r+1 == -rwmutexMaxReaders， 即r == -(rwmutexMaxReaders+1)，这里就算是某个goroutinue将要获取写锁，将readerCount 置为 readerCount-rwmutexMaxReaders，这个数字也不会小于-rwmutexMaxReaders 异常</span></span><br><span class="line">throw(<span class="string">&quot;sync: RUnlock of unlocked RWMutex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A writer is pending.</span></span><br><span class="line"><span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;   <span class="comment">// 某个goroutinue将要获取写锁，这里如果readerWait == 0，即 所有读锁全部解锁了，唤醒获取写锁的goroutinue</span></span><br><span class="line"><span class="comment">// The last reader unblocks the writer.</span></span><br><span class="line">runtime_Semrelease(&amp;rw.writerSem, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mutex </tag>
            
            <tag> RWmutex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-sync_map</title>
      <link href="/p/2de3d308.html"/>
      <url>/p/2de3d308.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h2 id="为什么需要sync-Map"><a href="#为什么需要sync-Map" class="headerlink" title="为什么需要sync.Map?"></a>为什么需要sync.Map?</h2><p>在Go 1.6之前， 内置map类型是部分goroutine安全，并发读没有问题，并发写可能有问题。</p><p>Go1.6之后， 并发读写map会报错，推荐用户直接用读写锁对map进行保护，也有第三方类库使用分段锁。</p><p>在1.9版本中，基于原本的map，新增了一个支持并发操作的map，叫sync map。</p><span id="more"></span><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="Go-1-9之前解决并发读写问题方案"><a href="#Go-1-9之前解决并发读写问题方案" class="headerlink" title="Go 1.9之前解决并发读写问题方案"></a>Go 1.9之前解决并发读写问题方案</h2><p>通过在结构体中加入读写锁,并且在读写之前先获取锁,使用完成之后释放锁<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syM := <span class="keyword">struct</span>&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)&#125;</span><br><span class="line"><span class="comment">//读数据的时候很方便的加锁：</span></span><br><span class="line">syM.RLock()</span><br><span class="line">n := syM.m[<span class="string">&quot;key1&quot;</span>]</span><br><span class="line">syM.RUnlock()</span><br><span class="line"><span class="comment">//写数据的时候:</span></span><br><span class="line">syM.Lock()</span><br><span class="line">syM.m[<span class="string">&quot;key1&quot;</span>]++</span><br><span class="line">syM.Unlock()</span><br></pre></td></tr></table></figure></p><h2 id="sync-Map使用方法"><a href="#sync-Map使用方法" class="headerlink" title="sync.Map使用方法"></a>sync.Map使用方法</h2><h2 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sm sync.Map</span><br></pre></td></tr></table></figure><p>添加元素 store</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sm.Store(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="读取元素-load"><a href="#读取元素-load" class="headerlink" title="读取元素 load"></a>读取元素 load</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v,ok:=sm.Load(<span class="number">1</span>);ok &#123;</span><br><span class="line">    fmt.Println(v)  <span class="comment">// a</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取或者保存-LoadOrStore"><a href="#获取或者保存-LoadOrStore" class="headerlink" title="获取或者保存 LoadOrStore"></a>获取或者保存 LoadOrStore</h2><p>参数是一对key：value，如果该key存在且没有被标记删除则返回原先的value（不更新）和true；不存在则store，返回该value 和false</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> v,ok:=sm.LoadOrStore(<span class="number">1</span>,<span class="string">&quot;c&quot;</span>);ok&#123;</span><br><span class="line">    fmt.Println(v) <span class="comment">// a</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> v,ok:=sm.LoadOrStore(<span class="number">2</span>,<span class="string">&quot;c&quot;</span>);!ok&#123;</span><br><span class="line">    fmt.Println(v) <span class="comment">// c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历map"><a href="#遍历map" class="headerlink" title="遍历map"></a>遍历map</h2><p>遍历该map，参数是个函数，该函数参的两个参数是遍历获得的key和value，返回一个bool值，当返回false时，遍历立刻结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sm.Range(<span class="function"><span class="keyword">func</span><span class="params">(k,v <span class="keyword">interface</span>&#123;&#125;)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">    fmt.Print(k) </span><br><span class="line">    fmt.Print(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">    fmt.Print(v)</span><br><span class="line">    fmt.Println()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//运行结果：</span></span><br><span class="line"><span class="comment">//1:a</span></span><br><span class="line"><span class="comment">//2:c</span></span><br></pre></td></tr></table></figure><h2 id="sync-map内部使用了map"><a href="#sync-map内部使用了map" class="headerlink" title="sync.map内部使用了map"></a>sync.map内部使用了map</h2><p>之前我们在讲解map是说过map本身是指针，因此当把sync.map当做函数参数传递，并且在函数内部就行修改，会影响到原sync.map。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sm sync.Map</span><br><span class="line">    sm.Store(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    b := sm</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>,b)</span><br><span class="line">    changerMap(b)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%p\n&quot;</span>,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changerMap</span><span class="params">(b sync.Map)</span></span> &#123;</span><br><span class="line">     b.LoadOrStore(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何复制一个map？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MapCopy</span><span class="params">(sm sync.Map)</span></span> sync.Map &#123;</span><br><span class="line">    <span class="keyword">var</span> newMp sync.Map</span><br><span class="line">    sm.Range(<span class="function"><span class="keyword">func</span><span class="params">(k,v <span class="keyword">interface</span>&#123;&#125;)</span></span><span class="type">bool</span>&#123;</span><br><span class="line">        newMp.Store(k,v)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newMp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用实现</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;encoding/gob&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepCopy</span><span class="params">(dst, src <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    <span class="keyword">if</span> err := gob.NewEncoder(&amp;buf).Encode(src); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gob.NewDecoder(bytes.NewBuffer(buf.Bytes())).Decode(dst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h1><h2 id="sync-map的总体结构"><a href="#sync-map的总体结构" class="headerlink" title="sync.map的总体结构"></a>sync.map的总体结构</h2><p>总结构如图所示：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/2de3d308/sync_map.png" class="" title="sync.map总体结构"><p>sync.Map的原理其实是用空间换时间的策略，通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</p><p>通过引入两个map将读写分离到不同的map，其中read map提供并发读和已存元素原子写，而dirty map则负责读写。 </p><p>这样read map就可以在不加锁的情况下进行并发读取,当read map中没有读取到值时,再加锁进行后续读取,并累加未命中数,当未命中数大于等于dirty map长度,将dirty map上升为read map。</p><p>从结构体的定义可以发现，虽然引入了两个map，但是底层数据存储的是指针，指向的是同一份值。</p><p>sync.map结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex  <span class="comment">// 加锁作用，保护 dirty 字段</span></span><br><span class="line">    read atomic.Value <span class="comment">// 只读的数据，实际数据类型为 readOnly</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry <span class="comment">// 最新写入的数据</span></span><br><span class="line">    misses <span class="type">int</span> <span class="comment">// 计数器，每次需要读 dirty 则 +1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read map 和 dirty map 的存储方式是不一致的——前者使用 atomic.Value，后者只是单纯的使用 map。</p><p>其实，这样的原因是 read map 是一个给 lock free 操作使用的数据结构，必须保证 load/store 的原子性，而 dirty map 的 load+store 操作是由 lock （就是 mu）来保护的。</p><blockquote><p>lock free：无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步</p></blockquote><p>read的数据结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type readOnly struct &#123;</span><br><span class="line">    m       map[interface&#123;&#125;]*entry // 内建 map</span><br><span class="line">    amended bool // 表示 dirty 里存在 read 里没有的 key，通过该字段决定是否加锁读 dirty</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read map与 dirty map在读写环节的转换</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/2de3d308/sync_map_rel.png" class="" title="read_map与dirty_map"><p>在读环节，先使用read map，再使用dirty map。其中读环节可能会触发dirty map到read map的升级(将dirty map内容给到read map read map 置空)。</p><p>在修改环节，先使用read map，再使用dirty map。其中当dirty map不存在此key时，追加此key。</p><p>在新增环节，使用read map，当dirty map 为空时，会触发read map迁移到dirty map</p><p>entry的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">//可见value是个指针类型，虽然read和dirty存在冗余情况（amended=false），但是由于是指针类型，存储的空间不会浪费</span></span><br><span class="line">    p unsafe.Pointer <span class="comment">// 等同于 *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 entry 其实就是正常 map 中的 value，但是为什么这里使用一个 entry 结构来做一层 wrapper 呢？ </p><p>其实，这是因为在对某个 key 做删除的时候，会由于内建的map不是thread-safe的，所以无法达到lock free，然而通过这个entry我们可以添加一些状态来回避这个问题，从注释中可以看到 entry 有三个状态：</p><p>1.p == nil: 键值已经被删除，且 m.dirty == nil(这样我们不需要执行 non-thread-safe 的 delete(m, key) 操作)</p><p>2.p == expunged: 键值已经被删除，但 m.dirty!=nil 且 m.dirty 不存在该键值（expunged 实际是空接口指针）</p><p>3.除以上情况，则键值对存在，存在于 m.read.m 中，如果 m.dirty!=nil 则也存在于 m.dirty</p><p>为了方便理解expunged，我们可以可以看看read map与dirty map存储：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/2de3d308/sync_map_expunged.png" class="" title="sync.map的read drity map对比"></p><p>从上图中可以看出，read map 和 dirty map 中含有相同的一部分 entry，我们称作是 normal entries，是双方共享的，并且其中的 entry.p 只会是两种状态:nil、unexpunged(未删除的)</p><p>但是 read map 中含有一部分 entry 是不属于 dirty map 的，而这部分 entry 就是状态为 expunged</p><p>而 dirty map 中有一部分 entry 也是不属于 read map 的，而这部分其实是来自 Store 操作形成的（也就是新增的 entry），换句话说就是新增的 entry 是出现在 dirty map 中的。</p><h2 id="map的加载"><a href="#map的加载" class="headerlink" title="map的加载"></a>map的加载</h2><p>首先我们先看一个大概的流程图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/2de3d308/sync_map_load.png" class="" title="sync.map_load"></p><p>首先是从readonly里面读，读不到时候才加锁去 map.dirty 里面读，并且加锁之后首先是进行double check。</p><p>double check 之后即使不存在于m.read中，经过miss几次之后，m.dirty会被提升为m.read，又会从m.read中查找。所以对于更新／增加较少，加载存在的key很多的case,性能基本和无锁的map类似。</p><p>missLocked方法中可能会将m.dirty提升，m,misses会记录从readOnly中获取不到 *entry 的次数，也就是miss的次数，如果达到了 len(m.dirty) 就会原子的替换m.read.m 为 m.dirty。提升后m.dirty、m.misses重置， 并且m.read.amended为false。</p><p>下面我们详细看源码部分：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.首先从m.read中加载只读的readOnly, 从它的map中查找，无锁。</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly) <span class="comment">// double check</span></span><br><span class="line">    e, ok = read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 从m.dirty查找</span></span><br><span class="line">            e, ok = m.dirty[key] </span><br><span class="line">            <span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line">            <span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原子加载 *entry 所保存的value。</span></span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map的存储"><a href="#map的存储" class="headerlink" title="map的存储"></a>map的存储</h2><p>首先我们先看一个大概的流程图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/2de3d308/sync_map_story.png" class="" title="sync.map_story"></p><p>整体思路就是：</p><p>1.如果从 read map 中能够找到 normal entry 的话，那么就直接 update 这个 entry 就行（lock free</p><p>2.否则，就上锁，对 dirty map 进行相关操作</p><p>其中2步骤分三种情况</p><p>2.1 double check流程：需要重新 check 一下 read map 中的内容，如果发现仍然是 expunged 的，那么会将 expunged 标记为 nil，并且在 dirty map 里面添加相应 key（这里其实就是将这个 entry 从一个 expunged 的 entry 变成了 normal entry）</p><p>2.2 dirty map处理流程：如果发现这个 key 并不属于 read，但属于 dirty 的时候，直接更新相应的值即可。</p><p>2.3 全新数据流程：在这种情况下，我们需要同时修改 read map 和 dirty map：如果 read map 没有被修改过（read.ameded==false），则意味着我们需要初始化 dirty map（read map 没有修改过表明 dirty map 有可能还未被使用，可能是 nil）。</p><p>下面我们详细看源码部分：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 1. 如果m.read存在这个键，并且这个entry没有被标记删除(expunged)，那么cas自旋更新value。</span></span><br><span class="line">    <span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. m.read不存在或者已经被标记删除</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// double check</span></span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123; <span class="comment">//标记成未被删除</span></span><br><span class="line">            <span class="comment">//m.dirty中不存在这个键，所以加入m.dirty</span></span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123; <span class="comment">// m.dirty存在这个键，更新</span></span><br><span class="line">    e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//新键值</span></span><br><span class="line">    <span class="keyword">if</span> !read.amended &#123; <span class="comment">//m.dirty中没有比m.readOnly更新的数据，往m.dirty中增加第一个新键</span></span><br><span class="line">        <span class="comment">// 从m.read中复制未删除的数据</span></span><br><span class="line">        <span class="comment">// 并标记m.read已经落后于m.dirty</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将这个entry加入到m.dirty中</span></span><br><span class="line">    m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cas自旋更新value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *<span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">if</span> p == expunged &#123;  <span class="comment">// 没有加锁，因此存在被删除的可能</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从m.read中复制未删除的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line"><span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read, _ := m.read.Load().(readOnly)</span><br><span class="line">m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line"><span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line"><span class="keyword">if</span> !e.tryExpungeLocked() &#123; <span class="comment">// 注意此处是cas操作，不是已经拿到锁了？原因是read map与dirty map的entry使用指针，下文delete时可能不加锁删除</span></span><br><span class="line">m.dirty[k] = e</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map的加载或存储"><a href="#map的加载或存储" class="headerlink" title="map的加载或存储"></a>map的加载或存储</h2><p>如果对应的元素存在，则返回该元素的值，如果不存在，则将元素写入到sync.Map。如果已加载值，则加载结果为true;如果已存储，则为false。</p><p>单数据不在read map 存在时，此处story过程和上述story一样。</p><p>下面我们详细看源码部分：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadOrStore(key, value <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 不加锁的情况下读取read map</span></span><br><span class="line">    <span class="comment">// 第一次检测</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">    <span class="comment">// 如果元素存在（是否标识为删除由tryLoadOrStore执行处理），尝试获取该元素已存在的值或者将元素写入</span></span><br><span class="line">        actual, loaded, ok := e.tryLoadOrStore(value)</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            <span class="keyword">return</span> actual, loaded</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    <span class="comment">// 第二次检测</span></span><br><span class="line">    <span class="comment">// 以下逻辑和Store相同</span></span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">    <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">    m.dirty[key] = e</span><br><span class="line">    &#125;</span><br><span class="line">    actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">    actual, loaded, _ = e.tryLoadOrStore(value)</span><br><span class="line">    m.missLocked()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">    <span class="comment">// We&#x27;re adding the first new key to the dirty map.</span></span><br><span class="line">    <span class="comment">// Make sure it is allocated and mark the read-only map as incomplete.</span></span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    m.dirty[key] = newEntry(value)</span><br><span class="line">    actual, loaded = value, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> actual, loaded</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果没有删除元素，tryLoadOrStore将自动加载或存储一个值。如果删除元素，tryLoadOrStore保持条目不变并返回ok= false。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryLoadOrStore(i <span class="keyword">interface</span>&#123;&#125;) (actual <span class="keyword">interface</span>&#123;&#125;, loaded, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="comment">// 元素标识删除，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在该元素真实值，则直接返回原来的元素值</span></span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新更新元素值</span></span><br><span class="line">    ic := i</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, unsafe.Pointer(&amp;ic)) &#123;</span><br><span class="line">    <span class="keyword">return</span> i, <span class="literal">false</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">interface</span>&#123;&#125;)(p), <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map的删除"><a href="#map的删除" class="headerlink" title="map的删除"></a>map的删除</h2><p>首先我们先看一个大概的流程图：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/2de3d308/sync_map_delete.png" class="" title="sync.sync_map_delete"></p><p>这里会删除 m.dirty 对应的key-value, 但是m.read中的key-value其实并没有删除，只是设置了删除的标志为expunged。这里的惰性删除避免了重新创建 entry 实体，只用更新指针和value指针。</p><p>下面我们详细看源码部分：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 1. 如果不存在于 m.read中，而且 m.dirty 和 m.read 数据不一致。</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">    <span class="comment">// 加锁，double check， 然后删除对应的key。</span></span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里会删除 m.dirty 对应的key-value, </span></span><br><span class="line"><span class="comment">// 但是m.read中的key-value其实并没有删除，只是设置了删除的标志为expunged。</span></span><br><span class="line"><span class="comment">// 这里的惰性删除避免了重新创建 entry 实体，只用更新指针和value指针。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (hadValue <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><p>sync.map无法使用系统提供的 for range 操作。这里采用了一个回调的操作：</p><p>下面我们详细看源码部分：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果m.dirty中有新数据，则提升m.dirty,然后再遍历</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">        <span class="comment">//提升m.dirty</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">            read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">            m.read.Store(read)</span><br><span class="line">            m.dirty = <span class="literal">nil</span></span><br><span class="line">            m.misses = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历, for range是安全的</span></span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        v, ok := e.load()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="进阶理解"><a href="#进阶理解" class="headerlink" title="进阶理解"></a>进阶理解</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>1.空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。</p><p>2.使用只读数据(read)，避免读写冲突。</p><p>3.动态调整，miss次数多了之后，将dirty数据提升为read。</p><p>4.double-checking。</p><p>5.延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。</p><p>6.优先从read读取、更新、删除，因为对read的读取不需要锁。</p><h2 id="sync-map与map性能对比"><a href="#sync-map与map性能对比" class="headerlink" title="sync.map与map性能对比"></a>sync.map与map性能对比</h2><h2 id="要使用的场景"><a href="#要使用的场景" class="headerlink" title="要使用的场景"></a>要使用的场景</h2><div class="table-container"><table><thead><tr><th>实现方式</th><th>原理</th><th>适用场景  </th></tr></thead><tbody><tr><td>map+Mutex</td><td>通过Mutex互斥锁来实现多个goroutine对map的串行化访问</td><td>读写都需要通过Mutex加锁和释放锁，适用于读写比接近的场景</td></tr><tr><td>map+RWMutex</td><td>通过RWMutex来实现对map的读写进行读写锁分离加锁，从而实现读的并发性能提高</td><td>同Mutex相比适用于读多写少的场景</td></tr><tr><td>sync.Map</td><td>底层通分离读写map和原子指令来实现读的近似无锁，并通过延迟更新的方式来保证读的无锁化</td><td>读多修改少，元素增加删除频率不高的情况，在大多数情况下替代上述两种实现</td></tr></tbody></table></div><h2 id="长度问题"><a href="#长度问题" class="headerlink" title="长度问题"></a>长度问题</h2><p>sync.Map没有Len方法，并且目前没有迹象要加上 (<a href="https://github.com/golang/go/issues/20680">issue#20680</a>),所以如果想得到当前Map中有效的entries的数量，需要使用Range方法遍历一次。</p><p>大致原因是：len如果需要准确，需要使用锁，不准确提供之后意义不大。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
        <tags>
            
            <tag> map </tag>
            
            <tag> sync_map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-mutex</title>
      <link href="/p/eecdb22f.html"/>
      <url>/p/eecdb22f.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><p>程序并发运行时，多个 Go 协程同时访问修改共享资源的代码，这些修改共享资源的代码称为临界区。多个 GO 协程同时访问临界区会出现竞态条件，将会发生不可预知的错误。常见的解决方法就是使用同步语句进行限制，是在任意时刻只允许一个go协程访问临界区，避免出现竞态条件。互斥锁就是同步语句的一种实现。</p><span id="more"></span><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><p>Go语言中，互斥锁是在<code>sync</code>包中，引入<code>sync</code>包即可创建一个互斥锁变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br></pre></td></tr></table></figure><p>加锁解锁的操作也比较简单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.Lock()   <span class="comment">// 加锁</span></span><br><span class="line">m.Unlock() <span class="comment">// 解锁</span></span><br></pre></td></tr></table></figure><p>需要注意的是，解锁操作是不可重入的。如果连着两次进行解锁。会抛出相应的异常。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br></pre></td></tr></table></figure><p>在锁的使用过程中，还需要注意避免死锁。举例说明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m.Lock()</span><br><span class="line">m.Lock()</span><br><span class="line">m.Unlock()</span><br></pre></td></tr></table></figure><p>在第一步加锁完成后，第三步的解锁依赖第二步的加锁成功，而第二步的加锁依赖第三步的解锁成功，这就出现了死锁。Go在执行过程中，也会检测死锁，直接抛出<code>fatal error: all goroutines are asleep - deadlock!</code>异常。</p><p>来看一个完整的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  </span><br><span class="line"><span class="keyword">import</span> (  </span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">var</span> x  = <span class="number">0</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increment</span><span class="params">(wg *sync.WaitGroup, m *sync.Mutex)</span></span> &#123;  </span><br><span class="line">    m.Lock()</span><br><span class="line">    x = x + <span class="number">1</span></span><br><span class="line">    m.Unlock()</span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">    <span class="keyword">var</span> w sync.WaitGroup</span><br><span class="line">    <span class="keyword">var</span> m sync.Mutex</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        w.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> increment(&amp;w, &amp;m)</span><br><span class="line">    &#125;</span><br><span class="line">    w.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;final value of x&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理剖析"><a href="#原理剖析" class="headerlink" title="原理剖析"></a>原理剖析</h1><h2 id="metux底层结构"><a href="#metux底层结构" class="headerlink" title="metux底层结构"></a>metux底层结构</h2><p>互斥锁底层，就是一个<code>Mutex</code>的结构体实现的。结构体内部两个字段<code>stata</code>字段和<code>sema</code>字段。<code>stata</code>字段用于标识锁状态，用于记录加锁状态、饥饿模式以及等待锁队列数量等。<code>sema</code>字段表示信号量，用于执行协程的唤醒和休眠。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span></span><br><span class="line">sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="metux状态"><a href="#metux状态" class="headerlink" title="metux状态"></a>metux状态</h2><p>在上文有讲到标记锁状态的字段，下面我们详细看一下这个字段，该字段的字段为<code>int32</code>类型的。 将该字段进行二进制拆开，二进制位的标记如下：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/eecdb22f/lock_mark.jpg" class="" title="lock_mark"><p>可以看到从低位起的第一个二进制位是标记锁状态，当前标志位下，0代表未加锁，1代表已加锁。第二个二进制位标记是否存在一个活跃在内存中等待锁资源的goroutinue（自旋状态）。 第三个二进制位标记锁模式（正常模式和饥饿模式）。该状态下文详细讲解。除去一位正负标记位，其他28位为存储等待队列中的goroutinue数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 处于锁状态</span></span><br><span class="line">mutexWoken              <span class="comment">// 唤醒状态</span></span><br><span class="line">mutexStarving           <span class="comment">// 锁处于饥饿模式</span></span><br><span class="line">mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 等待锁的队列中的元素数量 state &gt;&gt; mutexWaiterShift 即为元素数量</span></span><br><span class="line"></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span>  <span class="comment">// 1ms = 1000 微秒 = 1000*1000 纳秒</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="互斥锁模式"><a href="#互斥锁模式" class="headerlink" title="互斥锁模式"></a>互斥锁模式</h2><p>互斥锁有以下两种模式：</p><blockquote><ul><li><p>正常模式：所有等待锁的goroutine在一个先进先出的队列中，当锁释放的时候，如果内存中没有自旋中的goroutinue，会唤醒队首等待锁的goroutinue进行抢锁。如果抢锁失败，插入等待者队列头部等待下次唤醒。这里有一个问题就是在抢占锁比较频繁的场景下，内存中一直存在自旋状态下的goroutinue，这样就会存在队列中goroutinue一直没有得到调度，存在饿死的情况。于是，为了防止这种情况，就出现了饥饿模式。</p></li><li><p>饥饿模式：饥饿模式触发条件队首的goroutinue被唤醒是，检测到等待时长超过1ms，将锁模式切换为饥饿模式。在饥饿模式下，在锁释放的goroutinue内部，直接将锁移交给等待队列中队首的goroutinue，然后在进行挂载唤醒，这样就避免出现饿死的情况。另外，队首的goroutinue往往是等待时间最长的goutinue，后面如果检测到等待时长小于1ms，切换为正常模式。</p></li></ul></blockquote><p>什么情况下会出现处于自旋态的Goroutinue？</p><p>首先说一下什么是自旋，当协程尝试抢占资源时，如果资源被其他协程占用，当前协程将循环等待获取资源，即此时协程处于自旋态。当前goroutinue尝试获取锁时，如果此时锁处于锁定状态，当前goroutinue不会立马加入到锁等待队列中，而且是将当前goroutinue自旋一段时间，在这段时间内，如果锁释放，当前goroutinue可以很快的响应，拿到锁。</p><p>协程自旋和协程挂起唤醒有什么本质不同？</p><p>协程自旋：协程是一直处于运行状态，不释放CPU资源，当等待的资源就位时避免唤醒操作，响应及时。<br>协程挂起唤醒：协程挂起释放CUP资源，当等待的资源就位时执行唤醒操作，CPU执行效率高，但响应不及时。</p><p>总体来说，自旋和挂起唤醒各有个的优点。</p><p>自旋可以尽可能的减少协/线程的阻塞，这<strong>对于锁竞争不激烈且占用锁时间非常短</strong>的代码块来说性能能大幅度的提升，因为自旋的消耗会小于协/线程阻塞挂起再唤醒的操作的消耗。</p><p>挂起唤醒可以提高CPU的利用率，对于<strong>锁竞争激烈或占用锁时间较长</strong>的代码来说，自旋锁在获取锁前一直都是占用cpu做无用功，同时有大量协/线程在竞争一个锁，会导致获取锁的时间很长，协/线程自旋的消耗大于协/线程阻塞挂起操作的消耗。</p><p>思考一下GO为什么要先尝试自旋获取，失败后在进行挂起唤醒操作？</p><p>Go将自旋和挂起唤醒的优点结合在一块了，正常锁竞争不激烈的情况下，锁自旋这段时间就可以等到锁，避免了挂起唤醒。而锁竞争激烈或其他协程占用锁时间较长的情况下，将当前协程挂起，释放CPU资源，提高CPU的利用率。</p><h2 id="加锁逻辑"><a href="#加锁逻辑" class="headerlink" title="加锁逻辑"></a>加锁逻辑</h2><p>在详细的代码中，加锁逻辑比较复杂难以理解。但是一一拆分后，我们其实很容易就可以明白。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/eecdb22f/add_lock.png" class="" title="add_lock"><p>主要步骤如下：</p><ol><li><p>尝试简易加锁，如果成功直接返回。简易加锁逻辑cas(state, 0, 1)</p></li><li><p>尝试进行自旋以及awoken标记位置位。如果锁状态处于锁定状态且非饥饿，标记唤醒状态位， 进行自旋操作。</p></li><li><p>有两种情况。</p><p> a.锁已被释放，由于awoken的标记，不会去唤醒其他goroutinue强锁，进行加锁标记位置位，加锁成功，函数返回。<br> b.锁未释放，等待锁数量加1，将当前goroutinue休眠，等待被唤醒。</p></li><li><p>当前goroutinue唤醒后，也会存在两种情况。</p><p> a.当前锁状态为饥饿模式，即锁已经移交给当前goroutinue了，判断最新的饥饿状态，更新饥饿状态以及等待数量值减一，加锁成功，函数返回。<br> b.当前锁未处于饥饿模式，回溯到步骤2。</p></li></ol><p>相关代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;   <span class="comment">// 快速获取锁</span></span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">starving := <span class="literal">false</span></span><br><span class="line">awoke := <span class="literal">false</span></span><br><span class="line">iter := <span class="number">0</span></span><br><span class="line">old := m.state</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// old&amp;(mutexLocked|mutexStarving) == mutexLocked 锁定状态且非饥饿模式</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123; <span class="comment">// 等待中的gotinue 自旋状态</span></span><br><span class="line"><span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;    <span class="comment">// 自旋过程中，如果不是处于唤醒状态且等待锁队列不为空，将锁状态置为唤醒状态</span></span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">runtime_doSpin()</span><br><span class="line">iter++</span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;  <span class="comment">// 饥饿状态下不进行抢锁</span></span><br><span class="line"><span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;  <span class="comment">// 锁定状态，或者饥饿模式下，等待者计数+1</span></span><br><span class="line"><span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//  starving = true的情况，肯定是被唤醒的情况。</span></span><br><span class="line">        <span class="comment">//  被唤醒的情况下，设置饥饿模式为什么要判断 old&amp;mutexLocked != 0呢？</span></span><br><span class="line">        <span class="comment">//  原因是old&amp;mutexLocked == 0的情况下，再经过后面的cas是有可能直接拿到锁的，这样的情况下就不设置饥饿模式了。如果后面cas 拿锁失败，在进行一遍循环，还是会设置饥饿模式。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//  只有被唤醒，已经饥饿但锁还被其他人获取了，才设置饥饿模式。</span></span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">new</span> &amp;^= mutexWoken                      <span class="comment">// awoken标记位置为空</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;  <span class="comment">// 旧状态在此期间未改变的情况下，将新的状态更新到m.state</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;        <span class="comment">// 如果旧状态未持有锁且处于非饥饿模式，执行到这里就已经获取到锁了。</span></span><br><span class="line"><span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">            queueLifo := waitStartTime != <span class="number">0</span>                  <span class="comment">// 如果这里waitStartTime不等于0， 可以证明当前goroutinue是队首唤醒的goroutinue</span></span><br><span class="line"><span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">waitStartTime = runtime_nanotime()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入等待者队列，queueLifo=true放队首，否则反之。如果是队首唤醒的goroutinue的就放在队首。</span></span><br><span class="line">runtime_SemacquireMutex(&amp;m.sema, queueLifo)      </span><br><span class="line">starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs  <span class="comment">// 调度回来后，判断是否达到饥饿状态</span></span><br><span class="line">old = m.state</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;   <span class="comment">// 被唤醒时饥饿模式（已经拿到锁了）。1. 等待者计数减1， 2. 判断是否仍处于饥饿状态，更新最新的饥饿状态</span></span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line"><span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123; <span class="comment">// 最新非饥饿模式，或者旧的等待者计数为1（只剩自己，无其他等待者）</span></span><br><span class="line">delta -= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line">atomic.AddInt32(&amp;m.state, delta)             <span class="comment">// 更新状态</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">awoke = <span class="literal">true</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">race.Acquire(unsafe.Pointer(m))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_SemacquireMutex</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">semacquire1(addr, lifo, semaBlockProfile|semaMutexProfile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semacquire1</span><span class="params">(addr *<span class="type">uint32</span>, lifo <span class="type">bool</span>, profile semaProfileFlags)</span></span> &#123;</span><br><span class="line">gp := getg()</span><br><span class="line"><span class="keyword">if</span> gp != gp.m.curg &#123;</span><br><span class="line">throw(<span class="string">&quot;semacquire not on the G stack&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">s := acquireSudog()                     <span class="comment">// 获取一个新的goroutinue</span></span><br><span class="line">root := semroot(addr)</span><br><span class="line">t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">s.releasetime = <span class="number">0</span></span><br><span class="line">s.acquiretime = <span class="number">0</span></span><br><span class="line">s.ticket = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> profile&amp;semaBlockProfile != <span class="number">0</span> &amp;&amp; blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">s.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> profile&amp;semaMutexProfile != <span class="number">0</span> &amp;&amp; mutexprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t0 == <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">s.acquiretime = t0</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">lock(&amp;root.lock)                    <span class="comment">// 上锁</span></span><br><span class="line">atomic.Xadd(&amp;root.nwait, <span class="number">1</span>)         <span class="comment">// 等待者计数+1</span></span><br><span class="line"><span class="keyword">if</span> cansemacquire(addr) &#123;            <span class="comment">// 简易模式，存在锁资源，直接获取锁资源 返回</span></span><br><span class="line">atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">root.queue(addr, s, lifo)           <span class="comment">// 加入等待者队列</span></span><br><span class="line">goparkunlock(&amp;root.lock, <span class="string">&quot;semacquire&quot;</span>, traceEvGoBlockSync, <span class="number">4</span>)   <span class="comment">// gopark阻塞，待调度</span></span><br><span class="line"><span class="keyword">if</span> s.ticket != <span class="number">0</span> || cansemacquire(addr) &#123; <span class="comment">// 持有钥匙，或者获取到锁资源，直接break</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(s.releasetime-t0, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解锁逻辑"><a href="#解锁逻辑" class="headerlink" title="解锁逻辑"></a>解锁逻辑</h2><p>解锁逻辑相对于加锁来说是比较简单的。主要步骤如下：</p><ol><li>锁标记位置为0</li><li>如果当前处于等待队列数量不为0且非饥饿非锁定状态且不存在自旋中的goroutinue，唤醒队首处于休眠状态的goroutinue</li><li>如果处于饥饿状态，执行锁的移交操作，这里是依赖信号量的实现。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)      <span class="comment">// 更新标记位（这时候，其他自旋状态下的goroutinue可以抢锁了）</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">old := <span class="built_in">new</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="comment">// 等待着数量为0，或者当前锁状态处于 被锁（其他goutinue抢锁），唤醒状态（已经唤醒其他gourinue 或 处于自旋状态下将mutexWoken置位了），饥饿（饥饿模式下，不走唤醒操作） 直接返回</span></span><br><span class="line"><span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken      <span class="comment">// 等待者计数-1，唤醒标记为置1</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123; <span class="comment">// 更新状态</span></span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>)              <span class="comment">// 执行唤醒操作</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">old = m.state</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>)  <span class="comment">// 饥饿模式，在当前goutinue直接将锁资源给待唤醒的goutinue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_Semrelease sync.runtime_Semrelease</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">semrelease1(addr, handoff)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease1</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">root := semroot(addr)</span><br><span class="line">atomic.Xadd(addr, <span class="number">1</span>)        <span class="comment">// 资源为mutex.sema 自增</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;      <span class="comment">// 等待计数为0，返回</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">lock(&amp;root.lock)</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;      <span class="comment">// 再次判断计数</span></span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">s, t0 := root.dequeue(addr)             <span class="comment">// 取出队首goroutinue</span></span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)        <span class="comment">// 等待计数-1</span></span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123; <span class="comment">// May be slow, so unlock first</span></span><br><span class="line">acquiretime := s.acquiretime</span><br><span class="line"><span class="keyword">if</span> acquiretime != <span class="number">0</span> &#123;</span><br><span class="line">mutexevent(t0-acquiretime, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.ticket != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;corrupted semaphore ticket&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// handoff 标记是否是饥饿模式，饥饿模式下待唤醒的goutinue直接拿到钥匙（唤醒后不与内存中自旋的goutinue竞争）</span></span><br><span class="line">        <span class="comment">// cansemacquire函数 是用来获取到锁资源，这时候其他goroutinue拿不到锁</span></span><br><span class="line">        <span class="comment">// 这里其实饥饿模式下，在goroutinue未唤醒的情况下，就已经将锁资源给了待唤醒的goutinue</span></span><br><span class="line"><span class="keyword">if</span> handoff &amp;&amp; cansemacquire(addr) &#123; </span><br><span class="line">s.ticket = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">readyWithTime(s, <span class="number">5</span>)                 <span class="comment">// 执行唤醒操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进阶理解"><a href="#进阶理解" class="headerlink" title="进阶理解"></a>进阶理解</h1><ol><li>程序优化时，在原子性自增与互斥锁之间，可以不用考虑原子性自增，直接使用互斥锁了，互斥锁的底层实现就是原子性自增实现的。</li><li>在读多写少的场景下，建议使用读写锁<code>sync.RWMetux</code>。</li><li>在临界区入口加锁完成后，直接进行defer解锁操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mutex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-sync</title>
      <link href="/p/1834645404.html"/>
      <url>/p/1834645404.html</url>
      
        <content type="html"><![CDATA[<p><code>sync</code>包内主要是一些锁,信号量之类的东西</p><span id="more"></span><h1 id="条件变量-Cond"><a href="#条件变量-Cond" class="headerlink" title="条件变量 Cond"></a>条件变量 Cond</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy                   <span class="comment">// noCopy字段，用于标记该结构无法复制。通过go vet命令可以检测代码中是否出现存在noCopy字段的结构却发生复制的情况。</span></span><br><span class="line">    L Locker                        <span class="comment">// 锁接口</span></span><br><span class="line"> </span><br><span class="line">    notify  notifyList              <span class="comment">// 待通知列表</span></span><br><span class="line">    checker copyChecker             <span class="comment">// 普通指针，用于运行时检查是否发生复制。运行时检查。检查原理见下方。</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span>       </span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">    Lock()          <span class="comment">// 锁接口</span></span><br><span class="line">    Unlock()        <span class="comment">// 解锁接口</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">    wait <span class="type">uint32</span>                 <span class="comment">// 下一个待通知goroutine编号</span></span><br><span class="line"> </span><br><span class="line">    notify <span class="type">uint32</span>               <span class="comment">// 已通知过的goroutine编号</span></span><br><span class="line">     </span><br><span class="line">    lock mutex                  <span class="comment">// 锁</span></span><br><span class="line">    head *sudog                 <span class="comment">// list 起始位置</span></span><br><span class="line">    tail *sudog                 <span class="comment">// list 结束位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    c.checker.check()                       <span class="comment">// 检查是否发生复制</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify)   <span class="comment">// 获取wait值，并使notifyList.wait值自增。</span></span><br><span class="line">    c.L.Unlock()                            <span class="comment">// 休眠前需要释放锁</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t)    <span class="comment">// 添加到notifyList后休眠</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span>     <span class="comment">// 自增后，返回原本的值。 思考一下这里如果wait溢出，变为0会怎么样？</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">less</span><span class="params">(a, b <span class="type">uint32</span>)</span></span> <span class="type">bool</span> &#123;             </span><br><span class="line">    <span class="keyword">return</span> <span class="type">int32</span>(a-b) &lt; <span class="number">0</span>                </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> less(t, l.notify) &#123;                <span class="comment">// 判断是否wait和notify是否间距过大</span></span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Enqueue itself.</span></span><br><span class="line">    s := acquireSudog()                  <span class="comment">// 获取一个gotinue，将自己的信息添加到gotinue中</span></span><br><span class="line">    s.g = getg()</span><br><span class="line">    s.ticket = t</span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;                  <span class="comment">// 将当前gotinue加入待唤醒队列。</span></span><br><span class="line">        l.head = s</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.tail.next = s</span><br><span class="line">    &#125;</span><br><span class="line">    l.tail = s</span><br><span class="line">    goparkunlock(&amp;l.lock, <span class="string">&quot;semacquire&quot;</span>, traceEvGoBlockCond, <span class="number">3</span>)  <span class="comment">// 休眠自身</span></span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releaseSudog(s)             <span class="comment">// 唤醒后释放s</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>signal</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    c.checker.check()                       <span class="comment">// 检测是否发生复制</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)  <span class="comment">// 通知并唤醒响应的goroutinue</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;   <span class="comment">//  wait == notify， 代表没有待通知的goroutinue</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Re-check under the lock if we need to do anything.</span></span><br><span class="line">    t := l.notify</span><br><span class="line">    <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;                      <span class="comment">// 拿锁在此判断一下</span></span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Update the next notify ticket number.  </span></span><br><span class="line">    atomic.Store(&amp;l.notify, t+<span class="number">1</span>)                        <span class="comment">// notify自增</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 遍历待通知的goroutinue</span></span><br><span class="line">    <span class="comment">// 遍历到将该goroutinue从链表中移除并且置为可调度状态。未遍历到直接返回。</span></span><br><span class="line">    <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;  </span><br><span class="line">        <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">            n := s.next</span><br><span class="line">            <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">                p.next = n</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l.head = n</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">                l.tail = p</span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;l.lock)</span><br><span class="line">            s.next = <span class="literal">nil</span></span><br><span class="line">            readyWithTime(s, <span class="number">4</span>)                     <span class="comment">// 将goroutinue置为可调度状态</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copyCheck</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. uintptr(*c) != uintptr(unsafe.Pointer(c))  指针不指向本身。</span></span><br><span class="line"><span class="comment">    （ 指针不指向本身有两种情况。a.根据conf初始化逻辑，conf.checkerw为nil。第一次调用会存在指针不指向本身。 b. 发生了复制。</span></span><br><span class="line"><span class="comment">    ）</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    2. !atomic.CompareAndSwapUintptr((*uintptr)(c), 0, uintptr(unsafe.Pointer(c)))  cas操作。 这里是判断如果c为nil， 则将c指向c的地址。如果发生了这样的操作，返回值为true。否则返回值为false。 返回值为true的情况下，跳出if语句，这里就杜绝了第一个判断条件为a的情况。 返回值为false的情况下，即c不为nil。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">    3. intptr(*c) != uintptr(unsafe.Pointer(c) 再次检测指针不指向本身。</span></span><br><span class="line"><span class="comment">    结合前两个判断语句，可以说明这里conf发生了复制。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">        !atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">        <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-map</title>
      <link href="/p/3864341520.html"/>
      <url>/p/3864341520.html</url>
      
        <content type="html"><![CDATA[<p>代码版本:<strong>1.12.7</strong></p><p>主要代码在<code>src/runtime/map.go</code></p><span id="more"></span><h1 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3864341520/go_map.png" class="" title="map"><h1 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h1><p>每个bucket持有kv键值对数目<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum number of key/value pairs a bucket can hold.</span></span><br><span class="line"><span class="comment">//设置一个bucket最多持有多kv键值对</span></span><br><span class="line">bucketCntBits = <span class="number">3</span></span><br><span class="line">bucketCnt     = <span class="number">1</span> &lt;&lt; bucketCntBits</span><br></pre></td></tr></table></figure></p><p>扩容因子<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum average load of a bucket that triggers growth is 6.5.</span></span><br><span class="line"><span class="comment">// Represent as loadFactorNum/loadFactDen, to allow integer math.</span></span><br><span class="line"><span class="comment">//判断是否扩容的因子，按注释的意思是经多次测试选了6.5这个值，也就是当元素个数/bucket个数大于等于6.5时（换算下来就是元素个数80%左右的时候扩容），就会进行扩容，把bucket数量扩成原本的两倍</span></span><br><span class="line">loadFactorNum = <span class="number">13</span></span><br><span class="line">loadFactorDen = <span class="number">2</span></span><br></pre></td></tr></table></figure><br>kv最大的大小，超过这个大小会转成指针来存储<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Maximum key or value size to keep inline (instead of mallocing per element).</span></span><br><span class="line"><span class="comment">// Must fit in a uint8.</span></span><br><span class="line"><span class="comment">// Fast versions cannot handle big values - the cutoff size for</span></span><br><span class="line"><span class="comment">// fast versions in cmd/compile/internal/gc/walk.go must be at most this value.</span></span><br><span class="line"><span class="comment">//kv最大的大小，超过了这个大小就用指针来存储，单位是字节</span></span><br><span class="line">maxKeySize   = <span class="number">128</span></span><br><span class="line">maxValueSize = <span class="number">128</span></span><br></pre></td></tr></table></figure></p><p><code>bmap</code>的定义只有部分内容，剩下的需要通过偏移来查找<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data offset should be the size of the bmap struct, but needs to be</span></span><br><span class="line"><span class="comment">// aligned correctly. For amd64p32 this means 64-bit alignment</span></span><br><span class="line"><span class="comment">// even though pointers are 32 bit.</span></span><br><span class="line"><span class="comment">//数据的偏移量，因为bmap的结构里面只定义了一个 tophash，剩下的kv和ovf都是通过偏移量来算出来的，这么做的意图是为了保证兼容32位机和64位机</span></span><br><span class="line">dataOffset = unsafe.Offsetof(<span class="keyword">struct</span> &#123;</span><br><span class="line">b bmap</span><br><span class="line">v <span class="type">int64</span></span><br><span class="line">&#125;&#123;&#125;.v)</span><br></pre></td></tr></table></figure></p><p><code>tophash</code>的状态<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Possible tophash values. We reserve a few possibilities for special marks.</span></span><br><span class="line"><span class="comment">// Each bucket (including its overflow buckets, if any) will have either all or none of its</span></span><br><span class="line"><span class="comment">// entries in the evacuated* states (except during the evacuate() method, which only happens</span></span><br><span class="line"><span class="comment">// during map writes and thus no one else can observe the map during that time).</span></span><br><span class="line"><span class="comment">//记录每个bucket内坑位的状态</span></span><br><span class="line"><span class="comment">//标示所在单元是个空单元,后续也么有非空单元</span></span><br><span class="line">emptyRest      = <span class="number">0</span> <span class="comment">// this cell is empty, and there are no more non-empty cells at higher indexes or overflows.</span></span><br><span class="line"><span class="comment">//标示所在单元是个空单元</span></span><br><span class="line">emptyOne       = <span class="number">1</span> <span class="comment">// this cell is empty</span></span><br><span class="line"><span class="comment">//标示数据有效，数据迁移在新表的前半部分，同大小扩容位置一样</span></span><br><span class="line">evacuatedX     = <span class="number">2</span> <span class="comment">// key/value is valid.  Entry has been evacuated to first half of larger table.</span></span><br><span class="line"><span class="comment">//标示数据有效，数据迁移在新表的后半部分</span></span><br><span class="line">evacuatedY     = <span class="number">3</span> <span class="comment">// same as above, but evacuated to second half of larger table.</span></span><br><span class="line"><span class="comment">//标示所在单元是个空单元,相关数据已经迁移到新的hmap中</span></span><br><span class="line">evacuatedEmpty = <span class="number">4</span> <span class="comment">// cell is empty, bucket is evacuated.</span></span><br><span class="line"><span class="comment">//标示正常单元tophash状态的最小值，因为0-4是做状态判断的</span></span><br><span class="line">minTopHash     = <span class="number">5</span> <span class="comment">// minimum tophash for a normal filled cell.</span></span><br></pre></td></tr></table></figure></p><p>迭代器标记<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flags</span></span><br><span class="line"><span class="comment">//两个迭代器</span></span><br><span class="line">iterator     = <span class="number">1</span> <span class="comment">// there may be an iterator using buckets</span></span><br><span class="line">oldIterator  = <span class="number">2</span> <span class="comment">// there may be an iterator using oldbuckets</span></span><br></pre></td></tr></table></figure></p><p>写入状态标记，通过这个标记来判断是否同时读写<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入状态</span></span><br><span class="line">hashWriting  = <span class="number">4</span> <span class="comment">// a goroutine is writing to the map</span></span><br></pre></td></tr></table></figure></p><p>扩容标记，用来判断是等比扩容(rehash)还是二倍扩容<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标记是同大小扩容</span></span><br><span class="line">sameSizeGrow = <span class="number">8</span> <span class="comment">// the current map growth is to a new map of the same size</span></span><br></pre></td></tr></table></figure></p><p>迭代器使用的一个标记值，用来判别真实数据<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来做迭代器哨兵的一个值</span></span><br><span class="line"><span class="comment">// sentinel bucket ID for iterator checks</span></span><br><span class="line">noCheck = <span class="number">1</span>&lt;&lt;(<span class="number">8</span>*sys.PtrSize) - <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>0值定义<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> maxZero = <span class="number">1024</span> <span class="comment">// must match value in cmd/compile/internal/gc/walk.go</span></span><br><span class="line"><span class="keyword">var</span> zeroVal [maxZero]<span class="type">byte</span></span><br></pre></td></tr></table></figure></p><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A header for a Go map.</span></span><br><span class="line"><span class="comment">//go map的核心部分</span></span><br><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span>  <span class="comment">//  哈希表元素数量</span></span><br><span class="line">    flags     <span class="type">uint8</span>  <span class="comment">// 标记哈希表状态</span></span><br><span class="line">    B         <span class="type">uint8</span>  <span class="comment">// 哈希表内部桶数量（2^B个桶）</span></span><br><span class="line">    noverflow <span class="type">uint16</span> <span class="comment">// 溢出桶数量</span></span><br><span class="line">    hash0     <span class="type">uint32</span> <span class="comment">// 哈希因子</span></span><br><span class="line">    buckets    unsafe.Pointer <span class="comment">// 桶数组的首地址</span></span><br><span class="line">    oldbuckets unsafe.Pointer <span class="comment">// 旧桶数组的首地址</span></span><br><span class="line">    nevacuate  <span class="type">uintptr</span>        <span class="comment">// 迁移计数</span></span><br><span class="line">    extra *mapextra <span class="comment">// 拓展字段，里面存放一些不是所有哈希表都有的字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap  <span class="comment">// 溢出桶指针数组的指针</span></span><br><span class="line">    oldoverflow *[]*bmap  <span class="comment">// 旧溢出桶指针数组的指针</span></span><br><span class="line">    nextOverflow *bmap   <span class="comment">// 下一个可用溢出桶的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶数据结构</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;     </span><br><span class="line">    <span class="comment">// tophash 记录每一个元素哈希后key的高8位</span></span><br><span class="line">    <span class="comment">// 查找时，直接先对比tophash值，如果相等，在进行比较key。     </span></span><br><span class="line">    tophash [bucketCnt]<span class="type">uint8</span>     <span class="comment">// 每个桶最多可以存放8个元素</span></span><br><span class="line">    <span class="comment">//后面跟着8个k然后8个v</span></span><br><span class="line">    <span class="comment">//最后还有个overflow指针</span></span><br><span class="line">    <span class="comment">// Followed by bucketCnt keys and then bucketCnt values.  // key1， key2，... and value1, value2, ...</span></span><br><span class="line">    <span class="comment">// Followed by an overflow pointer.   // ovf指针, 溢出桶指针</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A hash iteration structure.</span></span><br><span class="line"><span class="comment">// If you modify hiter, also change cmd/compile/internal/gc/reflect.go to indicate</span></span><br><span class="line"><span class="comment">// the layout of this structure.</span></span><br><span class="line"><span class="comment">//map迭代器</span></span><br><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">key         unsafe.Pointer <span class="comment">// Must be in first position.  Write nil to indicate iteration end (see cmd/internal/gc/range.go).</span></span><br><span class="line">value       unsafe.Pointer <span class="comment">// Must be in second position (see cmd/internal/gc/range.go).</span></span><br><span class="line">t           *maptype</span><br><span class="line">h           *hmap</span><br><span class="line">buckets     unsafe.Pointer <span class="comment">// bucket ptr at hash_iter initialization time</span></span><br><span class="line">bptr        *bmap          <span class="comment">// current bucket</span></span><br><span class="line">overflow    *[]*bmap       <span class="comment">// keeps overflow buckets of hmap.buckets alive</span></span><br><span class="line">oldoverflow *[]*bmap       <span class="comment">// keeps overflow buckets of hmap.oldbuckets alive</span></span><br><span class="line">startBucket <span class="type">uintptr</span>        <span class="comment">// bucket iteration started at</span></span><br><span class="line">offset      <span class="type">uint8</span>          <span class="comment">// intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1)</span></span><br><span class="line">wrapped     <span class="type">bool</span>           <span class="comment">// already wrapped around from end of bucket array to beginning</span></span><br><span class="line">B           <span class="type">uint8</span></span><br><span class="line">i           <span class="type">uint8</span></span><br><span class="line">bucket      <span class="type">uintptr</span></span><br><span class="line">checkBucket <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// evacDst is an evacuation destination.</span></span><br><span class="line"><span class="comment">// 迁移用的</span></span><br><span class="line"><span class="keyword">type</span> evacDst <span class="keyword">struct</span> &#123;</span><br><span class="line">b *bmap          <span class="comment">// 当前的目标bucket</span></span><br><span class="line">i <span class="type">int</span>            <span class="comment">// 迁移到b中的index</span></span><br><span class="line">k unsafe.Pointer <span class="comment">// 当前keys的起始地址</span></span><br><span class="line">v unsafe.Pointer <span class="comment">// 当前values的起始地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bucketShift returns 1&lt;&lt;b, optimized for code generation.</span></span><br><span class="line"><span class="comment">//算桶个数的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketShift</span><span class="params">(b <span class="type">uint8</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line"><span class="keyword">if</span> sys.GoarchAmd64|sys.GoarchAmd64p32|sys.Goarch386 != <span class="number">0</span> &#123;</span><br><span class="line">b &amp;= sys.PtrSize*<span class="number">8</span> - <span class="number">1</span> <span class="comment">// help x86 archs remove shift overflow checks</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">uintptr</span>(<span class="number">1</span>) &lt;&lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.</span></span><br><span class="line"><span class="comment">//算桶个数掩码，方便&amp;取值，把hash值映射到buckte时，golang会把bucket的数量规整为2的次幂，而有m=2b，则n%m=n&amp;(m-1)，用位运算规避mod的昂贵代价</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketMask</span><span class="params">(b <span class="type">uint8</span>)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bucketShift(b) - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tophash calculates the tophash value for hash.</span></span><br><span class="line"><span class="comment">//算topsh的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tophash</span><span class="params">(hash <span class="type">uintptr</span>)</span></span> <span class="type">uint8</span> &#123;</span><br><span class="line">top := <span class="type">uint8</span>(hash &gt;&gt; (sys.PtrSize*<span class="number">8</span> - <span class="number">8</span>))</span><br><span class="line"><span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">        <span class="comment">//注意这里，小于minTopHash也就是5的时候+一个5，因为0-4是标记值</span></span><br><span class="line">top += minTopHash</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> top</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断这个bucket是不是迁移了,因为都是一个桶一个桶的迁移，所以判断第0号位置就行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bucketEvacuated</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">b := (*bmap)(add(h.oldbuckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">return</span> evacuated(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">h := b.tophash[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> h &gt; emptyOne &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过偏移算出overflow指向的bmap</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> overflow(t *maptype) *bmap &#123;</span><br><span class="line"><span class="keyword">return</span> *(**bmap)(add(unsafe.Pointer(b), <span class="type">uintptr</span>(t.bucketsize)-sys.PtrSize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一下overflow指向的位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> setoverflow(t *maptype, ovf *bmap) &#123;</span><br><span class="line">*(**bmap)(add(unsafe.Pointer(b), <span class="type">uintptr</span>(t.bucketsize)-sys.PtrSize)) = ovf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到keys的起始位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> keys() unsafe.Pointer &#123;</span><br><span class="line"><span class="keyword">return</span> add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// overLoadFactor reports whether count items placed in 1&lt;&lt;B buckets is over loadFactor.</span></span><br><span class="line"><span class="comment">// 判断是不是超过了影响因子</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">overLoadFactor</span><span class="params">(count <span class="type">int</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> count &gt; bucketCnt &amp;&amp; <span class="type">uintptr</span>(count) &gt; loadFactorNum*(bucketShift(B)/loadFactorDen)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tooManyOverflowBuckets reports whether noverflow buckets is too many for a map with 1&lt;&lt;B buckets.</span></span><br><span class="line"><span class="comment">// Note that most of these overflow buckets must be in sparse use;</span></span><br><span class="line"><span class="comment">// if use was dense, then we&#x27;d have already triggered regular map growth.</span></span><br><span class="line"><span class="comment">//判断是不是overflow链的buckets太多了，按注释的意思，15是个经验值，也就是最多32768个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tooManyOverflowBuckets</span><span class="params">(noverflow <span class="type">uint16</span>, B <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// If the threshold is too low, we do extraneous work.</span></span><br><span class="line"><span class="comment">// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.</span></span><br><span class="line"><span class="comment">// &quot;too many&quot; means (approximately) as many overflow buckets as regular buckets.</span></span><br><span class="line"><span class="comment">// See incrnoverflow for more details.</span></span><br><span class="line"><span class="keyword">if</span> B &gt; <span class="number">15</span> &#123;</span><br><span class="line">B = <span class="number">15</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The compiler doesn&#x27;t see here that B &lt; 16; mask B to generate shorter shift code.</span></span><br><span class="line"><span class="keyword">return</span> noverflow &gt;= <span class="type">uint16</span>(<span class="number">1</span>)&lt;&lt;(B&amp;<span class="number">15</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// incrnoverflow increments h.noverflow.</span></span><br><span class="line"><span class="comment">// noverflow counts the number of overflow buckets.</span></span><br><span class="line"><span class="comment">// This is used to trigger same-size map growth.</span></span><br><span class="line"><span class="comment">// See also tooManyOverflowBuckets.</span></span><br><span class="line"><span class="comment">// To keep hmap small, noverflow is a uint16.</span></span><br><span class="line"><span class="comment">// When there are few buckets, noverflow is an exact count.</span></span><br><span class="line"><span class="comment">// When there are many buckets, noverflow is an approximate count.</span></span><br><span class="line"><span class="comment">// 增加overflow个数计数,这里有个特殊处理</span></span><br><span class="line"><span class="comment">// 因为noverflow是一个uint16,最大也就2^16,所以在这里做了个特殊处理，就是当h.B&gt;=16的时候 做一个概率计算，只有1/2^(B-15)的概率加1，所以当太多的时候，这是一个近似值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> incrnoverflow() &#123;</span><br><span class="line"><span class="comment">// We trigger same-size map growth if there are</span></span><br><span class="line"><span class="comment">// as many overflow buckets as buckets.</span></span><br><span class="line"><span class="comment">// We need to be able to count to 1&lt;&lt;h.B.</span></span><br><span class="line"><span class="keyword">if</span> h.B &lt; <span class="number">16</span> &#123;</span><br><span class="line">h.noverflow++</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Increment with probability 1/(1&lt;&lt;(h.B-15)).</span></span><br><span class="line"><span class="comment">// When we reach 1&lt;&lt;15 - 1, we will have approximately</span></span><br><span class="line"><span class="comment">// as many overflow buckets as buckets.</span></span><br><span class="line">mask := <span class="type">uint32</span>(<span class="number">1</span>)&lt;&lt;(h.B<span class="number">-15</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// Example: if h.B == 18, then mask == 7,</span></span><br><span class="line"><span class="comment">// and fastrand &amp; 7 == 0 with probability 1/8.</span></span><br><span class="line"><span class="keyword">if</span> fastrand()&amp;mask == <span class="number">0</span> &#123;</span><br><span class="line">h.noverflow++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// growing reports whether h is growing. The growth may be to the same size or bigger.</span></span><br><span class="line"><span class="comment">//判断是不是在扩容，直接判断oldbuckets指向是不是为空即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> growing() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.oldbuckets != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sameSizeGrow reports whether the current growth is to a map of the same size.</span></span><br><span class="line"><span class="comment">//判断是不是同大小扩容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> sameSizeGrow() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.flags&amp;sameSizeGrow != <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// noldbuckets calculates the number of buckets prior to the current map growth.</span></span><br><span class="line"><span class="comment">//算一下桶个数，如果不是同大小扩容的话，因为每一次是原来的2倍扩容，所以B-1，也就是/2</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> noldbuckets() <span class="type">uintptr</span> &#123;</span><br><span class="line">oldB := h.B</span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">oldB--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bucketShift(oldB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// oldbucketmask provides a mask that can be applied to calculate n % noldbuckets().</span></span><br><span class="line"><span class="comment">//算掩码方便&amp;取值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *hmap)</span></span> oldbucketmask() <span class="type">uintptr</span> &#123;</span><br><span class="line"><span class="keyword">return</span> h.noldbuckets() - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断能不能做为map的key</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ismapkey</span><span class="params">(t *_type)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.alg.hash != <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// isEmpty reports whether the given tophash array entry represents an empty bucket entry.</span></span><br><span class="line"><span class="comment">// 判断当前单元tophash标志位是不是空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(x <span class="type">uint8</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x &lt;= emptyOne</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h3 id="新建map-a-make-map-string-interface"><a href="#新建map-a-make-map-string-interface" class="headerlink" title="新建map a :=make(map[string]interface{})"></a>新建map <code>a :=make(map[string]interface&#123;&#125;)</code></h3><p>新建步骤如下</p><ol><li>如果hmap结构已经传入，复用，否则，即新创建一个。</li><li>根据元素数量，确定桶大小数量B（2^B个桶）</li><li>如果B=0，直接返回h即可，即不申请具体buckets内存，后续惰性申请。</li><li>申请内存块，这里的逻辑是如果B&gt;=4， 即桶数量如果大于等于16时， 会增加1/16*B个桶，桶数量向上取整并使内存对齐， 这时候，根据对齐后的内存， 重新计算桶数量 。将对齐后的内存块，初始化为N个桶。 对于前2^B个桶， 都作为哈希表中的桶， 后面的桶作为哈希表的溢出桶。溢出桶是指：如果出现当前桶空间不足，将当前桶空间后面的ovf指针上挂上一个新的桶，来进行存储元素（类似链接法解决哈希冲突）。这个桶就叫溢出桶。 </li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// makemap implements Go map creation for make(map[k]v, hint).</span></span><br><span class="line"><span class="comment">// If the compiler has determined that the map or the first bucket</span></span><br><span class="line"><span class="comment">// can be created on the stack, h and/or bucket may be non-nil.</span></span><br><span class="line"><span class="comment">// If h != nil, the map can be created directly in h.</span></span><br><span class="line"><span class="comment">// If h.buckets != nil, bucket pointed to can be used as the first bucket.</span></span><br><span class="line"><span class="comment">//新建一个map</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="type">int</span>, h *hmap)</span></span> *hmap &#123;</span><br><span class="line">mem, overflow := math.MulUintptr(<span class="type">uintptr</span>(hint), t.bucket.size)</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc &#123;</span><br><span class="line">hint = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initialize Hmap</span></span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line">h = <span class="built_in">new</span>(hmap) <span class="comment">//如果hmap指针为空， 创建hmap结构体。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">h.hash0 = fastrand() <span class="comment">// 初始化哈希种子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Find the size parameter B which will hold the requested # of elements.</span></span><br><span class="line"><span class="comment">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span></span><br><span class="line">B := <span class="type">uint8</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> overLoadFactor(hint, B) &#123;</span><br><span class="line">        <span class="comment">// 根据元素数量，确定桶大小</span></span><br><span class="line">B++</span><br><span class="line">&#125;</span><br><span class="line">h.B = B</span><br><span class="line"></span><br><span class="line"><span class="comment">// allocate initial hash table</span></span><br><span class="line"><span class="comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span></span><br><span class="line"><span class="comment">// If hint is large zeroing this memory could take a while.</span></span><br><span class="line"><span class="comment">// 桶数量为0时，即不申请内存，即不指定元素数量,后续惰性申请</span></span><br><span class="line"><span class="keyword">if</span> h.B != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">var</span> nextOverflow *bmap</span><br><span class="line">h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="literal">nil</span>)<span class="comment">// 申请桶内存块，具体见下方</span></span><br><span class="line"><span class="keyword">if</span> nextOverflow != <span class="literal">nil</span> &#123;</span><br><span class="line">             <span class="comment">// 如果溢出桶的地址不为空就把扩展字段里的nextovf指过去</span></span><br><span class="line">h.extra = <span class="built_in">new</span>(mapextra)</span><br><span class="line">h.extra.nextOverflow = nextOverflow</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeBucketArray initializes a backing array for map buckets.</span></span><br><span class="line"><span class="comment">// 1&lt;&lt;b is the minimum number of buckets to allocate.</span></span><br><span class="line"><span class="comment">// dirtyalloc should either be nil or a bucket array previously</span></span><br><span class="line"><span class="comment">// allocated by makeBucketArray with the same t and b parameters.</span></span><br><span class="line"><span class="comment">// If dirtyalloc is nil a new backing array will be alloced and</span></span><br><span class="line"><span class="comment">// otherwise dirtyalloc will be cleared and reused as backing array.</span></span><br><span class="line"><span class="comment">//新建bucket数组,t是map类型，b是桶数的指数，dirtyalloc如果是空就新申请空间否则就清空这一块拿来用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeBucketArray</span><span class="params">(t *maptype, b <span class="type">uint8</span>, dirtyalloc unsafe.Pointer)</span></span> (buckets unsafe.Pointer, nextOverflow *bmap) &#123;</span><br><span class="line">base := bucketShift(b)</span><br><span class="line">nbuckets := base</span><br><span class="line"><span class="comment">// For small b, overflow buckets are unlikely.</span></span><br><span class="line"><span class="comment">// Avoid the overhead of the calculation.</span></span><br><span class="line"><span class="keyword">if</span> b &gt;= <span class="number">4</span> &#123;</span><br><span class="line"><span class="comment">// Add on the estimated number of overflow buckets</span></span><br><span class="line"><span class="comment">// required to insert the median number of elements</span></span><br><span class="line"><span class="comment">// used with this value of b.</span></span><br><span class="line">        <span class="comment">// 如果B&gt;=4 也就是bucket数目&gt;=16 增加1/16个桶的空间</span></span><br><span class="line">        <span class="comment">// 优先用预分配的overflow bucket，如果预分配的用完了，那么就malloc一个挂上去。注意golang的map不会shrink，内存只会越用越多，overflow bucket中的key全删了也不会释放</span></span><br><span class="line">nbuckets += bucketShift(b - <span class="number">4</span>)</span><br><span class="line">sz := t.bucket.size * nbuckets</span><br><span class="line">up := roundupsize(sz)<span class="comment">//做一下内存对齐</span></span><br><span class="line"><span class="keyword">if</span> up != sz &#123;</span><br><span class="line">nbuckets = up / t.bucket.size</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有可以复用的就新建一个</span></span><br><span class="line"><span class="keyword">if</span> dirtyalloc == <span class="literal">nil</span> &#123;</span><br><span class="line">buckets = newarray(t.bucket, <span class="type">int</span>(nbuckets))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// dirtyalloc was previously generated by</span></span><br><span class="line"><span class="comment">// the above newarray(t.bucket, int(nbuckets))</span></span><br><span class="line"><span class="comment">// but may not be empty.</span></span><br><span class="line">buckets = dirtyalloc</span><br><span class="line">size := t.bucket.size * nbuckets</span><br><span class="line"><span class="keyword">if</span> t.bucket.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">memclrHasPointers(buckets, size)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memclrNoHeapPointers(buckets, size)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> base != nbuckets &#123;</span><br><span class="line">        <span class="comment">// 如果内存块桶数量 大于2^B，将2^B个桶后面的桶初始化为溢出桶</span></span><br><span class="line"><span class="comment">// We preallocated some overflow buckets.</span></span><br><span class="line"><span class="comment">// To keep the overhead of tracking these overflow buckets to a minimum,</span></span><br><span class="line"><span class="comment">// we use the convention that if a preallocated overflow bucket&#x27;s overflow</span></span><br><span class="line"><span class="comment">// pointer is nil, then there are more available by bumping the pointer.</span></span><br><span class="line"><span class="comment">// We need a safe non-nil pointer for the last overflow bucket; just use buckets.</span></span><br><span class="line">        <span class="comment">// 溢出桶的起始地址</span></span><br><span class="line">nextOverflow = (*bmap)(add(buckets, base*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">        <span class="comment">// 内存块中最后一个溢出桶的位置</span></span><br><span class="line">last := (*bmap)(add(buckets, (nbuckets<span class="number">-1</span>)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">        <span class="comment">// 将内存块最后一个溢出桶的ovf 指针 指向起始地址。 这里的目的是为了后面判断内存块中是否有可用的溢出桶</span></span><br><span class="line">last.setoverflow(t, (*bmap)(buckets))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buckets, nextOverflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取值相关-a-m-quot-a-quot-a-ok-m-quot-a-quot-for-k-v-range-m-quot-a-quot"><a href="#取值相关-a-m-quot-a-quot-a-ok-m-quot-a-quot-for-k-v-range-m-quot-a-quot" class="headerlink" title="取值相关 a := m[&quot;a&quot;] a,ok := m[&quot;a&quot;] for k,v:=range m[&quot;a&quot;]"></a>取值相关 <code>a := m[&quot;a&quot;] a,ok := m[&quot;a&quot;] for k,v:=range m[&quot;a&quot;]</code></h3><p>map查找步骤如下：</p><ol><li>根据哈希算法，以及哈希因子可以得到将key哈希后的值hashKey</li><li>将hashKey&amp;(1&lt;&lt;B-1)即可知道当前的key所在的桶编号，根据桶编号，将指针偏移即可得到key所在桶的桶指针b。</li><li>判断当前hmap是否是处于扩容状态。 如果处于扩容状态，在旧hmap中在执行第二步，即获取在旧hmap中的桶指针oldb，根据桶指针，可以判断出当前桶是否已经迁移，未迁移，b=oldb</li><li>根据hash值，获取tophash值 ，即高8位字段，如果小于4 则+4。 在tophash值一致的情况下 获取key， 进行比对，如果相等，获取value 并返回。 不等， 继续循环。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//几个名字，简单明了,1就是返回value,2就是value+bool，k就是返回key+value。实现方式也都一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mapaccess1 returns a pointer to h[key].  Never returns nil, instead</span></span><br><span class="line"><span class="comment">// it will return a reference to the zero object for the value type if</span></span><br><span class="line"><span class="comment">// the key is not in the map.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> The returned pointer may keep the whole map live, so don&#x27;t</span></span><br><span class="line"><span class="comment">// hold onto it for very long.</span></span><br><span class="line"><span class="comment">//mapaccess1返回一个h[key]的指针，不会返回nil，如果不在map中就返回一个zero object的引用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess1</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">pc := funcPC(mapaccess1)</span><br><span class="line">racereadpc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">msanread(key, t.key.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//处理 key是一个不可比较的类型的情况</span></span><br><span class="line"><span class="keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">t.key.alg.hash(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// flags字段标示状态，这是如果多个goroutine同时对hmap进行修改，这里抛出异常</span></span><br><span class="line">throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">alg := t.key.alg <span class="comment">// alg是maptype的哈希方法</span></span><br><span class="line">hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0))<span class="comment">// 进行哈希操作，统一使用一个哈希因子（hash0字段）</span></span><br><span class="line">m := bucketMask(h.B)<span class="comment">// 算一下掩码</span></span><br><span class="line">    b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))<span class="comment">// hash&amp;m其实就是hash%h.B 就可以得到当前的key所在桶的编号，通过指针偏移，即可得到所在桶的桶指针</span></span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果在扩容中</span></span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// 如果不是等比例扩容，即发生的2倍扩容，则旧hmap的掩码为m&gt;&gt;1</span></span><br><span class="line"><span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">m &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 获取在旧hmap中所在桶的桶指针</span></span><br><span class="line">oldb := (*bmap)(add(c, (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">            <span class="comment">// 如果旧hmap所在桶未发生迁移，即数据还在旧hmap中时，直接将桶指针指向旧hmap中的桶</span></span><br><span class="line">b = oldb</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">top := tophash(hash)<span class="comment">// 获取tophash的值（64位中高8位的字段）</span></span><br><span class="line">bucketloop:</span><br><span class="line">    <span class="comment">// 遍历桶， 桶 -&gt; 溢出桶-&gt; 溢出桶-&gt; nil  以类似的方式进行</span></span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">        <span class="comment">// 遍历桶中的元素</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line">                    <span class="comment">//如果tophash不等，并且后续没有非空单元了，直接跳出</span></span><br><span class="line"><span class="keyword">break</span> bucketloop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 获取key</span></span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                <span class="comment">// 如果key是个指针， 获取真正的数据</span></span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> alg.equal(key, k) &#123;<span class="comment">// 比较key是否一致</span></span><br><span class="line">                <span class="comment">//获取value</span></span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">                     <span class="comment">// 如果value是个指针， 获取真正的数据</span></span><br><span class="line">v = *((*unsafe.Pointer)(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//未找到返回0值</span></span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面都跟上面一样，返回值不同而已</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccess2</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">pc := funcPC(mapaccess2)</span><br><span class="line">racereadpc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">msanread(key, t.key.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">t.key.alg.hash(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>]), <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;concurrent map read and map write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">alg := t.key.alg</span><br><span class="line">hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line">b := (*bmap)(unsafe.Pointer(<span class="type">uintptr</span>(h.buckets) + (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">m &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">oldb := (*bmap)(unsafe.Pointer(<span class="type">uintptr</span>(c) + (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">b = oldb</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line"><span class="keyword">break</span> bucketloop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">v = *((*unsafe.Pointer)(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="number">0</span>]), <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns both key and value. Used by map iterator</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapaccessK</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> (unsafe.Pointer, unsafe.Pointer) &#123;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">alg := t.key.alg</span><br><span class="line">hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line">m := bucketMask(h.B)</span><br><span class="line">b := (*bmap)(unsafe.Pointer(<span class="type">uintptr</span>(h.buckets) + (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> c := h.oldbuckets; c != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">// There used to be half as many buckets; mask down one more power of two.</span></span><br><span class="line">m &gt;&gt;= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">oldb := (*bmap)(unsafe.Pointer(<span class="type">uintptr</span>(c) + (hash&amp;m)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> !evacuated(oldb) &#123;</span><br><span class="line">b = oldb</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">top := tophash(hash)</span><br><span class="line">bucketloop:</span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line"><span class="keyword">break</span> bucketloop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> alg.equal(key, k) &#123;</span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">v = *((*unsafe.Pointer)(v))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> k, v</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器遍历</span></span><br><span class="line"><span class="comment">// mapiterinit initializes the hiter struct used for ranging over maps.</span></span><br><span class="line"><span class="comment">// The hiter struct pointed to by &#x27;it&#x27; is allocated on the stack</span></span><br><span class="line"><span class="comment">// by the compilers order pass or on the heap by reflect_mapiterinit.</span></span><br><span class="line"><span class="comment">// Both need to have zeroed hiter since the struct contains pointers.</span></span><br><span class="line"><span class="comment">// 迭代器的初始化 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiterinit</span><span class="params">(t *maptype, h *hmap, it *hiter)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiterinit))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> unsafe.Sizeof(hiter&#123;&#125;)/sys.PtrSize != <span class="number">12</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;hash_iter size incorrect&quot;</span>) <span class="comment">// see cmd/compile/internal/gc/reflect.go</span></span><br><span class="line">&#125;</span><br><span class="line">it.t = t</span><br><span class="line">it.h = h</span><br><span class="line"></span><br><span class="line"><span class="comment">// grab snapshot of bucket state</span></span><br><span class="line">it.B = h.B</span><br><span class="line">it.buckets = h.buckets</span><br><span class="line"><span class="keyword">if</span> t.bucket.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Allocate the current slice and remember pointers to both current and old.</span></span><br><span class="line"><span class="comment">// This preserves all relevant overflow buckets alive even if</span></span><br><span class="line"><span class="comment">// the table grows and/or overflow buckets are added to the table</span></span><br><span class="line"><span class="comment">// while we are iterating.</span></span><br><span class="line">h.createOverflow()</span><br><span class="line">it.overflow = h.extra.overflow</span><br><span class="line">it.oldoverflow = h.extra.oldoverflow</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// decide where to start</span></span><br><span class="line">    <span class="comment">// 随机值来选择一个遍历起点。。。这就是为什么遍历map的时候顺序不一样的原因</span></span><br><span class="line">r := <span class="type">uintptr</span>(fastrand())</span><br><span class="line">    <span class="comment">//3位桶内位置+B位桶位置 &gt;31的话 fastrand的32位随机数不够用得再加一个32位</span></span><br><span class="line"><span class="keyword">if</span> h.B &gt; <span class="number">31</span>-bucketCntBits &#123;</span><br><span class="line">r += <span class="type">uintptr</span>(fastrand()) &lt;&lt; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line">it.startBucket = r &amp; bucketMask(h.B)</span><br><span class="line">    <span class="comment">//随机来算一个桶内起始位置</span></span><br><span class="line">it.offset = <span class="type">uint8</span>(r &gt;&gt; h.B &amp; (bucketCnt - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator state</span></span><br><span class="line">it.bucket = it.startBucket</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remember we have an iterator.</span></span><br><span class="line"><span class="comment">// Can run concurrently with another mapiterinit().</span></span><br><span class="line"><span class="keyword">if</span> old := h.flags; old&amp;(iterator|oldIterator) != iterator|oldIterator &#123;</span><br><span class="line">        <span class="comment">// 标记有一个迭代器</span></span><br><span class="line">atomic.Or8(&amp;h.flags, iterator|oldIterator)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mapiternext(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapiternext</span><span class="params">(it *hiter)</span></span> &#123;</span><br><span class="line">h := it.h</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiternext))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;concurrent map iteration and map write&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">t := it.t</span><br><span class="line">bucket := it.bucket</span><br><span class="line">b := it.bptr</span><br><span class="line">i := it.i</span><br><span class="line">checkBucket := it.checkBucket</span><br><span class="line">alg := t.key.alg</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line"><span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> bucket == it.startBucket &amp;&amp; it.wrapped &#123;</span><br><span class="line"><span class="comment">// end of iteration</span></span><br><span class="line">it.key = <span class="literal">nil</span></span><br><span class="line">it.value = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//这里一共有6种情况</span></span><br><span class="line">        <span class="comment">//1.遍历开始到结束时都未扩容</span></span><br><span class="line">        <span class="comment">//2.遍历开始时未扩容，遍历中等比扩容，it.b==h.B</span></span><br><span class="line"><span class="comment">//3.遍历开始时未扩容，遍历中二倍扩容，it.b!=h.B</span></span><br><span class="line">        <span class="comment">//4.遍历开始时已经在等比扩容中，it.b==h.B</span></span><br><span class="line">        <span class="comment">//5.遍历开始时已经在二倍扩容中，it.b==h.B</span></span><br><span class="line">        <span class="comment">//这一段逻辑主要是保证b的指向一定是在有数据的buckets中，</span></span><br><span class="line">        <span class="comment">//如果已经迁移了，那么就指向新buckets</span></span><br><span class="line">        <span class="comment">//没有迁移就指向旧buckets</span></span><br><span class="line"><span class="keyword">if</span> h.growing() &amp;&amp; it.B == h.B &#123;</span><br><span class="line">            <span class="comment">// 4,5情况会走这个，2在开始扩容后也会走这个，所以这里并不能判断是不是等比扩容，需要额外一个ckeckBucket后续来做判断</span></span><br><span class="line">            <span class="comment">// 这个时候，如果迁移完了，checkBucket就为noCheck，也就是不用check，否则就是当前bucket</span></span><br><span class="line"><span class="comment">// Iterator was started in the middle of a grow, and the grow isn&#x27;t done yet.</span></span><br><span class="line"><span class="comment">// If the bucket we&#x27;re looking at hasn&#x27;t been filled in yet (i.e. the old</span></span><br><span class="line"><span class="comment">// bucket hasn&#x27;t been evacuated) then we need to iterate through the old</span></span><br><span class="line"><span class="comment">// bucket and only return the ones that will be migrated to this bucket.</span></span><br><span class="line">oldbucket := bucket &amp; it.h.oldbucketmask()</span><br><span class="line">b = (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line"><span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line">checkBucket = bucket</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//1，3情况是这个，2在开始扩容前会走这个</span></span><br><span class="line">b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">checkBucket = noCheck</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">b = (*bmap)(add(it.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">checkBucket = noCheck</span><br><span class="line">&#125;</span><br><span class="line">bucket++</span><br><span class="line"><span class="keyword">if</span> bucket == bucketShift(it.B) &#123;</span><br><span class="line">bucket = <span class="number">0</span></span><br><span class="line">it.wrapped = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ; i &lt; bucketCnt; i++ &#123;</span><br><span class="line">offi := (i + it.offset) &amp; (bucketCnt - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> isEmpty(b.tophash[offi]) || b.tophash[offi] == evacuatedEmpty &#123;</span><br><span class="line">            <span class="comment">// 如果为空或者是迁移后的，直接跳过</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> emptyRest is hard to use here, as we start iterating</span></span><br><span class="line"><span class="comment">// in the middle of a bucket. It&#x27;s feasible, just tricky.</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+<span class="type">uintptr</span>(offi)*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> checkBucket != noCheck &amp;&amp; !h.sameSizeGrow() &#123;</span><br><span class="line">            <span class="comment">// 这种情况是当开始遍历还没有2倍扩容迁移旧桶的时候，需要跳过之后这个旧桶迁移过去的新的桶</span></span><br><span class="line"><span class="comment">// Special case: iterator was started during a grow to a larger size</span></span><br><span class="line"><span class="comment">// and the grow is not done yet. We&#x27;re working on a bucket whose</span></span><br><span class="line"><span class="comment">// oldbucket has not been evacuated yet. Or at least, it wasn&#x27;t</span></span><br><span class="line"><span class="comment">// evacuated when we started the bucket. So we&#x27;re iterating</span></span><br><span class="line"><span class="comment">// through the oldbucket, skipping any keys that will go</span></span><br><span class="line"><span class="comment">// to the other new bucket (each oldbucket expands to two</span></span><br><span class="line"><span class="comment">// buckets during a grow).</span></span><br><span class="line">            <span class="comment">//这里处理一种特殊情况 NaN != NaN</span></span><br><span class="line"><span class="keyword">if</span> t.reflexivekey() || alg.equal(k, k) &#123;</span><br><span class="line"><span class="comment">// If the item in the oldbucket is not destined for</span></span><br><span class="line"><span class="comment">// the current new bucket in the iteration, skip it.</span></span><br><span class="line">hash := alg.hash(k, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"><span class="keyword">if</span> hash&amp;bucketMask(it.B) != checkBucket &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Hash isn&#x27;t repeatable if k != k (NaNs).  We need a</span></span><br><span class="line"><span class="comment">// repeatable and randomish choice of which direction</span></span><br><span class="line"><span class="comment">// to send NaNs during evacuation. We&#x27;ll use the low</span></span><br><span class="line"><span class="comment">// bit of tophash to decide which way NaNs go.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> this case is why we need two evacuate tophash</span></span><br><span class="line"><span class="comment">// values, evacuatedX and evacuatedY, that differ in</span></span><br><span class="line"><span class="comment">// their low bit.</span></span><br><span class="line">        <span class="comment">//evacuatedX=2、evacuatedY=3区分左右桶的一个用途，遍历NaNs可能出现的重复过滤： </span></span><br><span class="line">        <span class="comment">//迁移时:原桶的 NaNs根据桶的（tophash&amp;1），进行随机的左右放;注意：迁移到新的桶中的top被重新随机赋值了。 </span></span><br><span class="line">        <span class="comment">//遍历时: 根据计算原来桶中的状态，即evacuatedX=2、evacuatedY=3来判断。</span></span><br><span class="line">        <span class="comment">//如果是evacuatedX，则tophash&amp;1= 0     </span></span><br><span class="line">        <span class="comment">//如果是evacuatedY，则tophash&amp;1= 1  </span></span><br><span class="line">   <span class="comment">//那么当前遍历的是桶的右边还是左边，则是用：checkBucket&gt;&gt;(it.B-1)的最高位来判断。</span></span><br><span class="line">        <span class="comment">//因此，下面代码就是判断，原来的NaNs迁移的左右桶和访问左右桶不一致时，跳过</span></span><br><span class="line"><span class="keyword">if</span> checkBucket&gt;&gt;(it.B<span class="number">-1</span>) != <span class="type">uintptr</span>(b.tophash[offi]&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (b.tophash[offi] != evacuatedX &amp;&amp; b.tophash[offi] != evacuatedY) ||</span><br><span class="line">!(t.reflexivekey() || alg.equal(k, k)) &#123;</span><br><span class="line"><span class="comment">// This is the golden data, we can return it.</span></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"><span class="comment">// key!=key, so the entry can&#x27;t be deleted or updated, so we can just return it.</span></span><br><span class="line"><span class="comment">// That&#x27;s lucky for us because when key!=key we can&#x27;t look it up successfully.</span></span><br><span class="line">it.key = k</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">v = *((*unsafe.Pointer)(v))</span><br><span class="line">&#125;</span><br><span class="line">it.value = v</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这个时候是迭代器开始之后hash表已经扩容完了</span></span><br><span class="line"><span class="comment">// The hash table has grown since the iterator was started.</span></span><br><span class="line"><span class="comment">// The golden data for this key is now somewhere else.</span></span><br><span class="line"><span class="comment">// Check the current hash table for the data.</span></span><br><span class="line"><span class="comment">// This code handles the case where the key</span></span><br><span class="line"><span class="comment">// has been deleted, updated, or deleted and reinserted.</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> we need to regrab the key as it has potentially been</span></span><br><span class="line"><span class="comment">// updated to an equal() but not identical key (e.g. +0.0 vs -0.0).</span></span><br><span class="line">            <span class="comment">// 处理key被删，更新，和删除后又插入同样的key的情况，</span></span><br><span class="line"><span class="comment">// 重新取一遍key value</span></span><br><span class="line">rk, rv := mapaccessK(t, h, k)</span><br><span class="line"><span class="keyword">if</span> rk == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// key has been deleted</span></span><br><span class="line">&#125;</span><br><span class="line">it.key = rk</span><br><span class="line">it.value = rv</span><br><span class="line">&#125;</span><br><span class="line">it.bucket = bucket</span><br><span class="line"><span class="keyword">if</span> it.bptr != b &#123; <span class="comment">// avoid unnecessary write barrier; see issue 14921</span></span><br><span class="line">it.bptr = b</span><br><span class="line">&#125;</span><br><span class="line">it.i = i + <span class="number">1</span></span><br><span class="line">it.checkBucket = checkBucket</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 当前bucket遍历完了，开始遍历下一个</span></span><br><span class="line">b = b.overflow(t)</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">goto</span> next</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="map赋值-m-quot-a-quot-1"><a href="#map赋值-m-quot-a-quot-1" class="headerlink" title="map赋值 m[&quot;a&quot;]=1"></a>map赋值 <code>m[&quot;a&quot;]=1</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span></span><br><span class="line"><span class="comment">//key不在map中就申请单元，在里面就修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> unsafe.Pointer &#123;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;assignment to entry in nil map&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">pc := funcPC(mapassign)</span><br><span class="line">racewritepc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanread(key, t.key.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;<span class="comment">// 防止多个goroutine写</span></span><br><span class="line">throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//计算key的hash值</span></span><br><span class="line">alg := t.key.alg</span><br><span class="line">hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set hashWriting after calling alg.hash, since alg.hash may panic,</span></span><br><span class="line"><span class="comment">// in which case we have not actually done a write.</span></span><br><span class="line">    <span class="comment">// flags置位hashWriting，类似于拿个锁</span></span><br><span class="line">h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h.buckets == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 没有buckets就新建一个</span></span><br><span class="line">h.buckets = newobject(t.bucket) <span class="comment">// newarray(t.bucket, 1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">again:</span><br><span class="line">    <span class="comment">//算一下桶位置</span></span><br><span class="line">bucket := hash &amp; bucketMask(h.B)</span><br><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">//如果在扩容中，干一下扩容的事情，具体看下方map扩容相关</span></span><br><span class="line">growWork(t, h, bucket)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//根据偏移拿到具体的桶</span></span><br><span class="line">b := (*bmap)(unsafe.Pointer(<span class="type">uintptr</span>(h.buckets) + bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">top := tophash(hash)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inserti *<span class="type">uint8</span></span><br><span class="line"><span class="keyword">var</span> insertk unsafe.Pointer</span><br><span class="line"><span class="keyword">var</span> val unsafe.Pointer</span><br><span class="line">bucketloop:</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line">            <span class="comment">// 在tophash值不等的情况下，找到一个未使用的位置</span></span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == <span class="literal">nil</span> &#123;</span><br><span class="line">inserti = &amp;b.tophash[i]</span><br><span class="line">insertk = add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line"><span class="keyword">break</span> bucketloop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 在tophash相等的情况下，  进行比对key值是否相等</span></span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">k = *((*unsafe.Pointer)(k))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !alg.equal(key, k) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// already have a mapping for key. Update it.</span></span><br><span class="line">            <span class="comment">// 如果key相等，就将旧的key释放，即更新key</span></span><br><span class="line"><span class="keyword">if</span> t.needkeyupdate() &#123;</span><br><span class="line">typedmemmove(t.key, k, key)</span><br><span class="line">&#125;</span><br><span class="line">val = add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">goto</span> done</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 查找下一个溢出桶</span></span><br><span class="line">ovf := b.overflow(t)</span><br><span class="line"><span class="keyword">if</span> ovf == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">b = ovf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Did not find mapping for key. Allocate new cell &amp; add entry.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If we hit the max load factor or we have too many overflow buckets,</span></span><br><span class="line"><span class="comment">// and we&#x27;re not already in the middle of growing, start growing.</span></span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line"><span class="keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;</span><br><span class="line">hashGrow(t, h)</span><br><span class="line"><span class="keyword">goto</span> again <span class="comment">// Growing the table invalidates everything, so try again</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    / 如果找不到位置，则新建一个溢出桶，</span><br><span class="line"><span class="keyword">if</span> inserti == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// all current buckets are full, allocate a new one.</span></span><br><span class="line">newb := h.newoverflow(t, b)</span><br><span class="line">inserti = &amp;newb.tophash[<span class="number">0</span>]</span><br><span class="line">insertk = add(unsafe.Pointer(newb), dataOffset)</span><br><span class="line">val = add(insertk, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// store new key/value at insert position</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">kmem := newobject(t.key)</span><br><span class="line">*(*unsafe.Pointer)(insertk) = kmem</span><br><span class="line">insertk = kmem</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">vmem := newobject(t.elem)</span><br><span class="line">*(*unsafe.Pointer)(val) = vmem</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将key移除，使用新key</span></span><br><span class="line">typedmemmove(t.key, insertk, key)</span><br><span class="line">    <span class="comment">// 保存tophash值</span></span><br><span class="line">*inserti = top</span><br><span class="line">h.count++</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">h.flags &amp;^= hashWriting</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">val = *((*unsafe.Pointer)(val))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际的赋值是在编译层做的，会多插一条MOV语句</span></span><br><span class="line"><span class="comment">//所以reflect的时候需要手动赋值</span></span><br><span class="line"><span class="comment">//go:linkname reflect_mapassign reflect.mapassign</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_mapassign</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer, val unsafe.Pointer)</span></span> &#123;</span><br><span class="line">    p := mapassign(t, h, key)</span><br><span class="line">    typedmemmove(t.elem, p, val)    <span class="comment">// 这里做的更新value的操作 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map删除"><a href="#map删除" class="headerlink" title="map删除"></a>map删除</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapdelete</span><span class="params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">pc := funcPC(mapdelete)</span><br><span class="line">racewritepc(unsafe.Pointer(h), callerpc, pc)</span><br><span class="line">raceReadObjectPC(t.key, key, callerpc, pc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &amp;&amp; h != <span class="literal">nil</span> &#123;</span><br><span class="line">msanread(key, t.key.size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h == <span class="literal">nil</span> || h.count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> t.hashMightPanic() &#123;</span><br><span class="line">t.key.alg.hash(key, <span class="number">0</span>) <span class="comment">// see issue 23734</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alg := t.key.alg</span><br><span class="line">hash := alg.hash(key, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set hashWriting after calling alg.hash, since alg.hash may panic,</span></span><br><span class="line"><span class="comment">// in which case we have not actually done a write (delete).</span></span><br><span class="line">h.flags ^= hashWriting</span><br><span class="line"></span><br><span class="line">bucket := hash &amp; bucketMask(h.B)</span><br><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">growWork(t, h, bucket)</span><br><span class="line">&#125;</span><br><span class="line">b := (*bmap)(add(h.buckets, bucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">bOrig := b</span><br><span class="line">top := tophash(hash)</span><br><span class="line">search:</span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">0</span>); i &lt; bucketCnt; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != top &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] == emptyRest &#123;</span><br><span class="line"><span class="keyword">break</span> search</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset+i*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">k2 := k</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !alg.equal(key, k2) &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 前面逻辑与取值一致</span></span><br><span class="line"><span class="comment">// Only clear key if there are pointers in it.</span></span><br><span class="line">            <span class="comment">// 找到之后，如果是指针就清除掉</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">*(*unsafe.Pointer)(k) = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.key.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">memclrHasPointers(k, t.key.size)</span><br><span class="line">&#125;</span><br><span class="line">v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="type">uintptr</span>(t.keysize)+i*<span class="type">uintptr</span>(t.valuesize))</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">*(*unsafe.Pointer)(v) = <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> t.elem.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">memclrHasPointers(v, t.elem.size)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">memclrNoHeapPointers(v, t.elem.size)</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//tophash单元置位</span></span><br><span class="line">b.tophash[i] = emptyOne</span><br><span class="line"><span class="comment">// If the bucket now ends in a bunch of emptyOne states,</span></span><br><span class="line"><span class="comment">// change those to emptyRest states.</span></span><br><span class="line"><span class="comment">// It would be nice to make this a separate function, but</span></span><br><span class="line"><span class="comment">// for loops are not currently inlineable.</span></span><br><span class="line"><span class="keyword">if</span> i == bucketCnt<span class="number">-1</span> &#123;</span><br><span class="line">                <span class="comment">//如果遍历到bucket最后一个，判断ovf有没有别的</span></span><br><span class="line">                <span class="comment">// 如果有并且tophash等于emptyRest证明后面没有非空单元，所以跳过后面的置位操作</span></span><br><span class="line"><span class="keyword">if</span> b.overflow(t) != <span class="literal">nil</span> &amp;&amp; b.overflow(t).tophash[<span class="number">0</span>] != emptyRest &#123;</span><br><span class="line"><span class="keyword">goto</span> notLast</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i+<span class="number">1</span>] != emptyRest &#123;</span><br><span class="line"><span class="keyword">goto</span> notLast</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="comment">//删掉后要把tophash置位</span></span><br><span class="line">b.tophash[i] = emptyRest</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> b == bOrig &#123;</span><br><span class="line">                        <span class="comment">//如果是第一个bucket的头，就证明做完了</span></span><br><span class="line"><span class="keyword">break</span> <span class="comment">// beginning of initial bucket, we&#x27;re done.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Find previous bucket, continue at its last entry.</span></span><br><span class="line">                    <span class="comment">//找到前置的bucket</span></span><br><span class="line">c := b</span><br><span class="line"><span class="keyword">for</span> b = bOrig; b.overflow(t) != c; b = b.overflow(t) &#123;</span><br><span class="line">&#125;</span><br><span class="line">i = bucketCnt - <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//当前bucket index往前移</span></span><br><span class="line">i--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> b.tophash[i] != emptyOne &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">notLast:</span><br><span class="line">            <span class="comment">//删了一个元素，所以计数-1</span></span><br><span class="line">h.count--</span><br><span class="line"><span class="keyword">break</span> search</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;hashWriting == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;concurrent map writes&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">h.flags &amp;^= hashWriting</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p><strong>数据搬迁不是一次性完成，而是逐步的完成（在insert和remove时进行搬移），这样就分摊了扩容的耗时。同时为了避免有个bucket一直访问不到导致扩容无法完成，还会进行一个顺序扩容，每次因为写操作搬迁对应bucket后，还会按顺序搬迁未搬迁的bucket，所以最差情况下n次写操作，就保证搬迁完大小为n的map。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growWork</span><span class="params">(t *maptype, h *hmap, bucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// make sure we evacuate the oldbucket corresponding</span></span><br><span class="line"><span class="comment">// to the bucket we&#x27;re about to use</span></span><br><span class="line">    <span class="comment">//具体的迁移方法</span></span><br><span class="line">evacuate(t, h, bucket&amp;h.oldbucketmask())</span><br><span class="line"></span><br><span class="line"><span class="comment">// evacuate one more oldbucket to make progress on growing</span></span><br><span class="line"><span class="keyword">if</span> h.growing() &#123;</span><br><span class="line">        <span class="comment">//迁移中的话多迁移一个</span></span><br><span class="line">evacuate(t, h, h.nevacuate)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuate</span><span class="params">(t *maptype, h *hmap, oldbucket <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 取到具体的bucket</span></span><br><span class="line">b := (*bmap)(add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">    <span class="comment">// 拿到现在状态的h的B状态</span></span><br><span class="line">newbit := h.noldbuckets()</span><br><span class="line"><span class="keyword">if</span> !evacuated(b) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> reuse overflow buckets instead of using new ones, if there</span></span><br><span class="line"><span class="comment">// is no iterator using the old buckets.  (If !oldIterator.)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// xy contains the x and y (low and high) evacuation destinations.</span></span><br><span class="line">        <span class="comment">// x y分别代表同大小扩容后的位置和2倍扩容后的位置</span></span><br><span class="line">        <span class="comment">// eg. B=2 扩容后B=4 当前迁移的bucket=2,所以newbit=4</span></span><br><span class="line">        <span class="comment">// h.oldbuckets 0 1 2 3</span></span><br><span class="line">        <span class="comment">// h.buckets 0 1 2 3 4 5 6 7 8 ....</span></span><br><span class="line">        <span class="comment">// x    y</span></span><br><span class="line"><span class="keyword">var</span> xy [<span class="number">2</span>]evacDst</span><br><span class="line">        <span class="comment">//填充旧的bucket数据</span></span><br><span class="line">x := &amp;xy[<span class="number">0</span>]</span><br><span class="line">x.b = (*bmap)(add(h.buckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">x.k = add(unsafe.Pointer(x.b), dataOffset)</span><br><span class="line">x.v = add(x.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">// Only calculate y pointers if we&#x27;re growing bigger.</span></span><br><span class="line"><span class="comment">// Otherwise GC can see bad pointers.</span></span><br><span class="line">            <span class="comment">// 扩容的时候只计算高位</span></span><br><span class="line">            <span class="comment">// 填充新的bucket数据</span></span><br><span class="line">y := &amp;xy[<span class="number">1</span>]</span><br><span class="line">y.b = (*bmap)(add(h.buckets, (oldbucket+newbit)*<span class="type">uintptr</span>(t.bucketsize)))</span><br><span class="line">y.k = add(unsafe.Pointer(y.b), dataOffset)</span><br><span class="line">y.v = add(y.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ; b != <span class="literal">nil</span>; b = b.overflow(t) &#123;</span><br><span class="line">            <span class="comment">//取keys values 起始地址</span></span><br><span class="line">k := add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">v := add(k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="number">1</span>, add(k, <span class="type">uintptr</span>(t.keysize)), add(v, <span class="type">uintptr</span>(t.valuesize)) &#123;</span><br><span class="line">                <span class="comment">//遍历所有key value</span></span><br><span class="line">top := b.tophash[i]</span><br><span class="line"><span class="keyword">if</span> isEmpty(top) &#123;</span><br><span class="line">                    <span class="comment">// 如果是空就把标志位置为evacuatedEmpty</span></span><br><span class="line">b.tophash[i] = evacuatedEmpty</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> top &lt; minTopHash &#123;</span><br><span class="line">                    <span class="comment">//top 理论上绝对比minTopHash大</span></span><br><span class="line">throw(<span class="string">&quot;bad map state&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">k2 := k</span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">                    <span class="comment">//取k实际值</span></span><br><span class="line">k2 = *((*unsafe.Pointer)(k2))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> useY <span class="type">uint8</span></span><br><span class="line"><span class="keyword">if</span> !h.sameSizeGrow() &#123;</span><br><span class="line"><span class="comment">// Compute hash to make our evacuation decision (whether we need</span></span><br><span class="line"><span class="comment">// to send this key/value to bucket x or bucket y).</span></span><br><span class="line">hash := t.key.alg.hash(k2, <span class="type">uintptr</span>(h.hash0))</span><br><span class="line"><span class="keyword">if</span> h.flags&amp;iterator != <span class="number">0</span> &amp;&amp; !t.reflexivekey() &amp;&amp; !t.key.alg.equal(k2, k2) &#123;</span><br><span class="line"><span class="comment">// If key != key (NaNs), then the hash could be (and probably</span></span><br><span class="line"><span class="comment">// will be) entirely different from the old hash. Moreover,</span></span><br><span class="line"><span class="comment">// it isn&#x27;t reproducible. Reproducibility is required in the</span></span><br><span class="line"><span class="comment">// presence of iterators, as our evacuation decision must</span></span><br><span class="line"><span class="comment">// match whatever decision the iterator made.</span></span><br><span class="line"><span class="comment">// Fortunately, we have the freedom to send these keys either</span></span><br><span class="line"><span class="comment">// way. Also, tophash is meaningless for these kinds of keys.</span></span><br><span class="line"><span class="comment">// We let the low bit of tophash drive the evacuation decision.</span></span><br><span class="line"><span class="comment">// We recompute a new random tophash for the next level so</span></span><br><span class="line"><span class="comment">// these keys will get evenly distributed across all buckets</span></span><br><span class="line"><span class="comment">// after multiple grows.</span></span><br><span class="line">                        <span class="comment">// 如果buckets没有迭代器，key也不等于key，也就是NaN这一类，就用tophash的最低位来判断，并且重新计算一个新的随机tophash</span></span><br><span class="line">useY = top &amp; <span class="number">1</span></span><br><span class="line">top = tophash(hash)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> hash&amp;newbit != <span class="number">0</span> &#123;</span><br><span class="line">                            <span class="comment">//也是个随机处理，为了平分到两个桶内</span></span><br><span class="line">useY = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> evacuatedX+<span class="number">1</span> != evacuatedY || evacuatedX^<span class="number">1</span> != evacuatedY &#123;</span><br><span class="line">throw(<span class="string">&quot;bad evacuatedN&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b.tophash[i] = evacuatedX + useY <span class="comment">// evacuatedX + 1 == evacuatedY</span></span><br><span class="line">                <span class="comment">//取到迁移目标</span></span><br><span class="line">dst := &amp;xy[useY]                 <span class="comment">// evacuation destination</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> dst.i == bucketCnt &#123;</span><br><span class="line">                    <span class="comment">//如果个数超了，就新建一个新的bucket</span></span><br><span class="line">dst.b = h.newoverflow(t, dst.b)</span><br><span class="line">dst.i = <span class="number">0</span></span><br><span class="line">dst.k = add(unsafe.Pointer(dst.b), dataOffset)</span><br><span class="line">dst.v = add(dst.k, bucketCnt*<span class="type">uintptr</span>(t.keysize))</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//dst.i&amp;(bucketCnt-1) 就是 dst.i%bucketCnt</span></span><br><span class="line">dst.b.tophash[dst.i&amp;(bucketCnt<span class="number">-1</span>)] = top <span class="comment">// mask dst.i as an optimization, to avoid a bounds check</span></span><br><span class="line"><span class="keyword">if</span> t.indirectkey() &#123;</span><br><span class="line">*(*unsafe.Pointer)(dst.k) = k2 <span class="comment">// copy pointer</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">typedmemmove(t.key, dst.k, k) <span class="comment">// copy value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> t.indirectvalue() &#123;</span><br><span class="line">*(*unsafe.Pointer)(dst.v) = *(*unsafe.Pointer)(v)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">typedmemmove(t.elem, dst.v, v)</span><br><span class="line">&#125;</span><br><span class="line">dst.i++</span><br><span class="line"><span class="comment">// These updates might push these pointers past the end of the</span></span><br><span class="line"><span class="comment">// key or value arrays.  That&#x27;s ok, as we have the overflow pointer</span></span><br><span class="line"><span class="comment">// at the end of the bucket to protect against pointing past the</span></span><br><span class="line"><span class="comment">// end of the bucket.</span></span><br><span class="line">                <span class="comment">// k，v 指针往后移动一个</span></span><br><span class="line">dst.k = add(dst.k, <span class="type">uintptr</span>(t.keysize))</span><br><span class="line">dst.v = add(dst.v, <span class="type">uintptr</span>(t.valuesize))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unlink the overflow buckets &amp; clear key/value to help GC.</span></span><br><span class="line"><span class="keyword">if</span> h.flags&amp;oldIterator == <span class="number">0</span> &amp;&amp; t.bucket.kind&amp;kindNoPointers == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//如果没有oldbuckets迭代器，清除一下旧的内存</span></span><br><span class="line">b := add(h.oldbuckets, oldbucket*<span class="type">uintptr</span>(t.bucketsize))</span><br><span class="line"><span class="comment">// Preserve b.tophash because the evacuation</span></span><br><span class="line"><span class="comment">// state is maintained there.</span></span><br><span class="line">ptr := add(b, dataOffset)</span><br><span class="line">n := <span class="type">uintptr</span>(t.bucketsize) - dataOffset</span><br><span class="line">memclrHasPointers(ptr, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> oldbucket == h.nevacuate &#123;</span><br><span class="line">        <span class="comment">//如果当前迁移的bucket等于迁移的数量</span></span><br><span class="line">advanceEvacuationMark(h, t, newbit)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">advanceEvacuationMark</span><span class="params">(h *hmap, t *maptype, newbit <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">h.nevacuate++</span><br><span class="line"><span class="comment">// Experiments suggest that 1024 is overkill by at least an order of magnitude.</span></span><br><span class="line"><span class="comment">// Put it in there as a safeguard anyway, to ensure O(1) behavior.</span></span><br><span class="line">stop := h.nevacuate + <span class="number">1024</span></span><br><span class="line"><span class="keyword">if</span> stop &gt; newbit &#123;</span><br><span class="line">stop = newbit</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;</span><br><span class="line">h.nevacuate++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> h.nevacuate == newbit &#123; <span class="comment">// newbit == # of oldbuckets</span></span><br><span class="line">        <span class="comment">// newbit就是oldbuckets的数目，相等就证明迁移完成了</span></span><br><span class="line"><span class="comment">// Growing is all done. Free old main bucket array.</span></span><br><span class="line">h.oldbuckets = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Can discard old overflow buckets as well.</span></span><br><span class="line"><span class="comment">// If they are still referenced by an iterator,</span></span><br><span class="line"><span class="comment">// then the iterator holds a pointers to the slice.</span></span><br><span class="line"><span class="keyword">if</span> h.extra != <span class="literal">nil</span> &#123;</span><br><span class="line">h.extra.oldoverflow = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">h.flags &amp;^= sameSizeGrow</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-slice</title>
      <link href="/p/1954958954.html"/>
      <url>/p/1954958954.html</url>
      
        <content type="html"><![CDATA[<p>代码版本:<strong>1.12.7</strong></p><p>主要代码在<code>src/runtime/slice.go</code></p><span id="more"></span><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><p>其实slice底层就是一个指向数组的指针，加上两个大小值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">array unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An notInHeapSlice is a slice backed by go:notinheap memory.</span></span><br><span class="line"><span class="keyword">type</span> notInHeapSlice <span class="keyword">struct</span> &#123;</span><br><span class="line">array *notInHeap</span><br><span class="line"><span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line"><span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个panic用的</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicmakeslicelen</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(errorString(<span class="string">&quot;makeslice: len out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicmakeslicecap</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(errorString(<span class="string">&quot;makeslice: cap out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断一个数是否是2的次方</span></span><br><span class="line"><span class="comment">// x&amp;(x-1) 就是把最后一位1置0</span></span><br><span class="line"><span class="comment">// 对于2的次方，只有一个1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPowerOfTwo</span><span class="params">(x <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;(x<span class="number">-1</span>) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h2><h3 id="新建slice-s-make-int-1-1"><a href="#新建slice-s-make-int-1-1" class="headerlink" title="新建slice s:=make([]int,1,1)"></a>新建slice s:=make([]int,1,1)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice</span><span class="params">(et *_type, <span class="built_in">len</span>, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">//算一下cap大小需要的内存，overflow是是否超过最大寻址地址</span></span><br><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">cap</span>))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> || <span class="built_in">len</span> &gt; <span class="built_in">cap</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> Produce a &#x27;len out of range&#x27; error instead of a</span></span><br><span class="line"><span class="comment">// &#x27;cap out of range&#x27; error when someone does make([]T, bignumber).</span></span><br><span class="line"><span class="comment">// &#x27;cap out of range&#x27; is true too, but since the cap is only being</span></span><br><span class="line"><span class="comment">// supplied implicitly, saying len is clearer.</span></span><br><span class="line"><span class="comment">// See golang.org/issue/4085.</span></span><br><span class="line">mem, overflow := math.MulUintptr(et.size, <span class="type">uintptr</span>(<span class="built_in">len</span>))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc || <span class="built_in">len</span> &lt; <span class="number">0</span> &#123;</span><br><span class="line">panicmakeslicelen()</span><br><span class="line">&#125;</span><br><span class="line">panicmakeslicecap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//申请内存，详见string章节</span></span><br><span class="line"><span class="keyword">return</span> mallocgc(mem, et, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编译器用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeslice64</span><span class="params">(et *_type, len64, cap64 <span class="type">int64</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line"><span class="built_in">len</span> := <span class="type">int</span>(len64)</span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="built_in">len</span>) != len64 &#123;</span><br><span class="line">panicmakeslicelen()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cap</span> := <span class="type">int</span>(cap64)</span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="built_in">cap</span>) != cap64 &#123;</span><br><span class="line">panicmakeslicecap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makeslice(et, <span class="built_in">len</span>, <span class="built_in">cap</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// growslice handles slice growth during append.</span></span><br><span class="line"><span class="comment">// It is passed the slice element type, the old slice, and the desired new minimum capacity,</span></span><br><span class="line"><span class="comment">// and it returns a new slice with at least that capacity, with the old data</span></span><br><span class="line"><span class="comment">// copied into it.</span></span><br><span class="line"><span class="comment">// The new slice&#x27;s length is set to the old slice&#x27;s length,</span></span><br><span class="line"><span class="comment">// NOT to the new requested capacity.</span></span><br><span class="line"><span class="comment">// This is for codegen convenience. The old slice&#x27;s length is used immediately</span></span><br><span class="line"><span class="comment">// to calculate where to write new values during an append.</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> When the old backend is gone, reconsider this decision.</span></span><br><span class="line"><span class="comment">// The SSA backend might prefer the new length or to return only ptr/cap and save stack space.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racereadrangepc(old.array, <span class="type">uintptr</span>(old.<span class="built_in">len</span>*<span class="type">int</span>(et.size)), callerpc, funcPC(growslice))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanread(old.array, <span class="type">uintptr</span>(old.<span class="built_in">len</span>*<span class="type">int</span>(et.size)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">        <span class="comment">//扩容的大小比原来还小，报个错</span></span><br><span class="line"><span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// append should not create a slice with nil pointer but non-zero len.</span></span><br><span class="line"><span class="comment">// We assume that append doesn&#x27;t need to preserve old.array in this case.</span></span><br><span class="line">        <span class="comment">// 如果元素大小为0，不用迁移元素，直接申请个新的slice</span></span><br><span class="line"><span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newcap := old.<span class="built_in">cap</span></span><br><span class="line">    <span class="comment">//扩容是旧的大小的双倍扩容</span></span><br><span class="line">doublecap := newcap + newcap</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        <span class="comment">//如果需要的新cap比两倍大小还大就直接扩到新cap大小</span></span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> old.<span class="built_in">len</span> &lt; <span class="number">1024</span> &#123;</span><br><span class="line">            <span class="comment">// 旧的slice元素在1024内就直接双倍大小</span></span><br><span class="line">newcap = doublecap</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Check 0 &lt; newcap to detect overflow</span></span><br><span class="line"><span class="comment">// and prevent an infinite loop.</span></span><br><span class="line">            <span class="comment">// 如果 &gt;=1024 就一直1.25倍扩大到比需要的cap大</span></span><br><span class="line"><span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;</span><br><span class="line">newcap += newcap / <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set newcap to the requested cap when</span></span><br><span class="line"><span class="comment">// the newcap calculation overflowed.</span></span><br><span class="line">            <span class="comment">// 溢出了就直接扩容到cap</span></span><br><span class="line"><span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">newcap = <span class="built_in">cap</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line"><span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line"><span class="comment">// Specialize for common values of et.size.</span></span><br><span class="line"><span class="comment">// For 1 we don&#x27;t need any division/multiplication.</span></span><br><span class="line"><span class="comment">// For sys.PtrSize, compiler will optimize division/multiplication into a shift by a constant.</span></span><br><span class="line"><span class="comment">// For powers of 2, use a variable shift.</span></span><br><span class="line">    <span class="comment">// 不同size大小不同的迁移方法</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">newcap = <span class="type">int</span>(capmem)</span><br><span class="line"><span class="keyword">case</span> et.size == sys.PtrSize:</span><br><span class="line">lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * sys.PtrSize</span><br><span class="line">newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * sys.PtrSize</span><br><span class="line">capmem = roundupsize(<span class="type">uintptr</span>(newcap) * sys.PtrSize)</span><br><span class="line">overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc/sys.PtrSize</span><br><span class="line">newcap = <span class="type">int</span>(capmem / sys.PtrSize)</span><br><span class="line"><span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line"><span class="keyword">var</span> shift <span class="type">uintptr</span></span><br><span class="line"><span class="keyword">if</span> sys.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line"><span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">shift = <span class="type">uintptr</span>(sys.Ctz64(<span class="type">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">shift = <span class="type">uintptr</span>(sys.Ctz32(<span class="type">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">&#125;</span><br><span class="line">lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">capmem = roundupsize(<span class="type">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">overflow = <span class="type">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">newcap = <span class="type">int</span>(capmem &gt;&gt; shift)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">capmem, overflow = math.MulUintptr(et.size, <span class="type">uintptr</span>(newcap))</span><br><span class="line">capmem = roundupsize(capmem)</span><br><span class="line">newcap = <span class="type">int</span>(capmem / et.size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The check of overflow in addition to capmem &gt; maxAlloc is needed</span></span><br><span class="line"><span class="comment">// to prevent an overflow which can be used to trigger a segfault</span></span><br><span class="line"><span class="comment">// on 32bit architectures with this example program:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// type T [1&lt;&lt;27 + 1]int64</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// var d T</span></span><br><span class="line"><span class="comment">// var s []T</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// func main() &#123;</span></span><br><span class="line"><span class="comment">//   s = append(s, d, d, d, d)</span></span><br><span class="line"><span class="comment">//   print(len(s), &quot;\n&quot;)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 超过寻址返回或者内存不够也抛错</span></span><br><span class="line"><span class="keyword">if</span> overflow || capmem &gt; maxAlloc &#123;</span><br><span class="line"><span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line"><span class="keyword">if</span> et.kind&amp;kindNoPointers != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//如果不是指针，就得清除一下从newlen到cap的空间</span></span><br><span class="line">p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).</span></span><br><span class="line"><span class="comment">// Only clear the part that will not be overwritten.</span></span><br><span class="line">memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Note: can&#x27;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.</span></span><br><span class="line">p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> writeBarrier.enabled &#123;</span><br><span class="line"><span class="comment">// Only shade the pointers in old.array since we know the destination slice p</span></span><br><span class="line"><span class="comment">// only contains nil pointers because it has been cleared during alloc.</span></span><br><span class="line">bulkBarrierPreWriteSrcOnly(<span class="type">uintptr</span>(p), <span class="type">uintptr</span>(old.array), lenmem)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 迁移旧数据</span></span><br><span class="line">memmove(p, old.array, lenmem)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicecopy</span><span class="params">(to, fm slice, width <span class="type">uintptr</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> fm.<span class="built_in">len</span> == <span class="number">0</span> || to.<span class="built_in">len</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := fm.<span class="built_in">len</span></span><br><span class="line"><span class="keyword">if</span> to.<span class="built_in">len</span> &lt; n &#123;</span><br><span class="line">n = to.<span class="built_in">len</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> width == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">pc := funcPC(slicecopy)</span><br><span class="line">racewriterangepc(to.array, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)), callerpc, pc)</span><br><span class="line">racereadrangepc(fm.array, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)), callerpc, pc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanwrite(to.array, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)))</span><br><span class="line">msanread(fm.array, <span class="type">uintptr</span>(n*<span class="type">int</span>(width)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">size := <span class="type">uintptr</span>(n) * width</span><br><span class="line"><span class="keyword">if</span> size == <span class="number">1</span> &#123; <span class="comment">// common case worth about 2x to do here</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> is this still worth it with new memmove impl?</span></span><br><span class="line">        <span class="comment">// 1个字节的特殊处理。。他们也不知道是不是有优化效果</span></span><br><span class="line">*(*<span class="type">byte</span>)(to.array) = *(*<span class="type">byte</span>)(fm.array) <span class="comment">// known to be a byte pointer</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 内存移动</span></span><br><span class="line">memmove(to.array, fm.array, size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string转byte slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicestringcopy</span><span class="params">(to []<span class="type">byte</span>, fm <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(fm) == <span class="number">0</span> || <span class="built_in">len</span>(to) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="built_in">len</span>(fm)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(to) &lt; n &#123;</span><br><span class="line">n = <span class="built_in">len</span>(to)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">pc := funcPC(slicestringcopy)</span><br><span class="line">racewriterangepc(unsafe.Pointer(&amp;to[<span class="number">0</span>]), <span class="type">uintptr</span>(n), callerpc, pc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">msanwrite(unsafe.Pointer(&amp;to[<span class="number">0</span>]), <span class="type">uintptr</span>(n))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//string转成stringStruct后直接内存移动</span></span><br><span class="line">memmove(unsafe.Pointer(&amp;to[<span class="number">0</span>]), stringStructOf(&amp;fm).str, <span class="type">uintptr</span>(n))</span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-string</title>
      <link href="/p/2502706622.html"/>
      <url>/p/2502706622.html</url>
      
        <content type="html"><![CDATA[<p>代码版本:<strong>1.12.7</strong></p><p><code>Go</code>中<code>string</code>并不像<code>C</code>一样只是个单纯的指针指向一片空间，而是在底层封装了一层结构体来存储。字符串构建过程是先跟据字符串构建stringStruct，再转换成string。</p><p><em>string在runtime包中就是stringStruct，对外呈现叫做string。</em></p><p>主要代码在<code>src/runtime/string.go</code></p><span id="more"></span><h1 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The constant is known to the compiler.</span></span><br><span class="line"><span class="comment">// There is no fundamental theory behind this number.</span></span><br><span class="line"><span class="comment">// 这句话的意思是，就是想设32，没有原因:)</span></span><br><span class="line"><span class="keyword">const</span> tmpStringBufSize = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">maxUint = ^<span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line">maxInt  = <span class="type">int</span>(maxUint &gt;&gt; <span class="number">1</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>为啥<code>maxUint</code>和<code>maxInt</code>要这么写而不是写成常量是因为不同平台计算出来的不一样。</p><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> tmpBuf [tmpStringBufSize]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> stringStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">str unsafe.Pointer</span><br><span class="line"><span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Variant with *byte pointer type for DWARF debugging.</span></span><br><span class="line"><span class="keyword">type</span> stringStructDWARF <span class="keyword">struct</span> &#123;</span><br><span class="line">str *<span class="type">byte</span></span><br><span class="line"><span class="built_in">len</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件的一开头就定义了一个<code>tmpBuf</code>这个类型，看名字也知道是一个临时存储用的东西。</p><p>下面的<code>stringStruct</code>才是真正的<code>string</code>定义,在<code>stringStruct</code>中存储了具体数据的指针和数据的长度。而<code>stringStructDWARF</code>这个则是debug的时候用的。</p><p>这么一个结构体,可以发现里面存储的是一个具体数据的指针和数据的长度.<code>string</code>数据结构跟<code>slice</code>有些类似，只不过切片还有一个表示容量的成员，<code>string</code>本质上可以看做一个只读的字节切片.事实上<code>string</code>和<code>slice</code>，准确的说是<code>[]byte</code>经常发生转换。</p><h2 id="底层存储"><a href="#底层存储" class="headerlink" title="底层存储"></a>底层存储</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">s3 := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">fmt.Println(&amp;s1,&amp;s2,&amp;s3)</span><br><span class="line">fmt.Println((*reflect.StringHeader)(unsafe.Pointer(&amp;s1)),</span><br><span class="line">    (*reflect.StringHeader)(unsafe.Pointer(&amp;s2)),</span><br><span class="line">    (*reflect.StringHeader)(unsafe.Pointer(&amp;s3)))</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0xc000010200 0xc000010210 0xc000010220</span></span><br><span class="line"><span class="comment">&amp;&#123;17633267 11&#125; &amp;&#123;17633267 11&#125; &amp;&#123;17633267 11&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看出来，<code>string</code>在底层的<code>data</code>段都是一个地址，不同的字符串变量指向相同的底层数组，这是因为字符串是只读的，为了节省内存，相同字面量的字符串通常对应于同一字符串常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s1 := <span class="string">&quot;aaa&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;bbb&quot;</span> + <span class="string">&quot;ccc&quot;</span></span><br><span class="line">s3 := <span class="string">&quot;aaa&quot;</span> + <span class="string">&quot;bbb&quot;</span></span><br><span class="line">s4 := <span class="string">&quot;ddd&quot;</span></span><br><span class="line">_, _, _,_ = s1, s2, s3,s4</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go tool compile -S -B -N -l main.go</span></span><br><span class="line"><span class="keyword">go</span>.<span class="type">string</span>.<span class="string">&quot;aaa&quot;</span> SRODATA dupok size=<span class="number">3</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span>                                         aaa</span><br><span class="line"><span class="keyword">go</span>.<span class="type">string</span>.<span class="string">&quot;bbbccc&quot;</span> SRODATA dupok size=<span class="number">6</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span> <span class="number">63</span> <span class="number">63</span> <span class="number">63</span>                                bbbccc</span><br><span class="line"><span class="keyword">go</span>.<span class="type">string</span>.<span class="string">&quot;aaabbb&quot;</span> SRODATA dupok size=<span class="number">6</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">61</span> <span class="number">61</span> <span class="number">61</span> <span class="number">62</span> <span class="number">62</span> <span class="number">62</span>                                aaabbb</span><br><span class="line"><span class="keyword">go</span>.<span class="type">string</span>.<span class="string">&quot;ddd&quot;</span> SRODATA dupok size=<span class="number">3</span></span><br><span class="line"><span class="number">0x0000</span> <span class="number">64</span> <span class="number">64</span> <span class="number">64</span>                                         ddd</span><br></pre></td></tr></table></figure><p>可以看到，代码中的”aaa”+”bbb”会被编译器合并为一个”aaabbb”常量字符串。</p><h2 id="string与-byte的无拷贝转换"><a href="#string与-byte的无拷贝转换" class="headerlink" title="string与[]byte的无拷贝转换"></a>string与[]byte的无拷贝转换</h2><p>这里其实得了解到这两者的底层实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reflect.StringHeader&#123;<span class="comment">//string的本质</span></span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">reflect.SliceHeader&#123;<span class="comment">//slice的本质</span></span><br><span class="line">Data <span class="type">uintptr</span></span><br><span class="line">Len  <span class="type">int</span></span><br><span class="line">Cap  <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其实两者的结构是类似的,所以可以直接利用<code>unsafe</code>来进行转换。</p><h3 id="string-to-byte"><a href="#string-to-byte" class="headerlink" title="string to []byte"></a>string to []byte</h3><p>简单的转换方案:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string to []byte</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="type">string</span>)</span></span>[]<span class="type">byte</span>&#123;</span><br><span class="line">bs := *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line"><span class="keyword">return</span> bs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种转换会有一个问题，因为<code>string</code>比<code>slice</code>少了<code>cap</code>字段，所以其实赋值过来的时候<code>cap</code>是丢失的，所以一般更推荐以下这种</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">string2bytes</span><span class="params">(s <span class="type">string</span>)</span></span>[]<span class="type">byte</span>&#123;</span><br><span class="line">str := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))</span><br><span class="line">bs := reflect.SliceHeader&#123;</span><br><span class="line">Data: str.Data,</span><br><span class="line">Len:  str.Len,</span><br><span class="line">Cap:  str.Len,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>需要注意的是，常量<code>string</code>(本身存在的数据区域决定了可不可以修改)转换出来的<code>[]byte</code>是不可修改的，如果修改,会发生致命错误，<code>recover</code>也是捕捉不到的</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">var</span> s0 = <span class="type">string</span>([]<span class="type">byte</span>&#123;<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;p&#x27;</span>&#125;)</span><br><span class="line">bs0 := string2bytes(s0)</span><br><span class="line">bs0[<span class="number">0</span>]=<span class="string">&#x27;z&#x27;</span> <span class="comment">//这里是没有问题的</span></span><br><span class="line">fmt.Println(s0)</span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;qwerqwerqwerwer&quot;</span></span><br><span class="line">bs := string2bytes(s)</span><br><span class="line">bs[<span class="number">0</span>]=<span class="string">&#x27;r&#x27;</span> <span class="comment">//这里会发生错误</span></span><br><span class="line">    fmt.Println(bs)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">unexpected fault address 0x10ce0f7</span></span><br><span class="line"><span class="comment">fatal error: fault</span></span><br><span class="line"><span class="comment">[signal SIGBUS: bus error code=0x2 addr=0x10ce0f7 pc=0x109cf7f]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="byte-to-string"><a href="#byte-to-string" class="headerlink" title="[]byte to string"></a>[]byte to string</h3><p>与<code>string</code>转为<code>[]byte</code>不同，<code>sliceheader</code>中多的<code>cap</code>字段可以直接忽略，<code>[]byte</code>可以直接转为<code>string</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// []byte to string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(bs []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;bs))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以写的规范点</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bytes2string</span><span class="params">(bs []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">bsh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;bs))</span><br><span class="line">s := reflect.StringHeader&#123;</span><br><span class="line">Data: bsh.Data,</span><br><span class="line">Len:  bsh.Len,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;s))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于<code>[]byte</code>转出来的<code>string</code>,在<code>[]byte</code>本身发生变化是，<code>string</code>也是会同步发生变化的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">bs  := []<span class="type">byte</span>&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">s := bytes2string(bs)</span><br><span class="line">fmt.Println(s)<span class="comment">//abcde</span></span><br><span class="line">bs[<span class="number">0</span>]=<span class="string">&#x27;z&#x27;</span> <span class="comment">// 这里如果[]byte修改了，string也会同步修改</span></span><br><span class="line">fmt.Println(s)<span class="comment">//zbcde</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>goos: darwin goarch: amd64</p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">操作耗时</th></tr></thead><tbody><tr><td style="text-align:left">BenchmarkString2Bytes_normal-4</td><td style="text-align:left">8.80 ns/op</td></tr><tr><td style="text-align:left">BenchmarkString2Bytes-4</td><td style="text-align:left">0.400 ns/op</td></tr><tr><td style="text-align:left">BenchmarkBytes2String_normal-4</td><td style="text-align:left">5.57 ns/op</td></tr><tr><td style="text-align:left">BenchmarkBytes2String-4</td><td style="text-align:left">0.354 ns/op</td></tr></tbody></table></div><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h2 id="类型转换相关的函数"><a href="#类型转换相关的函数" class="headerlink" title="类型转换相关的函数"></a>类型转换相关的函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//string转成stringStruct，就是指针强转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringStructOf</span><span class="params">(sp *<span class="type">string</span>)</span></span> *stringStruct &#123;</span><br><span class="line"><span class="keyword">return</span> (*stringStruct)(unsafe.Pointer(sp))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// slicebytetostringtmp returns a &quot;string&quot; referring to the actual []byte bytes.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Callers need to ensure that the returned string will not be used after</span></span><br><span class="line"><span class="comment">// the calling goroutine modifies the original slice or synchronizes with</span></span><br><span class="line"><span class="comment">// another goroutine.</span></span><br><span class="line"><span class="comment">// 调用者得确保不会在另外一个goroutine里修改源切片</span></span><br><span class="line"><span class="comment">// The function is only called when instrumenting</span></span><br><span class="line"><span class="comment">// and otherwise intrinsified by the compiler.</span></span><br><span class="line"><span class="comment">// 这个函数仅在检测时调用，或者是编译器优化的时候用。</span></span><br><span class="line"><span class="comment">// Some internal compiler optimizations use this function.</span></span><br><span class="line"><span class="comment">// - Used for m[T1&#123;... Tn&#123;..., string(k), ...&#125; ...&#125;] and m[string(k)]</span></span><br><span class="line"><span class="comment">//   where k is []byte, T1 to Tn is a nesting of struct and array literals.</span></span><br><span class="line"><span class="comment">// - Used for &quot;&lt;&quot;+string(b)+&quot;&gt;&quot; concatenation where b is []byte.</span></span><br><span class="line"><span class="comment">// - Used for string(b)==&quot;foo&quot; comparison where b is []byte.</span></span><br><span class="line"><span class="comment">//byte切片转string，也是指针强转，指向的还是原来的地址，所以会相互影响</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostringtmp</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//竞争检测，忽略</span></span><br><span class="line">racereadrangepc(unsafe.Pointer(&amp;b[<span class="number">0</span>]),</span><br><span class="line"><span class="type">uintptr</span>(<span class="built_in">len</span>(b)),</span><br><span class="line">getcallerpc(),</span><br><span class="line">funcPC(slicebytetostringtmp))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &amp;&amp; <span class="built_in">len</span>(b) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//Memory Sanitizer 用于检测危险指针等内存问题，忽略</span></span><br><span class="line">msanread(unsafe.Pointer(&amp;b[<span class="number">0</span>]), <span class="type">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string转byte切片，这个就不是指针强转了，是内存拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line"><span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">        <span class="comment">// 判断一下空间够不够</span></span><br><span class="line">*buf = tmpBuf&#123;&#125;</span><br><span class="line">b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不够就去申请</span></span><br><span class="line">b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 然后拷贝</span></span><br><span class="line"><span class="built_in">copy</span>(b, s)</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string转rune切片，一般情况是多字节编码的时候用（我猜的）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicerune</span><span class="params">(buf *[tmpStringBufSize]<span class="type">rune</span>, s <span class="type">string</span>)</span></span> []<span class="type">rune</span> &#123;</span><br><span class="line"><span class="comment">// two passes.</span></span><br><span class="line">    <span class="comment">// 双扫描算法。。也就是先for一次计数，然后判断空间，然后再for一次做正事</span></span><br><span class="line"><span class="comment">// unlike slicerunetostring, no race because strings are immutable.</span></span><br><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">range</span> s &#123;</span><br><span class="line">        <span class="comment">//注意这里是用range来遍历s来计算长度而不是用len,因为len算的是字节数</span></span><br><span class="line">        <span class="comment">//对于多字节编码，比如中文来说，字数！=字节数</span></span><br><span class="line">n++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a []<span class="type">rune</span></span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; n &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">*buf = [tmpStringBufSize]<span class="type">rune</span>&#123;&#125;</span><br><span class="line">a = buf[:n]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">a = rawruneslice(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> s &#123;</span><br><span class="line">a[n] = r</span><br><span class="line">n++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rune切片转string，一般是多字节编码用（还是我猜的）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicerunetostring</span><span class="params">(buf *tmpBuf, a []<span class="type">rune</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &amp;&amp; <span class="built_in">len</span>(a) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//竞争检测，忽略</span></span><br><span class="line">racereadrangepc(unsafe.Pointer(&amp;a[<span class="number">0</span>]),</span><br><span class="line"><span class="type">uintptr</span>(<span class="built_in">len</span>(a))*unsafe.Sizeof(a[<span class="number">0</span>]),</span><br><span class="line">getcallerpc(),</span><br><span class="line">funcPC(slicerunetostring))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> msanenabled &amp;&amp; <span class="built_in">len</span>(a) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">//Memory Sanitizer 用于检测危险指针等内存问题，忽略</span></span><br><span class="line">msanread(unsafe.Pointer(&amp;a[<span class="number">0</span>]), <span class="type">uintptr</span>(<span class="built_in">len</span>(a))*unsafe.Sizeof(a[<span class="number">0</span>]))</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//这个变量没用，单纯为了调用encoderune这个函数，因为这个函数会把r转到第一个参数里面，下面再详细看这个函数</span></span><br><span class="line"><span class="keyword">var</span> dum [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">size1 := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="comment">// 算大小</span></span><br><span class="line">size1 += encoderune(dum[:], r)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">s, b := rawstringtmp(buf, size1+<span class="number">3</span>)</span><br><span class="line">size2 := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, r := <span class="keyword">range</span> a &#123;</span><br><span class="line"><span class="comment">// check for race</span></span><br><span class="line"><span class="keyword">if</span> size2 &gt;= size1 &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//干正事</span></span><br><span class="line">size2 += encoderune(b[size2:], r)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[:size2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int转string，注意是 int ,不是int64</span></span><br><span class="line"><span class="comment">// 虽然我也不知道为啥int转string非要传一个int64，只能理解是编译器会干点什么</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intstring</span><span class="params">(buf *[4]<span class="type">byte</span>, v <span class="type">int64</span>)</span></span> (s <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="comment">//runeSelf是一个常量 0x80,也就是127</span></span><br><span class="line">    <span class="comment">//staticbytes是一个常量数组，里面是0-127的的字节码</span></span><br><span class="line"><span class="keyword">if</span> v &gt;= <span class="number">0</span> &amp;&amp; v &lt; runeSelf &#123;</span><br><span class="line">        <span class="comment">// 所以这个其实是直接扫表加速处理</span></span><br><span class="line">stringStructOf(&amp;s).str = unsafe.Pointer(&amp;staticbytes[v])</span><br><span class="line">stringStructOf(&amp;s).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//有空间，直接用</span></span><br><span class="line">b = buf[:]</span><br><span class="line">s = slicebytetostringtmp(b)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//没空间，申请</span></span><br><span class="line">s, b = rawstring(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//rune其实就是int32，所以把int64转int32再转int64看是不是自己来判断是否是一个int大小的</span></span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="type">rune</span>(v)) != v &#123;</span><br><span class="line">v = runeError</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//再算一遍大小，并且填到b里面去</span></span><br><span class="line">n := encoderune(b, <span class="type">rune</span>(v))</span><br><span class="line"><span class="keyword">return</span> s[:n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数不是string.go里的，是在src/runtime/utf8.go:104</span></span><br><span class="line"><span class="comment">// encoderune writes into p (which must be large enough) the UTF-8 encoding of the rune.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written.</span></span><br><span class="line"><span class="comment">// 注释的意思是，会把rune进行utf8编码写到p（必须保证空间足够大）里，</span></span><br><span class="line"><span class="comment">// 返回值是写入的字节数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encoderune</span><span class="params">(p []<span class="type">byte</span>, r <span class="type">rune</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="comment">// Negative values are erroneous. Making it unsigned addresses the problem.</span></span><br><span class="line"><span class="keyword">switch</span> i := <span class="type">uint32</span>(r); &#123;</span><br><span class="line"><span class="keyword">case</span> i &lt;= rune1Max: <span class="comment">//1&lt;&lt;7 -1 127 ，一个字节的情况</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="type">byte</span>(r)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">case</span> i &lt;= rune2Max: <span class="comment">//1&lt;&lt;11 -1 2047,两个字节</span></span><br><span class="line">_ = p[<span class="number">1</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">p[<span class="number">0</span>] = t2 | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)</span><br><span class="line">p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">case</span> i &gt; maxRune, surrogateMin &lt;= i &amp;&amp; i &lt;= surrogateMax: <span class="comment">//看是不是不再unicode处理范围</span></span><br><span class="line">  <span class="comment">// maxRune &#x27;\U0010FFFF&#x27; // Maximum valid Unicode code point.</span></span><br><span class="line">        <span class="comment">// Code points in the surrogate range are not valid for UTF-8.</span></span><br><span class="line">        <span class="comment">//const (</span></span><br><span class="line">        <span class="comment">//surrogateMin = 0xD800</span></span><br><span class="line">        <span class="comment">//surrogateMax = 0xDFFF</span></span><br><span class="line"><span class="comment">//)</span></span><br><span class="line">r = runeError</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> i &lt;= rune3Max:<span class="comment">// 1&lt;&lt;16 -1 65535,三个字节</span></span><br><span class="line">_ = p[<span class="number">2</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">p[<span class="number">0</span>] = t3 | <span class="type">byte</span>(r&gt;&gt;<span class="number">12</span>)</span><br><span class="line">p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)&amp;maskx</span><br><span class="line">p[<span class="number">2</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">default</span>:<span class="comment">// 自然就是四个字节啦</span></span><br><span class="line">_ = p[<span class="number">3</span>] <span class="comment">// eliminate bounds checks</span></span><br><span class="line">p[<span class="number">0</span>] = t4 | <span class="type">byte</span>(r&gt;&gt;<span class="number">18</span>)</span><br><span class="line">p[<span class="number">1</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">12</span>)&amp;maskx</span><br><span class="line">p[<span class="number">2</span>] = tx | <span class="type">byte</span>(r&gt;&gt;<span class="number">6</span>)&amp;maskx</span><br><span class="line">p[<span class="number">3</span>] = tx | <span class="type">byte</span>(r)&amp;maskx</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="内存申请相关的函数"><a href="#内存申请相关的函数" class="headerlink" title="内存申请相关的函数"></a>内存申请相关的函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rawstring allocates storage for a new string. The returned</span></span><br><span class="line"><span class="comment">// string and byte slice both refer to the same storage.</span></span><br><span class="line"><span class="comment">// The storage is not zeroed. Callers should use</span></span><br><span class="line"><span class="comment">// b to set the string contents and then drop b.</span></span><br><span class="line"><span class="comment">// 申请size大小的一片内存（不为空，就是纯内存空间）</span></span><br><span class="line"><span class="comment">// 返回的s和b其实指向的一个地方，不过类型不一样</span></span><br><span class="line"><span class="comment">// 调用者应该用b来进行赋值，完成后就释放b</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawstring</span><span class="params">(size <span class="type">int</span>)</span></span> (s <span class="type">string</span>, b []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="comment">// 这个函数是申请空间,第一个参数是大小，第二个参数是类型，第三个参数是是否初始化为0</span></span><br><span class="line">    <span class="comment">// 小对象直接在goroutine的栈上申请</span></span><br><span class="line">    <span class="comment">// 大对象(&gt;32kb)会直接在堆上申请</span></span><br><span class="line">p := mallocgc(<span class="type">uintptr</span>(size), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">stringStructOf(&amp;s).str = p</span><br><span class="line">stringStructOf(&amp;s).<span class="built_in">len</span> = size</span><br><span class="line"></span><br><span class="line">*(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, size&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.</span></span><br><span class="line"><span class="comment">// 申请size大的byte切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawbyteslice</span><span class="params">(size <span class="type">int</span>)</span></span> (b []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="comment">//内存大小对齐处理，对go来说内存片是分成不同大小来处理的</span></span><br><span class="line"><span class="built_in">cap</span> := roundupsize(<span class="type">uintptr</span>(size))</span><br><span class="line">p := mallocgc(<span class="built_in">cap</span>, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cap</span> != <span class="type">uintptr</span>(size) &#123;</span><br><span class="line">        <span class="comment">//有对齐的话清空一下这片内存</span></span><br><span class="line">memclrNoHeapPointers(add(p, <span class="type">uintptr</span>(size)), <span class="built_in">cap</span>-<span class="type">uintptr</span>(size))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, <span class="type">int</span>(<span class="built_in">cap</span>)&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rawruneslice allocates a new rune slice. The rune slice is not zeroed.</span></span><br><span class="line"><span class="comment">// 申请size大小的rune切片,rune是4字节的，所以函数里出现了很多4</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawruneslice</span><span class="params">(size <span class="type">int</span>)</span></span> (b []<span class="type">rune</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(size) &gt; maxAlloc/<span class="number">4</span> &#123;</span><br><span class="line">        <span class="comment">//看看内存够不够</span></span><br><span class="line">throw(<span class="string">&quot;out of memory&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//下面和上面一样的处理方式</span></span><br><span class="line">mem := roundupsize(<span class="type">uintptr</span>(size) * <span class="number">4</span>)</span><br><span class="line">p := mallocgc(mem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">if</span> mem != <span class="type">uintptr</span>(size)*<span class="number">4</span> &#123;</span><br><span class="line">memclrNoHeapPointers(add(p, <span class="type">uintptr</span>(size)*<span class="number">4</span>), mem-<span class="type">uintptr</span>(size)*<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, <span class="type">int</span>(mem / <span class="number">4</span>)&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstrings</span><span class="params">(buf *tmpBuf, a []<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    <span class="comment">//首先声明一些用的上的变量</span></span><br><span class="line">idx := <span class="number">0</span></span><br><span class="line">l := <span class="number">0</span></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">n := <span class="built_in">len</span>(x)</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前的这个string长度为0直接跳过</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> l+n &lt; l &#123;</span><br><span class="line">            <span class="comment">//判断是不是超过大小，为什么这么写呢，举个例子</span></span><br><span class="line">            <span class="comment">//比如 l是一个int64，那么它的最大值就是2^63-1</span></span><br><span class="line">            <span class="comment">//如果我的l现在是2^63,然后n现在是2</span></span><br><span class="line">         <span class="comment">//那么我的l就会越界变成最小值</span></span><br><span class="line">            <span class="comment">//所以判断是不是加完小于自己就行了</span></span><br><span class="line">throw(<span class="string">&quot;string concatenation too long&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">l += n</span><br><span class="line">count++</span><br><span class="line">idx = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If there is just one string and either it is not on the stack</span></span><br><span class="line"><span class="comment">// or our result does not escape the calling frame (buf != nil),</span></span><br><span class="line"><span class="comment">// then we can return that string directly.</span></span><br><span class="line">    <span class="comment">// 想明白这个位置的话，首先得理解go里面对变量的内存处理</span></span><br><span class="line">    <span class="comment">// 我们都知道go里面的函数是可以返回一个地址的，这点跟c不一样，</span></span><br><span class="line">    <span class="comment">// c里面如果返回一个局部变量的地址，这个地址在函数执行完之后会被释放掉</span></span><br><span class="line">    <span class="comment">// 但是go里面返回的地址则不会，是别的地方可用的，go是怎么实现的呢？</span></span><br><span class="line">    <span class="comment">// 主要是go会对代码进行逃逸分析，如果说这个变量的适用范围不仅仅在自己的调用栈</span></span><br><span class="line">    <span class="comment">// 那么会直接把它分配到堆上而不是自己的栈上。</span></span><br><span class="line"><span class="keyword">if</span> count == <span class="number">1</span> &amp;&amp; (buf != <span class="literal">nil</span> || !stringDataOnStack(a[idx])) &#123;</span><br><span class="line">        <span class="comment">//stringDataOnStack见下方工具函数</span></span><br><span class="line"><span class="keyword">return</span> a[idx]</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//判断内存空间够不够，不够就申请</span></span><br><span class="line">    <span class="comment">//这里返回的s是实际的string，b其实是一个游标指针，方便后面拷贝</span></span><br><span class="line">    <span class="comment">//同见下方工具函数</span></span><br><span class="line">s, b := rawstringtmp(buf, l)</span><br><span class="line"><span class="keyword">for</span> _, x := <span class="keyword">range</span> a &#123;</span><br><span class="line">        <span class="comment">//开始实际的拷贝，每次都是把x拷贝到b指向到空间，然后把b往后移动len(x)长度继续考呗</span></span><br><span class="line"><span class="built_in">copy</span>(b, x)</span><br><span class="line">b = b[<span class="built_in">len</span>(x):]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的那2，3，4，5 就不说了，是编译器用来做加速优化的，因为其实大部分字符串相加不会超过5个。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring2</span><span class="params">(buf *tmpBuf, a [2]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring3</span><span class="params">(buf *tmpBuf, a [3]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring4</span><span class="params">(buf *tmpBuf, a [4]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">concatstring5</span><span class="params">(buf *tmpBuf, a [5]<span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> concatstrings(buf, a[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s中找t开始位置，正常朴素算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(t) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s[i] == t[<span class="number">0</span>] &amp;&amp; hasPrefix(s[i:], t) &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断t在不在s中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">contains</span><span class="params">(s, t <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> index(s, t) &gt;= <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断s是否以prefix开头</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasPrefix</span><span class="params">(s, prefix <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s) &gt;= <span class="built_in">len</span>(prefix) &amp;&amp; s[:<span class="built_in">len</span>(prefix)] == prefix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// atoi parses an int from a string s.</span></span><br><span class="line"><span class="comment">// The bool result reports whether s is a number</span></span><br><span class="line"><span class="comment">// representable by a value of type int.</span></span><br><span class="line"><span class="comment">// atoi，也是朴素算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> s == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">neg := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> &#123;</span><br><span class="line">neg = <span class="literal">true</span></span><br><span class="line">s = s[<span class="number">1</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">un := <span class="type">uint</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">c := s[i]</span><br><span class="line"><span class="keyword">if</span> c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> un &gt; maxUint/<span class="number">10</span> &#123;</span><br><span class="line"><span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">un *= <span class="number">10</span></span><br><span class="line">un1 := un + <span class="type">uint</span>(c) - <span class="string">&#x27;0&#x27;</span></span><br><span class="line"><span class="keyword">if</span> un1 &lt; un &#123;</span><br><span class="line"><span class="comment">// overflow</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">un = un1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !neg &amp;&amp; un &gt; <span class="type">uint</span>(maxInt) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> neg &amp;&amp; un &gt; <span class="type">uint</span>(maxInt)+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := <span class="type">int</span>(un)</span><br><span class="line"><span class="keyword">if</span> neg &#123;</span><br><span class="line">n = -n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// atoi32 is like atoi but for integers</span></span><br><span class="line"><span class="comment">// that fit into an int32.</span></span><br><span class="line"><span class="comment">// 就是调一下上方的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atoi32</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">int32</span>, <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> n, ok := atoi(s); n == <span class="type">int</span>(<span class="type">int32</span>(n)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">int32</span>(n), ok</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stringDataOnStack reports whether the string&#x27;s data is</span></span><br><span class="line"><span class="comment">// stored on the current goroutine&#x27;s stack.</span></span><br><span class="line"><span class="comment">// 判断string是否在当前栈空间内</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringDataOnStack</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">ptr := <span class="type">uintptr</span>(stringStructOf(&amp;s).str)</span><br><span class="line">stk := getg().stack</span><br><span class="line">    <span class="comment">//对于go来说，每个goroutine的栈空间记录都是记录栈顶和栈底的地址</span></span><br><span class="line">    <span class="comment">//所以只用判断这个指针是不是在这两之间就可以判断在不在当前栈空间上</span></span><br><span class="line"><span class="keyword">return</span> stk.lo &lt;= ptr &amp;&amp; ptr &lt; stk.hi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了一下，如果buf空间够就直接用buf不够才申请</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawstringtmp</span><span class="params">(buf *tmpBuf, l <span class="type">int</span>)</span></span> (s <span class="type">string</span>, b []<span class="type">byte</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; l &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">b = buf[:l]</span><br><span class="line">        <span class="comment">//把byte的切片转成string</span></span><br><span class="line">s = slicebytetostringtmp(b)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//申请空间</span></span><br><span class="line">s, b = rawstring(l)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="comment">//无拷贝的byte转string，就是指针类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gostringnocopy</span><span class="params">(str *<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">ss := stringStruct&#123;str: unsafe.Pointer(str), <span class="built_in">len</span>: findnull(str)&#125;</span><br><span class="line">s := *(*<span class="type">string</span>)(unsafe.Pointer(&amp;ss))</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>所以从<code>string.go</code>里来看，里面其实就两种东西</p><ol><li>two passes 先计数，然后判断内存，然后做操作</li><li>指针类型转换</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-interface</title>
      <link href="/p/1751243825.html"/>
      <url>/p/1751243825.html</url>
      
        <content type="html"><![CDATA[<p>代码版本:<strong>1.12.7</strong></p><p><code>interface</code>是<code>Go</code>语言里面的接口,可以理解为一种方法声明的集合约定，整个<code>ducktyping</code>就是通过这个完成的。</p><ol><li>任何类型实现了在<code>interface</code> 接口中声明的全部方法，则表明该类型实现了该接口，可以实现多个<code>interface</code></li><li><code>interface</code>可以作为一种数据类型，实现了该接口的任何对象都可以给对应的接口类型变量赋值。</li><li><code>interface</code>中的方法不能重载,比如<code>test()</code>和<code>test(a int)</code>不能同时存在</li></ol><span id="more"></span><p>interface 常见有两种用法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 一个空的interface变量，go的“弱类型” 底层其实是eface</span></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123;  <span class="comment">// 一个存在函数的interface类型，go的接口 底层其实是iface</span></span><br><span class="line">    Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>go的两种用法映射到底层是两种不同的实现，eface和iface 。 eface是没有函数的interface（go的“弱类型”），iface内部存在函数（go的接口）。</p><p>弱类型实现基本上都是 desc + data </p><h2 id="eface结构"><a href="#eface结构" class="headerlink" title="eface结构"></a>eface结构</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type           <span class="comment">// desc</span></span><br><span class="line">    data  unsafe.Pointer   <span class="comment">// data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量整体结构"><a href="#变量整体结构" class="headerlink" title="变量整体结构"></a>变量整体结构</h2><p>变量的整体结构如下：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/1751243825/var_struct.png" class="" title="var_struct"><p>其中_type 和 uncommonType为通用数据结构， selfType对于不同类型来说有不同的实现。以struct举例说明：</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/1751243825/struct.png" class="" title="struct"><p>对于struct的_type指向的是structType结构的_type字段，对于一个struct的描述，增加了后面的内容，由structType和uncommonType两个结构组成。 其中uncommonType是与函数相关，在不存在函数的情况下，没有该字段， 即eface没有uncommonType字段。</p><p>源码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">    _type *_type           <span class="comment">// desc</span></span><br><span class="line">    data  unsafe.Pointer   <span class="comment">// data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ     _type       </span><br><span class="line">    pkgPath name</span><br><span class="line">    fields  []structfield</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> uncommontype <span class="keyword">struct</span> &#123;</span><br><span class="line">    pkgpath nameOff</span><br><span class="line">    mcount  <span class="type">uint16</span> <span class="comment">// number of methods</span></span><br><span class="line">    _       <span class="type">uint16</span> <span class="comment">// unused</span></span><br><span class="line">    moff    <span class="type">uint32</span> <span class="comment">// offset from this uncommontype to [mcount]method</span></span><br><span class="line">    _       <span class="type">uint32</span> <span class="comment">// unused</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思考：</p><ol><li><p>golang定义一个struct类型，底层是否头部自动插入_type类型？</p><p>golang的变量使用和定义是分离，即使用还是一样的；定义的部分则保存在二进制文件中。</p></li><li><p>基础数据类型(int32，float)是否有_type定义？</p><p>是有的，反编译后可以看到</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/1751243825/base_type.png" class="" title="base_type"></li><li><p>对于一个struct类型变量转interface 会发生什么？</p><p>在编译阶段完成：</p><ol><li>struct type的定义在二进制文件</li><li>生成对应的类型赋值的二进制文件<ol><li>从.rodata文件中读取该struct的_type信息。</li><li>构建该struct的eface结构，与该变量关联。</li></ol></li></ol></li><li><p>golang 的底层selfType到底有多少种呢？</p><p>一共有以下这几个：interfacetype、maptype、arraytype、chantype、slicetype、functype、ptrtype、structtype</p></li></ol><h2 id="type源码"><a href="#type源码" class="headerlink" title="_type源码"></a>_type源码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    tflagUncommon tflag = <span class="number">1</span> &lt;&lt; <span class="number">0</span>  <span class="comment">// 标记是否有uncommon内容（即：记录pkgpath和方法的内容），目前看：只有匿名结构体和reflect动态创建的struct并且没有methods时，该值为0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    type AA struct &#123;&#125;</span></span><br><span class="line"><span class="comment">    var a = AA&#123;&#125;</span></span><br><span class="line"><span class="comment">        b := &amp;a</span></span><br><span class="line"><span class="comment">    fmt.Println(reflect.TypeOf(a),reflect.TypeOf(b))</span></span><br><span class="line"><span class="comment">    a的name为：&quot;main.AA&quot;</span></span><br><span class="line"><span class="comment">    b的name为：&quot;*main.AA&quot;</span></span><br><span class="line"><span class="comment">     </span></span><br><span class="line"><span class="comment">    在底层golang为了做优化，让a和b的name都指向了&quot;*main.AA&quot;。然后通过tflagExtraStar区分。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    tflagExtraStar tflag = <span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="comment">//标记name是否是多含*，如果为true，实际的名称是：name[1:]。</span></span><br><span class="line">    tflagNamed tflag = <span class="number">1</span> &lt;&lt; <span class="number">2</span>     <span class="comment">// 标记是否有类型名称（必须通过type定义的类型才有类型名称，没有定义名字的类型，比如函数，匿名结构体，类型的指针）。</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> rtype <span class="keyword">struct</span> &#123;        <span class="comment">// _type类型</span></span><br><span class="line">    size <span class="type">uintptr</span> <span class="comment">// 类型占用字节大小</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        type AA struct &#123;</span></span><br><span class="line"><span class="comment">            a *int</span></span><br><span class="line"><span class="comment">            b int</span></span><br><span class="line"><span class="comment">            c *int</span></span><br><span class="line"><span class="comment">            d *int</span></span><br><span class="line"><span class="comment">            e int</span></span><br><span class="line"><span class="comment">            f int</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        size = 48</span></span><br><span class="line"><span class="comment">        ptrdata = 32</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ptrdata <span class="type">uintptr</span> <span class="comment">// 类型前ptrdata字节包含指针</span></span><br><span class="line">    hash    <span class="type">uint32</span>  <span class="comment">// 类型的哈希（其实就是类型名称（str）的哈希）</span></span><br><span class="line">    tflag   tflag   <span class="comment">// 看上面tflagUncommon，tflagExtraStar，tflagNamed注释</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        align和fieldAlign含义分别为：</span></span><br><span class="line"><span class="comment">            align：申请内存时结构体内部类型内存对齐大小</span></span><br><span class="line"><span class="comment">            fieldAlign：作为其他结构体时结构体内部变量内存对齐大小</span></span><br><span class="line"><span class="comment">        以上为翻译注释以及结合代码前后提交历史，从现在源码来看这两个值完全一样，没有任何区别</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    align      <span class="type">uint8</span>    </span><br><span class="line">    fieldAlign <span class="type">uint8</span>   </span><br><span class="line">    kind       <span class="type">uint8</span>    <span class="comment">// 基础类型的枚举值</span></span><br><span class="line">    alg        *typeAlg <span class="comment">// 见下方typeAlg</span></span><br><span class="line">    gcdata     *<span class="type">byte</span>    <span class="comment">// gc相关：标记结构体类型中哪些字节是指针类型（mask数组），与ptrdata配合使用。</span></span><br><span class="line">    str        nameOff  <span class="comment">// 类型名称</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        例子：</span></span><br><span class="line"><span class="comment">        struct AA &#123;&#125;  // AA的rtype里面的ptrToThis 这里ptrToThis其实是*AA（*AA也是一种类型）的偏移</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ptrToThis typeOff <span class="comment">// *type类型的定义偏移。一般的代码中（除reflect外）定义的类型都会在编译时，生成两种type（一个是type类型，一个是*type类型），并存在二进制文件rodata块中。运行时会直接使用。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> typeAlg <span class="keyword">struct</span> &#123;</span><br><span class="line">    hash <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, <span class="type">uintptr</span>)</span></span> <span class="type">uintptr</span> <span class="comment">// 类型对应的哈希函数</span></span><br><span class="line">    equal <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="type">bool</span> <span class="comment">// 类型对应的比较函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="iface"><a href="#iface" class="headerlink" title="iface"></a>iface</h2><p>go语言中用来描述接口的底层结构。<br>常见使用场景：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IGreeting <span class="keyword">interface</span> &#123;</span><br><span class="line">    sayHello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Go <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g Go)</span></span> sayHello() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hi, I am GO!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PHP <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p PHP)</span></span> sayHello() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Hi, I am PHP!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> c, d IGreeting = Go&#123;&#125;, PHP&#123;&#125;</span><br><span class="line">    c.sayHello()</span><br><span class="line">    d.sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/1751243825/iface.png" class="" title="iface"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">    tab  *itab                  <span class="comment">// 接口实例的类型信息</span></span><br><span class="line">    data unsafe.Pointer         <span class="comment">// 接口实例数据的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype        <span class="comment">// 接口类型信息</span></span><br><span class="line">    _type *_type                <span class="comment">// struct类型信息</span></span><br><span class="line">    hash  <span class="type">uint32</span>                <span class="comment">// 哈希函数</span></span><br><span class="line">    _     [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">    fun   [<span class="number">1</span>]<span class="type">uintptr</span>            <span class="comment">// 标记位。如果为0表示未实现接口的所有方法。 不为0 表示函数方法数组的首指针。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">    typ     _type               <span class="comment">// 接口类型描述 _type</span></span><br><span class="line">    pkgpath name                <span class="comment">// 接口路径</span></span><br><span class="line">    mhdr    []imethod           <span class="comment">// 接口方法数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="go如何判断类型实现了该接口"><a href="#go如何判断类型实现了该接口" class="headerlink" title="go如何判断类型实现了该接口"></a>go如何判断类型实现了该接口</h3><p>遍历接口的方法，判断该类型是否实现了该方法。如果全部都是实现了，即继承了该接口，否则就是没有继承该接口。</p><p>源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 填充m.fun数组，如果类型（拿struct举例）你未实现接口，则将m.fun[0]置为0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *itab)</span></span> init() <span class="type">string</span> &#123;</span><br><span class="line">    inter := m.inter         <span class="comment">// 接口描述  </span></span><br><span class="line">    typ := m._type           <span class="comment">// struct描述</span></span><br><span class="line">    x := typ.uncommon()      <span class="comment">// struct的uncommon字段，目的是取struct方法数量以及方法指针</span></span><br><span class="line"></span><br><span class="line">    ni := <span class="built_in">len</span>(inter.mhdr)    <span class="comment">// 接口方法数量</span></span><br><span class="line">    nt := <span class="type">int</span>(x.mcount)      <span class="comment">// struct方法数量</span></span><br><span class="line">    xmhdr := (*[<span class="number">1</span> &lt;&lt; <span class="number">16</span>]method)(add(unsafe.Pointer(x), <span class="type">uintptr</span>(x.moff)))[:nt:nt] <span class="comment">// struct方法数组</span></span><br><span class="line">    j := <span class="number">0</span></span><br><span class="line">imethods:</span><br><span class="line">    <span class="comment">// 这里看似双重遍历，由于方法数组都是有序的，所以其实时间复杂度为ni+nt, 而不是ni*nt</span></span><br><span class="line">    <span class="keyword">for</span> k := <span class="number">0</span>; k &lt; ni; k++ &#123;      <span class="comment">// 遍历接口方法。</span></span><br><span class="line">        i := &amp;inter.mhdr[k]        <span class="comment">// 接口中的一个方法i </span></span><br><span class="line">        itype := inter.typ.typeOff(i.ityp)  <span class="comment">// i方法描述</span></span><br><span class="line">        name := inter.typ.nameOff(i.name)   <span class="comment">// 方法的name字段</span></span><br><span class="line">        iname := name.name()                <span class="comment">// name转化为string</span></span><br><span class="line">        ipkg := name.pkgPath()              <span class="comment">// 路径</span></span><br><span class="line">        <span class="keyword">if</span> ipkg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            ipkg = inter.pkgpath.name()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ; j &lt; nt; j++ &#123;                 <span class="comment">// 遍历struct的方法</span></span><br><span class="line">            t := &amp;xmhdr[j]</span><br><span class="line">            tname := typ.nameOff(t.name)</span><br><span class="line">            <span class="keyword">if</span> typ.typeOff(t.mtyp) == itype &amp;&amp; tname.name() == iname &#123;  <span class="comment">//判等</span></span><br><span class="line">                pkgPath := tname.pkgPath()</span><br><span class="line">                <span class="keyword">if</span> pkgPath == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                    pkgPath = typ.nameOff(x.pkgpath).name()</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> tname.isExported() || pkgPath == ipkg &#123;</span><br><span class="line">                    <span class="keyword">if</span> m != <span class="literal">nil</span> &#123;</span><br><span class="line">                        ifn := typ.textOff(t.ifn)</span><br><span class="line">                        *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[<span class="number">0</span>]), <span class="type">uintptr</span>(k)*sys.PtrSize)) = ifn</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span> imethods               <span class="comment">// 存在i方法就continue到外层for</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        m.fun[<span class="number">0</span>] = <span class="number">0</span>            <span class="comment">// 没有找到i方法， 将m.fun[0] 置为0</span></span><br><span class="line">        <span class="keyword">return</span> iname</span><br><span class="line">    &#125;</span><br><span class="line">    m.hash = typ.hash</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的全局存储表"><a href="#接口的全局存储表" class="headerlink" title="接口的全局存储表"></a>接口的全局存储表</h3><p>程序启动的时候，会加载所有的接口类型，这些内容会保存在一个全局的哈希表中。</p><p>全局哈希表结构：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itabTableType <span class="keyword">struct</span> &#123;</span><br><span class="line">    size    <span class="type">uintptr</span>             <span class="comment">// 全局哈希表的表大小</span></span><br><span class="line">    count   <span class="type">uintptr</span>             <span class="comment">// 填充的大小</span></span><br><span class="line">    entries [itabInitSize]*itab <span class="comment">// 数组（哈希表）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>什么时候执行存储逻辑？<br>在程序启动时会调用schedinit函数。在schedinit函数内执行一系列初始化逻辑，其中就有itabsinit函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabsinit</span><span class="params">()</span></span> &#123;                        <span class="comment">// 该方法调用是在schedinit中，即程序启动时</span></span><br><span class="line">    lock(&amp;itabLock)</span><br><span class="line">    <span class="keyword">for</span> _, md := <span class="keyword">range</span> activeModules() &#123;  <span class="comment">// 遍历所有模块，将所有模块下的接口类型添加在全局哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> _, i := <span class="keyword">range</span> md.itablinks &#123;  <span class="comment">// 遍历该模块下的所有接口类型</span></span><br><span class="line">            itabAdd(i)                    <span class="comment">// 添加到全局哈希表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;itabLock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全局哈希表的添加操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabAdd</span><span class="params">(m *itab)</span></span> &#123;         <span class="comment">// 向全局的哈希表中添加接口， </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 省略一部分代码</span></span><br><span class="line"></span><br><span class="line">    t := itabTable              <span class="comment">// 全局的itabTable哈希表</span></span><br><span class="line">    <span class="keyword">if</span> t.count &gt;= <span class="number">3</span>*(t.size/<span class="number">4</span>) &#123; <span class="comment">// 75% load factor 容量超过3/4，扩容</span></span><br><span class="line">        t2 := (*itabTableType)(mallocgc((<span class="number">2</span>+<span class="number">2</span>*t.size)*sys.PtrSize, <span class="literal">nil</span>, <span class="literal">true</span>)) </span><br><span class="line">        t2.size = t.size * <span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        iterate_itabs(t2.add)  <span class="comment">// rehash迁移</span></span><br><span class="line">        <span class="keyword">if</span> t2.count != t.count &#123;</span><br><span class="line">            throw(<span class="string">&quot;mismatched count during itab table copy&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        atomicstorep(unsafe.Pointer(&amp;itabTable), unsafe.Pointer(t2)) <span class="comment">// itabTable指向扩容后哈希表</span></span><br><span class="line">        t = itabTable</span><br><span class="line">    &#125;</span><br><span class="line">    t.add(m)  <span class="comment">// 执行添加逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *itabTableType)</span></span> add(m *itab) &#123; <span class="comment">// 添加逻辑</span></span><br><span class="line">    mask := t.size - <span class="number">1</span></span><br><span class="line">    h := itabHashFunc(m.inter, m._type) &amp; mask  <span class="comment">// 哈希后的值</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">1</span>); ; i++ &#123;</span><br><span class="line">        p := (**itab)(add(unsafe.Pointer(&amp;t.entries), h*sys.PtrSize))  <span class="comment">// 得到下表对应的位置</span></span><br><span class="line">        m2 := *p</span><br><span class="line">        <span class="keyword">if</span> m2 == m &#123;    <span class="comment">// 已经存在返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> m2 == <span class="literal">nil</span> &#123;  <span class="comment">// 位置为空存储</span></span><br><span class="line">            atomic.StorepNoWB(unsafe.Pointer(p), unsafe.Pointer(m))</span><br><span class="line">            t.count++</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        h += i          <span class="comment">// 哈希表解决哈希冲突的一种</span></span><br><span class="line">        h &amp;= mask</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全局哈希表的查找操作<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getitab</span><span class="params">(inter *interfacetype, typ *_type, canfail <span class="type">bool</span>)</span></span> *itab &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略一部分代码</span></span><br><span class="line">    <span class="keyword">var</span> m *itab</span><br><span class="line"></span><br><span class="line">    t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(&amp;itabTable))) <span class="comment">// 全局哈希表</span></span><br><span class="line">    <span class="keyword">if</span> m = t.find(inter, typ); m != <span class="literal">nil</span> &#123;               <span class="comment">// 全局哈希表中查找</span></span><br><span class="line">        <span class="keyword">goto</span> finish</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lock(&amp;itabLock)</span><br><span class="line">    <span class="keyword">if</span> m = itabTable.find(inter, typ); m != <span class="literal">nil</span> &#123;       <span class="comment">// 获取锁再次查找（最新的）</span></span><br><span class="line">        unlock(&amp;itabLock)</span><br><span class="line">        <span class="keyword">goto</span> finish</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没找到的情况下，新建itab，执行init函数（见上面init函数，填充itab.fun数组），将新建的添加到全局哈希表</span></span><br><span class="line">    m = (*itab)(persistentalloc(unsafe.Sizeof(itab&#123;&#125;)+<span class="type">uintptr</span>(<span class="built_in">len</span>(inter.mhdr)<span class="number">-1</span>)*sys.PtrSize, <span class="number">0</span>, &amp;memstats.other_sys))</span><br><span class="line">    m.inter = inter</span><br><span class="line">    m._type = typ</span><br><span class="line">    m.init()</span><br><span class="line">    itabAdd(m)</span><br><span class="line">    unlock(&amp;itabLock)</span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> m.fun[<span class="number">0</span>] != <span class="number">0</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> m</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> canfail &#123;        <span class="comment">// 允许失败，返回空。即m.fun[0] == 0， 未实现接口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不允许失败，panic</span></span><br><span class="line">    <span class="built_in">panic</span>(&amp;TypeAssertionError&#123;concreteString: typ.<span class="type">string</span>(), assertedString: inter.typ.<span class="type">string</span>(), missingMethod: m.init()&#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正常的hash获取逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *itabTableType)</span></span> find(inter *interfacetype, typ *_type) *itab &#123;</span><br><span class="line">    mask := t.size - <span class="number">1</span></span><br><span class="line">    h := itabHashFunc(inter, typ) &amp; mask</span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uintptr</span>(<span class="number">1</span>); ; i++ &#123;</span><br><span class="line">        p := (**itab)(add(unsafe.Pointer(&amp;t.entries), h*sys.PtrSize))</span><br><span class="line">        m := (*itab)(atomic.Loadp(unsafe.Pointer(p)))</span><br><span class="line">        <span class="keyword">if</span> m == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> m.inter == inter &amp;&amp; m._type == typ &#123;</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        &#125;</span><br><span class="line">        h += i</span><br><span class="line">        h &amp;= mask</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>go-源码研读-channel</title>
      <link href="/p/555850103.html"/>
      <url>/p/555850103.html</url>
      
        <content type="html"><![CDATA[<p>代码版本:<strong>1.12.7</strong></p><p><code>channel</code>是<code>Go</code>语言里面用来传递数据的一个接口</p><p>主要代码在<code>src/runtime/chan.go</code></p><span id="more"></span><h1 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">maxAlign  = <span class="number">8</span> <span class="comment">//偏移量</span></span><br><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>)) <span class="comment">//这里就是对齐一下maxAlign</span></span><br><span class="line">debugChan = <span class="literal">false</span> <span class="comment">//debug模式，开启后会输出debug信息</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h1><p>主要就两个类型，一个是<code>chan</code>的底层<code>hchan</code>，另外一个是<code>waitq</code>用来记录收发队列的<code>goroutine</code>的信息<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">   qcount   <span class="type">uint</span>               <span class="comment">// 缓冲区中已有元素个数</span></span><br><span class="line">   dataqsiz <span class="type">uint</span>               <span class="comment">// 循环队列容量大小</span></span><br><span class="line">   buf      unsafe.Pointer     <span class="comment">// 缓冲区指针</span></span><br><span class="line">   elemsize <span class="type">uint16</span>             <span class="comment">// 元素大小</span></span><br><span class="line">   closed   <span class="type">uint32</span>             <span class="comment">// 关闭标记，0没关闭，1关闭</span></span><br><span class="line">   elemtype *_type             <span class="comment">// 数据项类型</span></span><br><span class="line">   sendx    <span class="type">uint</span>               <span class="comment">// 发送索引</span></span><br><span class="line">   recvx    <span class="type">uint</span>               <span class="comment">// 接收索引</span></span><br><span class="line">   recvq    waitq              <span class="comment">// 等待接收排队链表</span></span><br><span class="line">   sendq    waitq              <span class="comment">// 等待发送排队链表</span></span><br><span class="line">   lock mutex                  <span class="comment">// 锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">   first *sudog</span><br><span class="line">   last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h1><h2 id="新建channel-ch-make-chan-int"><a href="#新建channel-ch-make-chan-int" class="headerlink" title="新建channel ch := make(chan int)"></a>新建channel <code>ch := make(chan int)</code></h2><p>创建一个<code>channel</code>的时候<code>Go</code>的语法是<code>ch := make(chan datatype)</code>,这个在底层的实现实际是<code>makechan</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、检查待存的数据类型大小，大于1&lt;&lt;16时异常</span></span><br><span class="line">    <span class="comment">// compiler checks this but be safe.</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//2、检查内存对齐（降低寻址次数，提高内存读取速度），大于最大的内存对齐字节数时，panic</span></span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、检查传入的size大小，大于堆可分配的最大内存时，panic，可以看出chan是在堆里面分配内存的</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.</span></span><br><span class="line"><span class="comment">// buf points into the same allocation, elemtype is persistent.</span></span><br><span class="line"><span class="comment">// SudoG&#x27;s are referenced from their owning thread so they can&#x27;t be collected.</span></span><br><span class="line"><span class="comment">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.</span></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Queue or element size is zero.</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line"><span class="comment">// Race detector uses this location for synchronization.</span></span><br><span class="line">        <span class="comment">// mem为0的时候将c.buf指向自己，避免竞争,具体可看raceaddr注释</span></span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.kind&amp;kindNoPointers != <span class="number">0</span>:</span><br><span class="line"><span class="comment">// Elements do not contain pointers.</span></span><br><span class="line"><span class="comment">// Allocate hchan and buf in one call.</span></span><br><span class="line">        <span class="comment">// 数据类型不包含指针的时候，直接分配hchanSize+size个数据的大小，然后将c.buf指向数据起始地址</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// Elements contain pointers.</span></span><br><span class="line">        <span class="comment">//包含指针的时候分开申请内存</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;makechan: chan=&quot;</span>, c, <span class="string">&quot;; elemsize=&quot;</span>, elem.size, <span class="string">&quot;; elemalg=&quot;</span>, elem.alg, <span class="string">&quot;; dataqsiz=&quot;</span>, size, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向channel发送数据-ch-lt-1"><a href="#向channel发送数据-ch-lt-1" class="headerlink" title="向channel发送数据 ch &lt;- 1"></a>向channel发送数据 <code>ch &lt;- 1</code></h2><p>向一个<code>chan</code>发送数据的语法是<code>chan &lt;- data</code>,在底层会被转为<code>chansend1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry point for c &lt;- x from compiled code</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * generic single channel send/recv</span></span><br><span class="line"><span class="comment"> * If block is not nil,</span></span><br><span class="line"><span class="comment"> * then the protocol will not</span></span><br><span class="line"><span class="comment"> * sleep but return if it could</span></span><br><span class="line"><span class="comment"> * not complete.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * sleep can wake up with g.param == nil</span></span><br><span class="line"><span class="comment"> * when a channel involved in the sleep has</span></span><br><span class="line"><span class="comment"> * been closed.  it is easiest to loop and re-run</span></span><br><span class="line"><span class="comment"> * the operation; we&#x27;ll see that it&#x27;s now closed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//c是当前channel，ep是数据的指针，block代表是否阻塞，默认都是阻塞，只有在select中是非阻塞，callerpc是取的PC寄存器</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">//如果当前channel是nil，在非阻塞的情况下会返回false，阻塞情况下会报错，按照历史提交来看的话，throw之前是return false，也就是再调度一轮后返回发送失败，现在的版本是直接在调度的时候就报错了</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chansend: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// After observing that the channel is not closed, we observe that the channel is</span></span><br><span class="line"><span class="comment">// not ready for sending. Each of these observations is a single word-sized read</span></span><br><span class="line"><span class="comment">// (first c.closed and second c.recvq.first or c.qcount depending on kind of channel).</span></span><br><span class="line"><span class="comment">// Because a closed channel cannot transition from &#x27;ready for sending&#x27; to</span></span><br><span class="line"><span class="comment">// &#x27;not ready for sending&#x27;, even if the channel is closed between the two observations,</span></span><br><span class="line"><span class="comment">// they imply a moment between the two when the channel was both not yet closed</span></span><br><span class="line"><span class="comment">// and not ready for sending. We behave as if we observed the channel at that moment,</span></span><br><span class="line"><span class="comment">// and report that the send cannot proceed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// It is okay if the reads are reordered here: if we observe that the channel is not</span></span><br><span class="line"><span class="comment">// ready for sending and then observe that it is not closed, that implies that the</span></span><br><span class="line"><span class="comment">// channel wasn&#x27;t closed during the first observation.</span></span><br><span class="line">    <span class="comment">// 如果是非阻塞，并且channel未关闭，并且（缓冲区为空也没有接受者或者缓冲区放满了），直接返回false</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; ((c.dataqsiz == <span class="number">0</span> &amp;&amp; c.recvq.first == <span class="literal">nil</span>) ||</span><br><span class="line">(c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; c.qcount == c.dataqsiz)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果channel关闭了，报错</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从接收者队列里面去取一个，直接把ep复制到接收者中，具体看send函数分析，然后返回成功</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting receiver. We pass the value we want to send</span></span><br><span class="line"><span class="comment">// directly to the receiver, bypassing the channel buffer (if any).</span></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有接收者，缓冲区有空位，就放入缓冲区中</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="comment">// Space is available in the channel buffer. Enqueue the element to send.</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没发出去，非阻塞直接返回</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Block on the channel. Some receiver will complete our operation for us.</span></span><br><span class="line">    <span class="comment">//阻塞的就将自己休眠进入调度</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前g</span></span><br><span class="line">gp := getg()</span><br><span class="line">    <span class="comment">//拿一个可用g</span></span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    <span class="comment">// 初始化一下</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 放入发送队列中</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 开始休眠调度</span></span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanSend, traceEvGoBlockSend, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// Ensure the value being sent is kept alive until the</span></span><br><span class="line"><span class="comment">// receiver copies it out. The sudog has a pointer to the</span></span><br><span class="line"><span class="comment">// stack object, but sudogs aren&#x27;t considered as roots of the</span></span><br><span class="line"><span class="comment">// stack tracer.</span></span><br><span class="line">    <span class="comment">//保活</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up.</span></span><br><span class="line">    <span class="comment">// 唤醒后gp.waiting应该等于mysg</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 唤醒的时候有传gp.param，所以判断下</span></span><br><span class="line"><span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 释放g</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// send processes a send operation on an empty channel c.</span></span><br><span class="line"><span class="comment">// The value ep sent by the sender is copied to the receiver sg.</span></span><br><span class="line"><span class="comment">// The receiver is then woken up to go on its merry way.</span></span><br><span class="line"><span class="comment">// Channel c must be empty and locked.  send unlocks c with unlockf.</span></span><br><span class="line"><span class="comment">// sg must already be dequeued from c.</span></span><br><span class="line"><span class="comment">// ep must be non-nil and point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="comment">// c是当前channel，sg是从接收队列中取出的g，ep是数据指针（必须是非空并且指向队或者调用放的栈上），unlockf解锁函数，发送后解锁用， skip作用未知</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">racesync(c, sg)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Pretend we go through the buffer, even though</span></span><br><span class="line"><span class="comment">// we copy directly. Note that we need to increment</span></span><br><span class="line"><span class="comment">// the head/tail locations only when raceenabled.</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">raceacquireg(sg.g, qp)</span><br><span class="line">racereleaseg(sg.g, qp)</span><br><span class="line">c.recvx++</span><br><span class="line">            <span class="comment">// 循环队列置位</span></span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 接收者数据指针不为空就直接发送，具体看sendDirect分析，发送完后置空</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 获取接受者的g</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">    <span class="comment">// param赋值</span></span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将接受者的g置为ready状态，让其可以调度</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sends and receives on unbuffered or empty-buffered channels are the</span></span><br><span class="line"><span class="comment">// only operations where one running goroutine writes to the stack of</span></span><br><span class="line"><span class="comment">// another running goroutine. The GC assumes that stack writes only</span></span><br><span class="line"><span class="comment">// happen when the goroutine is running and are only done by that</span></span><br><span class="line"><span class="comment">// goroutine. Using a write barrier is sufficient to make up for</span></span><br><span class="line"><span class="comment">// violating that assumption, but the write barrier has to work.</span></span><br><span class="line"><span class="comment">// typedmemmove will call bulkBarrierPreWrite, but the target bytes</span></span><br><span class="line"><span class="comment">// are not in the heap, so that will not help. We arrange to call</span></span><br><span class="line"><span class="comment">// memmove and typeBitsBulkBarrier instead.</span></span><br><span class="line"><span class="comment">// 因为按照规定，当前g是不能写别的g的栈的，所以需要一些处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src is on our stack, dst is a slot on another stack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Once we read sg.elem out of sg, it will no longer</span></span><br><span class="line"><span class="comment">// be updated if the destination&#x27;s stack gets copied (shrunk).</span></span><br><span class="line"><span class="comment">// So make sure that no preemption points can happen between read &amp; use.</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">    <span class="comment">// 写屏障处理</span></span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line"><span class="comment">// No need for cgo write barrier checks because dst is always</span></span><br><span class="line"><span class="comment">// Go memory.</span></span><br><span class="line">    <span class="comment">// 直接复制过去</span></span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从channel接收数据-lt-ch-a-lt-ch-a-ok-lt-ch"><a href="#从channel接收数据-lt-ch-a-lt-ch-a-ok-lt-ch" class="headerlink" title="从channel接收数据&lt;- ch,a =&lt;- ch,a,ok = &lt;- ch"></a>从channel接收数据<code>&lt;- ch</code>,<code>a =&lt;- ch</code>,<code>a,ok = &lt;- ch</code></h2><p>整体跟发送差不多，底层对应两种情况<code>chanrecv1</code>和<code>chanrecv2</code></p><p><code>chanrecv1</code>对应着<code>&lt;- ch</code>,<code>a =&lt;- ch</code>,赋值的操作还是在汇编做的</p><p><code>chanrecv2</code>则对应着<code>a,ok =&lt;- ch</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry points for &lt;- c from compiled code</span></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// chanrecv receives on channel c and writes the received data to ep.</span></span><br><span class="line"><span class="comment">// ep may be nil, in which case received data is ignored.</span></span><br><span class="line"><span class="comment">// If block == false and no elements are available, returns (false, false).</span></span><br><span class="line"><span class="comment">// Otherwise, if c is closed, zeros *ep and returns (true, false).</span></span><br><span class="line"><span class="comment">// Otherwise, fills in *ep with an element and returns (true, true).</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// raceenabled: don&#x27;t need to check ep, as it is always on the stack</span></span><br><span class="line"><span class="comment">// or is new memory allocated by reflect.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> debugChan &#123;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;chanrecv: chan=&quot;</span>, c, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前chan为空，非阻塞直接返回</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: check for failed non-blocking operation without acquiring the lock.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// After observing that the channel is not ready for receiving, we observe that the</span></span><br><span class="line"><span class="comment">// channel is not closed. Each of these observations is a single word-sized read</span></span><br><span class="line"><span class="comment">// (first c.sendq.first or c.qcount, and second c.closed).</span></span><br><span class="line"><span class="comment">// Because a channel cannot be reopened, the later observation of the channel</span></span><br><span class="line"><span class="comment">// being not closed implies that it was also not closed at the moment of the</span></span><br><span class="line"><span class="comment">// first observation. We behave as if we observed the channel at that moment</span></span><br><span class="line"><span class="comment">// and report that the receive cannot proceed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The order of operations is important here: reversing the operations can lead to</span></span><br><span class="line"><span class="comment">// incorrect behavior when racing with a close.</span></span><br><span class="line">    <span class="comment">//判断下是否有非阻塞返回的情况</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; (c.dataqsiz == <span class="number">0</span> &amp;&amp; c.sendq.first == <span class="literal">nil</span> ||</span><br><span class="line">c.dataqsiz &gt; <span class="number">0</span> &amp;&amp; atomic.Loaduint(&amp;c.qcount) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果关闭了并且缓冲区为空，直接返回</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从发送者队列里面去取一个，直接把值复制到ep中，具体看recv函数分析，然后返回成功</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// Found a waiting sender. If buffer is size 0, receive value</span></span><br><span class="line"><span class="comment">// directly from sender. Otherwise, receive from head of queue</span></span><br><span class="line"><span class="comment">// and add sender&#x27;s value to the tail of the queue (both map to</span></span><br><span class="line"><span class="comment">// the same buffer slot because the queue is full).</span></span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果缓冲区有值，从缓冲区取</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Receive directly from queue</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.qcount--</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都没取到，非阻塞直接返回</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no sender available: block on this channel.</span></span><br><span class="line">    <span class="comment">// 阻塞的就将自己休眠进入调度</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// No stack splits between assigning elem and enqueuing mysg</span></span><br><span class="line"><span class="comment">// on gp.waiting where copystack can find it.</span></span><br><span class="line">    <span class="comment">// 初始化一下g</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">goparkunlock(&amp;c.lock, waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// someone woke us up</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recv processes a receive operation on a full channel c.</span></span><br><span class="line"><span class="comment">// There are 2 parts:</span></span><br><span class="line"><span class="comment">// 1) The value sent by the sender sg is put into the channel</span></span><br><span class="line"><span class="comment">//    and the sender is woken up to go on its merry way.</span></span><br><span class="line"><span class="comment">// 2) The value received by the receiver (the current G) is</span></span><br><span class="line"><span class="comment">//    written to ep.</span></span><br><span class="line"><span class="comment">// For synchronous channels, both values are the same.</span></span><br><span class="line"><span class="comment">// For asynchronous channels, the receiver gets its data from</span></span><br><span class="line"><span class="comment">// the channel buffer and the sender&#x27;s data is put in the</span></span><br><span class="line"><span class="comment">// channel buffer.</span></span><br><span class="line"><span class="comment">// Channel c must be full and locked. recv unlocks c with unlockf.</span></span><br><span class="line"><span class="comment">// sg must already be dequeued from c.</span></span><br><span class="line"><span class="comment">// A non-nil ep must point to the heap or the caller&#x27;s stack.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果无缓冲</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racesync(c, sg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// copy data from sender</span></span><br><span class="line">            <span class="comment">// 如果接收者有接收值，直接从发送者复制一份到ep中</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Queue is full. Take the item at the</span></span><br><span class="line"><span class="comment">// head of the queue. Make the sender enqueue</span></span><br><span class="line"><span class="comment">// its item at the tail of the queue. Since the</span></span><br><span class="line"><span class="comment">// queue is full, those are both the same slot.</span></span><br><span class="line">        <span class="comment">// 从缓冲区取值</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquire(qp)</span><br><span class="line">racerelease(qp)</span><br><span class="line">raceacquireg(sg.g, qp)</span><br><span class="line">racereleaseg(sg.g, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// copy data from queue to receiver</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 如果接收者有接收值，复制一份到ep中</span></span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// copy data from sender to queue</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">c.recvx++</span><br><span class="line">        <span class="comment">// 循环队列置位</span></span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将发送者的g置为ready状态，让其可以调度</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与sendDirect 一样</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// dst is on our stack or the heap, src is on another stack.</span></span><br><span class="line"><span class="comment">// The channel is locked, so src will not move during this</span></span><br><span class="line"><span class="comment">// operation.</span></span><br><span class="line">src := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关闭channel-close-ch"><a href="#关闭channel-close-ch" class="headerlink" title="关闭channel close(ch)"></a>关闭channel <code>close(ch)</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c是当前channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 当前channel为空直接报错</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 之前已经关过</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">callerpc := getcallerpc()</span><br><span class="line">racewritepc(c.raceaddr(), callerpc, funcPC(closechan))</span><br><span class="line">racerelease(c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 置位关闭状态</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all readers</span></span><br><span class="line">    <span class="comment">// 释放所有的接收方</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 从读取队列里取一个g</span></span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 接收者接收值不为空清理一下</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 添加到glist等待释放</span></span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// release all writers (they will panic)</span></span><br><span class="line">    <span class="comment">// 释放所有发送者，会panic</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 从发送者队列取</span></span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 直接置空发送者的值，方便gc回收</span></span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 添加到glist等待释放</span></span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ready all Gs now that we&#x27;ve dropped the channel lock.</span></span><br><span class="line">    <span class="comment">// 将所有g置为ready状态让其可以被调度</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="select相关"><a href="#select相关" class="headerlink" title="select相关"></a><code>select</code>相关</h2><p>在底层<code>select</code>会被转成对应的语法来调用上面的<code>chansend</code>,<code>chanrecv</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//select &#123;</span></span><br><span class="line"><span class="comment">//case c &lt;- v:</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//default:</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if selectnbsend(c, v) &#123;</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//select &#123;</span></span><br><span class="line"><span class="comment">//case v = &lt;-c:</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//default:</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if selectnbrecv(&amp;v, c) &#123;</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line">selected, _ = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compiler implements</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//select &#123;</span></span><br><span class="line"><span class="comment">//case v, ok = &lt;-c:</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//default:</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// as</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//if c != nil &amp;&amp; selectnbrecv2(&amp;v, &amp;ok, c) &#123;</span></span><br><span class="line"><span class="comment">//... foo</span></span><br><span class="line"><span class="comment">//&#125; else &#123;</span></span><br><span class="line"><span class="comment">//... bar</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv2</span><span class="params">(elem unsafe.Pointer, received *<span class="type">bool</span>, c *hchan)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// TODO(khr): just return 2 values from this function, now that it is in Go.</span></span><br><span class="line">selected, *received = chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> src </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql-innodb索引与查询优化</title>
      <link href="/p/3122189522.html"/>
      <url>/p/3122189522.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、-引言"><a href="#一、-引言" class="headerlink" title="一、 引言"></a>一、 引言</h2><p><strong>概要</strong></p><p>(1)  innodb索引类型与B+树</p><p>(2)  索引使用注意事项</p><p><strong>问题</strong></p><p>(1)  InnoDb索引为什么要用b+树？</p><p>(2)  聚集索引与普通索引有什么区别？</p><p>(3)  为什么主键最好是自增？</p><p>(4)  组合索引有什么优势？</p><p>(5) 有哪些实际业务场景索引搞不定？ </p> <span id="more"></span><h2 id="二、-innodb索引类型与B-树"><a href="#二、-innodb索引类型与B-树" class="headerlink" title="二、 innodb索引类型与B+树"></a>二、 innodb索引类型与B+树</h2><p>INNODB主要有几种索引：B+树索引，自适应哈希索引，全文索引 ，覆盖索引。<br>B+树索引是一种多叉平衡查找树。<br>自适应哈希索引是mysql对于频繁查询的数据采取的hash存储优化，用户无法选择设置。<br>全文索引主要用于全文检索使用。<br>覆盖索引说的是查询的字段都属于同一个索引字段，这样效率非常高。</p><h3 id="查找树"><a href="#查找树" class="headerlink" title="查找树"></a>查找树</h3><p>​      查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），红黑树(Red-Black Tree )，B-tree/B+-tree/ B*-tree (B~Tree)。前三者是典型的二叉查找树结构，其查找的时间复杂度O(log2N)与树的深度相关，那么降低树的深度自然会提高查找效率。</p><h3 id="B树-B-树-B-树"><a href="#B树-B-树-B-树" class="headerlink" title="B树/B+树/B*树"></a>B树/B+树/B*树</h3><p>B树</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3122189522/b.png" class="" title="soft"><p>B+树</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3122189522/b_plus.png" class="" title="soft"><p>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。</p><p>数据库索引采用B+树的主要原因是: B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。</p><p>B*树</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3122189522/b_star.png" class="" title="soft"><p>和B+树的主要区别：</p><p>1、B*树中非根和非叶子结点都有指向兄弟的指针；</p><p>2、B<em>树定义了叶子结点关键字个数至少为(2/3)</em>M，即块的最低使用率为2/3（代替B+树的1/2）</p><h3 id="聚集索引和普通索引"><a href="#聚集索引和普通索引" class="headerlink" title="聚集索引和普通索引"></a>聚集索引和普通索引</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3122189522/index.png" class="" title="soft"><p>1、主键和普通索引都是B+树索引</p><p>2、主键的叶子节点是：数据；普通索引的叶子节点是：主键的值</p><p>3、普通索引的检索需要经过两次B+树查找：</p><p>​     I）通过普通索引，找到：主键key</p><p>​     II）通过主键key，查找到元素</p><h3 id="自适应hash索引"><a href="#自适应hash索引" class="headerlink" title="自适应hash索引"></a>自适应hash索引</h3><p> Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升。经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。</p><p>自适应hash索引只适用于等值查询。</p><h3 id="INNODB如何建立聚集索引"><a href="#INNODB如何建立聚集索引" class="headerlink" title="INNODB如何建立聚集索引"></a>INNODB如何建立聚集索引</h3><p>1）有主键，则INNODB使用它作为聚集索引。</p><p>2）未定义主键，INNODB选第一个非NULL的唯一索引列，使用它作为聚集索引。</p><p>3）如果1）、2）都没有，Mysql自动添加一个不可见不可引用的6byte大小的rowid作为聚集索引.</p><h3 id="主键必须是自增"><a href="#主键必须是自增" class="headerlink" title="主键必须是自增"></a>主键必须是自增</h3><p>       如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，<strong>因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据</strong>，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><h3 id="普通索引的叶子节点内容"><a href="#普通索引的叶子节点内容" class="headerlink" title="普通索引的叶子节点内容"></a>普通索引的叶子节点内容</h3><p>​       存储的是主键的值。好处如下</p><p>​       辅助索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”。</p><h3 id="普通索引的叶子节点空洞"><a href="#普通索引的叶子节点空洞" class="headerlink" title="普通索引的叶子节点空洞"></a>普通索引的叶子节点空洞</h3><p>B*树定义了叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3</p><p>B+树的最低使用率是1/2,这是由树的分裂算法决定的。</p><p>B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；</p><p>B*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字(因为兄弟结点的关键字范围改变了）；</p><p>​                      如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；<br>所以，B*树分配新结点的概率比B+树要低，空间使用率更高； </p><p><strong>每一次数据页分裂，都会导致叶子节点空洞的产生。</strong></p><h3 id="COUNT查询较慢原因以及优化"><a href="#COUNT查询较慢原因以及优化" class="headerlink" title="COUNT查询较慢原因以及优化"></a>COUNT查询较慢原因以及优化</h3><p>​    count指令实现上采用实时统计方式，要么通过聚集索引统计，要么通过二级索引统计<br>​    在无可用的二级索引情况下，执行count会使MySQL扫描全表数据，当数据中存在大字段或字段较多时候，其效率非常低下（每个页只能包含较少的数据条数，需要访问的物理页较多）</p><p>​      二级索引存储的数据为指定字段的值与主键值。当我们通过二级索引统计数据的时候，无需扫描数据文件；</p><p>​      所以，可以建立合适的单子段普通索引，提高COUNT统计效率<br>​     </p><h3 id="组合索引优势"><a href="#组合索引优势" class="headerlink" title="组合索引优势"></a>组合索引优势</h3><p>(1) 满足最左前缀的查询，都可以用到索引。</p><p>(2) 覆盖索引查询，效率更快。</p><h2 id="三、-索引使用注意事项"><a href="#三、-索引使用注意事项" class="headerlink" title="三、 索引使用注意事项"></a>三、 索引使用注意事项</h2><p>(1)  尽量选择区分度高的列作为索引。</p><p>​      区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1</p><p>(2) 选用自增ID作为主键。</p><p>(3) 组合索引的建立需要进行仔细分析；</p><p>​    1)、正确选择组合索引中的主列字段，一般是选择性较好的字段；</p><p>     2)、组合索引的几个字段是否经常同时以AND方式出现在Where子句中？<br>          如果是，则可以建立复合索引；否则考虑单字段索引； </p><p>​    3)、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；</p><p>     4)、如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；</p><p>(4) 频繁进行数据操作的表，不要建立太多的索引；</p><p>(5) 删除无用的索引，避免对执行计划造成负面影响；</p><p>(6) 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描。</p><p>(7) 字符字段只建前缀索引, 最好不要做主键。</p><p>(8) 使用同类型进行比较, 否则不会用到索引。</p><p>(9)  尽量避免在WHERE子句中使用!= 或 &lt;&gt;，not like 操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>(10) 索引不会包含有NULL值的列。</p><p>(11) 单表索引建议控制在5个以内。</p><p>(12) 什么时候不要使用索引？</p><p>​    经常增删改的列不要建立索引.</p><p>​    有大量重复的列不建立索引.</p><p>​    表记录太少不要建立索引；</p><p>…</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis-源码学习-zset</title>
      <link href="/p/3997352082.html"/>
      <url>/p/3997352082.html</url>
      
        <content type="html"><![CDATA[<p>基础的zset相关的命令,<code>t_zset.c</code></p><span id="more"></span><h2 id="zadd——zaddCommand"><a href="#zadd——zaddCommand" class="headerlink" title="zadd——zaddCommand"></a>zadd——zaddCommand</h2><p>示例：ZADD KEY_NAME SCORE1 VALUE1.. SCOREN VALUEN</p><ul><li>被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zaddCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    zaddGenericCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* This generic command implements both ZADD and ZINCRBY. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zaddGenericCommand</span><span class="params">(redisClient *c, <span class="type">int</span> incr)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *nanerr = <span class="string">&quot;resulting score is not a number (NaN)&quot;</span>;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *ele;</span><br><span class="line">    robj *zobj;</span><br><span class="line">    robj *curobj;</span><br><span class="line">    <span class="type">double</span> score = <span class="number">0</span>, *scores = <span class="literal">NULL</span>, curscore = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> j, elements = (c-&gt;argc<span class="number">-2</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> added = <span class="number">0</span>, updated = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输入的 score - member 参数必须是成对出现的</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc % <span class="number">2</span>) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Start parsing all the scores, we need to emit any syntax error</span></span><br><span class="line"><span class="comment">     * before executing additions to the sorted set, as the command should</span></span><br><span class="line"><span class="comment">     * either execute fully or nothing at all. */</span></span><br><span class="line">    <span class="comment">// 取出所有输入的 score 分值</span></span><br><span class="line">    scores = zmalloc(<span class="keyword">sizeof</span>(<span class="type">double</span>)*elements);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>)</span><br><span class="line">            != REDIS_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Lookup the key and create the sorted set if does not exist. */</span></span><br><span class="line">    <span class="comment">// 取出有序集合对象</span></span><br><span class="line">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    <span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 有序集合不存在，创建新有序集合</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[<span class="number">3</span>]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            zobj = createZsetZiplistObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关联对象到数据库</span></span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对象存在，检查类型</span></span><br><span class="line">        <span class="keyword">if</span> (zobj-&gt;type != REDIS_ZSET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="comment">// 有序集合为 ziplist 编码</span></span><br><span class="line">        <span class="keyword">if</span> (zobj-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">char</span> *eptr;</span><br><span class="line">            <span class="comment">/* Prefer non-encoded element when dealing with ziplists. */</span></span><br><span class="line">            <span class="comment">// 查找成员</span></span><br><span class="line">            ele = c-&gt;argv[<span class="number">3</span>+j*<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 成员已存在</span></span><br><span class="line">                <span class="comment">// ZINCRYBY 命令时使用</span></span><br><span class="line">                <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                    score += curscore;</span><br><span class="line">                    <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                        addReplyError(c,nanerr);</span><br><span class="line">                        <span class="keyword">goto</span> cleanup;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* Remove and re-insert when score changed. */</span></span><br><span class="line">                <span class="comment">// 执行 ZINCRYBY 命令时，</span></span><br><span class="line">                <span class="comment">// 或者用户通过 ZADD 修改成员的分值时执行</span></span><br><span class="line">                <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                    <span class="comment">// 删除已有元素</span></span><br><span class="line">                    zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                    <span class="comment">// 重新插入元素</span></span><br><span class="line">                    zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">                    <span class="comment">// 计数器</span></span><br><span class="line">                    server.dirty++;</span><br><span class="line">                    updated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Optimize: check if the element is too large or the list</span></span><br><span class="line"><span class="comment">                 * becomes too long *before* executing zzlInsert. */</span></span><br><span class="line">                <span class="comment">// 元素不存在，直接添加</span></span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">                <span class="comment">// 查看元素的数量，</span></span><br><span class="line">                <span class="comment">// 看是否需要将 ZIPLIST 编码转换为有序集合</span></span><br><span class="line">                <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries)</span><br><span class="line">                    zsetConvert(zobj,REDIS_ENCODING_SKIPLIST);</span><br><span class="line">                <span class="comment">// 查看新添加元素的长度</span></span><br><span class="line">                <span class="comment">// 看是否需要将 ZIPLIST 编码转换为有序集合</span></span><br><span class="line">                <span class="keyword">if</span> (sdslen(ele-&gt;ptr) &gt; server.zset_max_ziplist_value)</span><br><span class="line">                    zsetConvert(zobj,REDIS_ENCODING_SKIPLIST);</span><br><span class="line">                server.dirty++;</span><br><span class="line">                added++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 有序集合为 SKIPLIST 编码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == REDIS_ENCODING_SKIPLIST) &#123;</span><br><span class="line">            zset *zs = zobj-&gt;ptr;</span><br><span class="line">            zskiplistNode *znode;</span><br><span class="line">            dictEntry *de;</span><br><span class="line">            <span class="comment">// 编码对象</span></span><br><span class="line">            ele = c-&gt;argv[<span class="number">3</span>+j*<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>+j*<span class="number">2</span>]);</span><br><span class="line">            <span class="comment">// 查看成员是否存在</span></span><br><span class="line">            de = dictFind(zs-&gt;dict,ele);</span><br><span class="line">            <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 成员存在</span></span><br><span class="line">                <span class="comment">// 取出成员</span></span><br><span class="line">                curobj = dictGetKey(de);</span><br><span class="line">                <span class="comment">// 取出分值</span></span><br><span class="line">                curscore = *(<span class="type">double</span>*)dictGetVal(de);</span><br><span class="line">                <span class="comment">// ZINCRYBY 时执行</span></span><br><span class="line">                <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                    score += curscore;</span><br><span class="line">                    <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                        addReplyError(c,nanerr);</span><br><span class="line">                        <span class="comment">/* Don&#x27;t need to check if the sorted set is empty</span></span><br><span class="line"><span class="comment">                         * because we know it has at least one element. */</span></span><br><span class="line">                        <span class="keyword">goto</span> cleanup;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* Remove and re-insert when score changed. We can safely</span></span><br><span class="line"><span class="comment">                 * delete the key object from the skiplist, since the</span></span><br><span class="line"><span class="comment">                 * dictionary still has a reference to it. */</span></span><br><span class="line">                <span class="comment">// 执行 ZINCRYBY 命令时，</span></span><br><span class="line">                <span class="comment">// 或者用户通过 ZADD 修改成员的分值时执行</span></span><br><span class="line">                <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                    <span class="comment">// 删除原有元素</span></span><br><span class="line">                    redisAssertWithInfo(c,curobj,zslDelete(zs-&gt;zsl,curscore,curobj));</span><br><span class="line">                    <span class="comment">// 重新插入元素</span></span><br><span class="line">                    znode = zslInsert(zs-&gt;zsl,score,curobj);</span><br><span class="line">                    incrRefCount(curobj); <span class="comment">/* Re-inserted in skiplist. */</span></span><br><span class="line">                    <span class="comment">// 更新字典的分值指针</span></span><br><span class="line">                    dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">/* Update score ptr. */</span></span><br><span class="line">                    server.dirty++;</span><br><span class="line">                    updated++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 元素不存在，直接添加到跳跃表</span></span><br><span class="line">                znode = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">                incrRefCount(ele); <span class="comment">/* Inserted in skiplist. */</span></span><br><span class="line">                <span class="comment">// 将元素关联到字典</span></span><br><span class="line">                redisAssertWithInfo(c,<span class="literal">NULL</span>,dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);</span><br><span class="line">                incrRefCount(ele); <span class="comment">/* Added to dictionary. */</span></span><br><span class="line">                server.dirty++;</span><br><span class="line">                added++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            redisPanic(<span class="string">&quot;Unknown sorted set encoding&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (incr) <span class="comment">/* ZINCRBY */</span></span><br><span class="line">        addReplyDouble(c,score);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">/* ZADD */</span></span><br><span class="line">        addReplyLongLong(c,added);</span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">&quot;zincr&quot;</span> : <span class="string">&quot;zadd&quot;</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="zincrby——zincrbyCommand"><a href="#zincrby——zincrbyCommand" class="headerlink" title="zincrby——zincrbyCommand"></a>zincrby——zincrbyCommand</h2><p>示例：ZINCRBY key increment member</p><ul><li>member 成员的新分数值，以字符串形式表示。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zincrbyCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    zaddGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="zrem——zremCommand"><a href="#zrem——zremCommand" class="headerlink" title="zrem——zremCommand"></a>zrem——zremCommand</h2><p>示例：ZREM key member [member …]</p><ul><li>被成功移除的成员的数量，不包括被忽略的成员。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zremCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    <span class="type">int</span> deleted = <span class="number">0</span>, keyremoved = <span class="number">0</span>, j;</span><br><span class="line">    <span class="comment">// 取出有序集合对象</span></span><br><span class="line">    <span class="keyword">if</span> ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,zobj,REDIS_ZSET)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从 ziplist 中删除</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *eptr;</span><br><span class="line">        <span class="comment">// 遍历所有输入元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果元素在 ziplist 中存在的话</span></span><br><span class="line">            <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,c-&gt;argv[j],<span class="literal">NULL</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 元素存在时，删除计算器才增一</span></span><br><span class="line">                deleted++;</span><br><span class="line">                <span class="comment">// 那么删除它们</span></span><br><span class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// ziplist 已清空，将有序集合从数据库中删除</span></span><br><span class="line">                <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) == <span class="number">0</span>) &#123;</span><br><span class="line">                    dbDelete(c-&gt;db,key);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 从跳跃表和字典中删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == REDIS_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        <span class="type">double</span> score;</span><br><span class="line">        <span class="comment">// 遍历所有输入元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            <span class="comment">// 查找元素</span></span><br><span class="line">            de = dictFind(zs-&gt;dict,c-&gt;argv[j]);</span><br><span class="line">            <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 元素存在时，删除计算器才增一</span></span><br><span class="line">                deleted++;</span><br><span class="line">                <span class="comment">/* Delete from the skiplist */</span></span><br><span class="line">                <span class="comment">// 将元素从跳跃表中删除</span></span><br><span class="line">                score = *(<span class="type">double</span>*)dictGetVal(de);</span><br><span class="line">                redisAssertWithInfo(c,c-&gt;argv[j],zslDelete(zs-&gt;zsl,score,c-&gt;argv[j]));</span><br><span class="line">                <span class="comment">/* Delete from the hash table */</span></span><br><span class="line">                <span class="comment">// 将元素从字典中删除</span></span><br><span class="line">                dictDelete(zs-&gt;dict,c-&gt;argv[j]);</span><br><span class="line">                <span class="comment">// 检查是否需要缩小字典</span></span><br><span class="line">                <span class="keyword">if</span> (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);</span><br><span class="line">                <span class="comment">// 字典已被清空，有序集合已经被清空，将它从数据库中删除</span></span><br><span class="line">                <span class="keyword">if</span> (dictSize(zs-&gt;dict) == <span class="number">0</span>) &#123;</span><br><span class="line">                    dbDelete(c-&gt;db,key);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown sorted set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有至少一个元素被删除的话，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,<span class="string">&quot;zrem&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (keyremoved)</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        server.dirty += deleted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回复被删除元素的数量</span></span><br><span class="line">    addReplyLongLong(c,deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="zremrangebyscore——zremrangebyscoreCommand"><a href="#zremrangebyscore——zremrangebyscoreCommand" class="headerlink" title="zremrangebyscore——zremrangebyscoreCommand"></a>zremrangebyscore——zremrangebyscoreCommand</h2><p>示例：ZREMRANGEBYSCORE key min max</p><ul><li>被移除成员的数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zremrangebyscoreCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    zremrangeGenericCommand(c,ZRANGE_SCORE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Implements ZREMRANGEBYRANK, ZREMRANGEBYSCORE, ZREMRANGEBYLEX commands. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZRANGE_RANK 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZRANGE_SCORE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZRANGE_LEX 2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">zremrangeGenericCommand</span><span class="params">(redisClient *c, <span class="type">int</span> rangetype)</span> &#123;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    <span class="type">int</span> keyremoved = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> deleted;</span><br><span class="line">    zrangespec range;</span><br><span class="line">    zlexrangespec lexrange;</span><br><span class="line">    <span class="type">long</span> start, end, llen;</span><br><span class="line">    <span class="comment">/* Step 1: Parse the range. */</span></span><br><span class="line">    <span class="keyword">if</span> (rangetype == ZRANGE_RANK) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;start,<span class="literal">NULL</span>) != REDIS_OK) ||</span><br><span class="line">            (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;end,<span class="literal">NULL</span>) != REDIS_OK))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangetype == ZRANGE_SCORE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (zslParseRange(c-&gt;argv[<span class="number">2</span>],c-&gt;argv[<span class="number">3</span>],&amp;range) != REDIS_OK) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">&quot;min or max is not a float&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rangetype == ZRANGE_LEX) &#123;</span><br><span class="line">        <span class="keyword">if</span> (zslParseLexRange(c-&gt;argv[<span class="number">2</span>],c-&gt;argv[<span class="number">3</span>],&amp;lexrange) != REDIS_OK) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">&quot;min or max not valid string range item&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Lookup &amp; range sanity checks if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,zobj,REDIS_ZSET)) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    <span class="keyword">if</span> (rangetype == ZRANGE_RANK) &#123;</span><br><span class="line">        <span class="comment">/* Sanitize indexes. */</span></span><br><span class="line">        llen = zsetLength(zobj);</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">         * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: Perform the range deletion operation. */</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(rangetype) &#123;</span><br><span class="line">        <span class="keyword">case</span> ZRANGE_RANK:</span><br><span class="line">            zobj-&gt;ptr = zzlDeleteRangeByRank(zobj-&gt;ptr,start+<span class="number">1</span>,end+<span class="number">1</span>,&amp;deleted);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ZRANGE_SCORE:</span><br><span class="line">            zobj-&gt;ptr = zzlDeleteRangeByScore(zobj-&gt;ptr,&amp;range,&amp;deleted);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ZRANGE_LEX:</span><br><span class="line">            zobj-&gt;ptr = zzlDeleteRangeByLex(zobj-&gt;ptr,&amp;lexrange,&amp;deleted);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) == <span class="number">0</span>) &#123;</span><br><span class="line">            dbDelete(c-&gt;db,key);</span><br><span class="line">            keyremoved = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 从跳跃表和字典中删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == REDIS_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        <span class="keyword">switch</span>(rangetype) &#123;</span><br><span class="line">        <span class="keyword">case</span> ZRANGE_RANK:</span><br><span class="line">            deleted = zslDeleteRangeByRank(zs-&gt;zsl,start+<span class="number">1</span>,end+<span class="number">1</span>,zs-&gt;dict);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ZRANGE_SCORE:</span><br><span class="line">            deleted = zslDeleteRangeByScore(zs-&gt;zsl,&amp;range,zs-&gt;dict);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ZRANGE_LEX:</span><br><span class="line">            deleted = zslDeleteRangeByLex(zs-&gt;zsl,&amp;lexrange,zs-&gt;dict);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);</span><br><span class="line">        <span class="comment">// 对象已清空，从数据库中删除</span></span><br><span class="line">        <span class="keyword">if</span> (dictSize(zs-&gt;dict) == <span class="number">0</span>) &#123;</span><br><span class="line">            dbDelete(c-&gt;db,key);</span><br><span class="line">            keyremoved = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown sorted set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: Notifications and reply. */</span></span><br><span class="line">    <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">        <span class="type">char</span> *event[<span class="number">3</span>] = &#123;<span class="string">&quot;zremrangebyrank&quot;</span>,<span class="string">&quot;zremrangebyscore&quot;</span>,<span class="string">&quot;zremrangebylex&quot;</span>&#125;;</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_ZSET,event[rangetype],key,c-&gt;db-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (keyremoved)</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += deleted;</span><br><span class="line">    <span class="comment">// 回复被删除元素的个数</span></span><br><span class="line">    addReplyLongLong(c,deleted);</span><br><span class="line">cleanup:</span><br><span class="line">    <span class="keyword">if</span> (rangetype == ZRANGE_LEX) zslFreeLexRange(&amp;lexrange);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除 ziplist 中分值在指定范围内的元素</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * deleted 不为 NULL 时，在删除完毕之后，将被删除元素的数量保存到 *deleted 中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">zzlDeleteRangeByScore</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *zl, zrangespec *range, <span class="type">unsigned</span> <span class="type">long</span> *deleted)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *eptr, *sptr;</span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (deleted != <span class="literal">NULL</span>) *deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 指向 ziplist 中第一个符合范围的节点</span></span><br><span class="line">    eptr = zzlFirstInRange(zl,range);</span><br><span class="line">    <span class="keyword">if</span> (eptr == <span class="literal">NULL</span>) <span class="keyword">return</span> zl;</span><br><span class="line">    <span class="comment">/* When the tail of the ziplist is deleted, eptr will point to the sentinel</span></span><br><span class="line"><span class="comment">     * byte and ziplistNext will return NULL. */</span></span><br><span class="line">    <span class="comment">// 一直删除节点，直到遇到不在范围内的值为止</span></span><br><span class="line">    <span class="comment">// 节点中的值都是有序的</span></span><br><span class="line">    <span class="keyword">while</span> ((sptr = ziplistNext(zl,eptr)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        score = zzlGetScore(sptr);</span><br><span class="line">        <span class="keyword">if</span> (zslValueLteMax(score,range)) &#123;</span><br><span class="line">            <span class="comment">/* Delete both the element and the score. */</span></span><br><span class="line">            zl = ziplistDelete(zl,&amp;eptr);</span><br><span class="line">            zl = ziplistDelete(zl,&amp;eptr);</span><br><span class="line">            num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* No longer in range. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deleted != <span class="literal">NULL</span>) *deleted = num;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Delete all the elements with score between min and max from the skiplist.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 删除所有分值在给定范围之内的节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Min and max are inclusive, so a score &gt;= min || score &lt;= max is deleted.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * min 和 max 参数都是包含在范围之内的，所以分值 &gt;= min 或 &lt;= max 的节点都会被删除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function takes the reference to the hash table view of the</span></span><br><span class="line"><span class="comment"> * sorted set, in order to remove the elements from the hash table too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 节点不仅会从跳跃表中删除，而且会从相应的字典中删除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值为被删除节点的数量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">zslDeleteRangeByScore</span><span class="params">(zskiplist *zsl, zrangespec *range, dict *dict)</span> &#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> removed = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 记录所有和被删除节点（们）有关的节点</span></span><br><span class="line">    <span class="comment">// T_wrost = O(N) , T_avg = O(log N)</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (range-&gt;minex ?</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt;= range-&gt;min :</span><br><span class="line">            x-&gt;level[i].forward-&gt;score &lt; range-&gt;min))</span><br><span class="line">                x = x-&gt;level[i].forward;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Current node is the last with score &lt; or &lt;= min. */</span></span><br><span class="line">    <span class="comment">// 定位到给定范围开始的第一个节点</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    <span class="comment">/* Delete nodes while in range. */</span></span><br><span class="line">    <span class="comment">// 删除范围中的所有节点</span></span><br><span class="line">    <span class="comment">// T = O(N)</span></span><br><span class="line">    <span class="keyword">while</span> (x &amp;&amp;</span><br><span class="line">           (range-&gt;maxex ? x-&gt;score &lt; range-&gt;max : x-&gt;score &lt;= range-&gt;max))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 记录下个节点的指针</span></span><br><span class="line">        zskiplistNode *next = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zslDeleteNode(zsl,x,update);</span><br><span class="line">        dictDelete(dict,x-&gt;obj);</span><br><span class="line">        zslFreeNode(x);</span><br><span class="line">        removed++;</span><br><span class="line">        x = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="zremrangebyrank——zremrangebyrankCommand"><a href="#zremrangebyrank——zremrangebyrankCommand" class="headerlink" title="zremrangebyrank——zremrangebyrankCommand"></a>zremrangebyrank——zremrangebyrankCommand</h2><p>示例：ZREMRANGEBYSCORE key min max</p><ul><li>被移除成员的数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">zremrangebyrankCommand</span><span class="params">(client *c)</span> &#123;</span><br><span class="line">    zremrangeGenericCommand(c,ZRANGE_RANK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th><th>ziplist编码时间复杂度</th><th>skiplist编码时间复杂度</th></tr></thead><tbody><tr><td>命令</td><td>作用</td><td>ziplist编码时间复杂度</td><td>skiplist编码时间复杂度</td></tr><tr><td>ZADD</td><td>将一个或多个元素加入到指定有序集合当中</td><td>平均O(N), 最坏O(N2)</td><td>平均O(logN), 最坏O(N)</td></tr><tr><td>ZCARD</td><td>返回指定有序集合的元素数量</td><td>O(1)</td><td>O(1)</td></tr><tr><td>ZCOUNT</td><td>返回有序集合中，score 值在 min 和 max 之间成员的数量</td><td>O(n)</td><td>O(log(n))</td></tr><tr><td>ZRANGE</td><td>返回有序集合中，指定区间内的成员</td><td>O(n)</td><td>O(log(n)+m)，n为有序集合的长度，m为结果集的长度</td></tr><tr><td>ZREVRANGE</td><td>返回有序集 key 中，指定区间内的成员，其中有序集成员按 score 值递减(从大到小)顺序排列</td><td>O(n)</td><td>O(log(n)+m)，n为有序集合的长度，m为结果集的长度</td></tr><tr><td>ZRANK</td><td>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列</td><td>O(n)</td><td>O(log(n))</td></tr><tr><td>ZREVRANK</td><td>返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递减(从大到小)排序</td><td>O(n)</td><td>O(log(n))</td></tr><tr><td>ZREM</td><td>移除有序集 key 中的一个或多个成员，不存在的成员将被忽略</td><td>平均O(N), 最坏O(N2)</td><td>O(m*log(n))，m为需要移除的元素数量,n为有序中的元素数量</td></tr><tr><td>ZSCORE</td><td>返回有序集 key 中，成员 member 的 score 值</td><td>O(n)</td><td>O(1)</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis-源码学习-set</title>
      <link href="/p/976380154.html"/>
      <url>/p/976380154.html</url>
      
        <content type="html"><![CDATA[<p>基础的set相关的命令,<code>t_set.c</code></p><span id="more"></span><h2 id="sadd——saddCommand"><a href="#sadd——saddCommand" class="headerlink" title="sadd——saddCommand"></a>sadd——saddCommand</h2><p>示例：SADD KEY_NAME VALUE1..VALUEN</p><ul><li>被添加到集合中的新元素的数量，不包括被忽略的元素。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">saddCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="type">int</span> j, added = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取出集合对象</span></span><br><span class="line">    <span class="built_in">set</span> = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 对象不存在，创建一个新的，并将它关联到数据库</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">set</span> = setTypeCreate(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="built_in">set</span>);</span><br><span class="line">    <span class="comment">// 对象存在，检查类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;type != REDIS_SET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将所有输入元素添加到集合中</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        c-&gt;argv[j] = tryObjectEncoding(c-&gt;argv[j]);</span><br><span class="line">        <span class="comment">// 只有元素未存在于集合时，才算一次成功添加</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeAdd(<span class="built_in">set</span>,c-&gt;argv[j])) added++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有至少一个元素被成功添加，那么执行以下程序</span></span><br><span class="line">    <span class="keyword">if</span> (added) &#123;</span><br><span class="line">        <span class="comment">// 发送键修改信号</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_SET,<span class="string">&quot;sadd&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将数据库设为脏</span></span><br><span class="line">    server.dirty += added;</span><br><span class="line">    <span class="comment">// 返回添加元素的数量</span></span><br><span class="line">    addReplyLongLong(c,added);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多态 add 操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 添加成功返回 1 ，如果元素已经存在，返回 0 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setTypeAdd</span><span class="params">(robj *subject, robj *value)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> llval;</span><br><span class="line">    <span class="comment">// 字典</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 将 value 作为键， NULL 作为值，将元素添加到字典中</span></span><br><span class="line">        <span class="keyword">if</span> (dictAdd(subject-&gt;ptr,value,<span class="literal">NULL</span>) == DICT_OK) &#123;</span><br><span class="line">            incrRefCount(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// intset</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_INTSET) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 如果对象的值可以编码为整数的话，那么将对象的值添加到 intset 中</span></span><br><span class="line">        <span class="keyword">if</span> (isObjectRepresentableAsLongLong(value,&amp;llval) == REDIS_OK) &#123;</span><br><span class="line">            <span class="type">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">/* Convert to regular set when the intset contains</span></span><br><span class="line"><span class="comment">                 * too many entries. */</span></span><br><span class="line">                <span class="comment">// 添加成功</span></span><br><span class="line">                <span class="comment">// 检查集合在添加新元素之后是否需要转换为字典</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,REDIS_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果对象的值不能编码为整数，那么将集合从 intset 编码转换为 HT 编码</span></span><br><span class="line">        <span class="comment">// 然后再执行添加操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Failed to get integer from object, convert to regular set. */</span></span><br><span class="line">            setTypeConvert(subject,REDIS_ENCODING_HT);</span><br><span class="line">            <span class="comment">/* The set *was* an intset and this value is not integer</span></span><br><span class="line"><span class="comment">             * encodable, so dictAdd should always work. */</span></span><br><span class="line">            redisAssertWithInfo(<span class="literal">NULL</span>,value,dictAdd(subject-&gt;ptr,value,<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            incrRefCount(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 未知编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加失败，元素已经存在</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="srem——sremCommand"><a href="#srem——sremCommand" class="headerlink" title="srem——sremCommand"></a>srem——sremCommand</h2><p>示例：SREM KEY MEMBER1..MEMBERN</p><ul><li>被成功移除的元素的数量，不包括被忽略的元素。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sremCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="type">int</span> j, deleted = <span class="number">0</span>, keyremoved = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取出集合对象</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,REDIS_SET)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 删除输入的所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 只有元素在集合中时，才算一次成功删除</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeRemove(<span class="built_in">set</span>,c-&gt;argv[j])) &#123;</span><br><span class="line">            deleted++;</span><br><span class="line">            <span class="comment">// 如果集合已经为空，那么删除集合对象</span></span><br><span class="line">            <span class="keyword">if</span> (setTypeSize(<span class="built_in">set</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">                keyremoved = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有至少一个元素被成功删除，那么执行以下程序</span></span><br><span class="line">    <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">        <span class="comment">// 发送键修改信号</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_SET,<span class="string">&quot;srem&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        <span class="keyword">if</span> (keyremoved)</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],</span><br><span class="line">                                c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 将数据库设为脏</span></span><br><span class="line">        server.dirty += deleted;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 将被成功删除元素的数量作为回复</span></span><br><span class="line">    addReplyLongLong(c,deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="smove——smoveCommand"><a href="#smove——smoveCommand" class="headerlink" title="smove——smoveCommand"></a>smove——smoveCommand</h2><p>示例：SMOVE SOURCE DESTINATION MEMBER </p><ul><li>如果成员元素被成功移除，返回 1 。 如果成员元素不是 source 集合的成员，并且没有任何操作对 destination 集合执行，那么返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">smoveCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *srcset, *dstset, *ele;</span><br><span class="line">    <span class="comment">// 取出源集合</span></span><br><span class="line">    srcset = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 取出目标集合</span></span><br><span class="line">    dstset = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 编码元素</span></span><br><span class="line">    ele = c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">/* If the source key does not exist return 0 */</span></span><br><span class="line">    <span class="comment">// 源集合不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (srcset == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If the source key has the wrong type, or the destination key</span></span><br><span class="line"><span class="comment">     * is set and has the wrong type, return with an error. */</span></span><br><span class="line">    <span class="comment">// 如果源集合的类型错误</span></span><br><span class="line">    <span class="comment">// 或者目标集合存在、但是类型错误</span></span><br><span class="line">    <span class="comment">// 那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c,srcset,REDIS_SET) ||</span><br><span class="line">        (dstset &amp;&amp; checkType(c,dstset,REDIS_SET))) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* If srcset and dstset are equal, SMOVE is a no-op */</span></span><br><span class="line">    <span class="comment">// 如果源集合和目标集合相等，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (srcset == dstset) &#123;</span><br><span class="line">        addReply(c,shared.cone);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If the element cannot be removed from the src set, return 0. */</span></span><br><span class="line">    <span class="comment">// 从源集合中移除目标元素</span></span><br><span class="line">    <span class="comment">// 如果目标元素不存在于源集合中，那么直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!setTypeRemove(srcset,ele)) &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_SET,<span class="string">&quot;srem&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">/* Remove the src set from the database when empty */</span></span><br><span class="line">    <span class="comment">// 如果源集合已经为空，那么将它从数据库中删除</span></span><br><span class="line">    <span class="keyword">if</span> (setTypeSize(srcset) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除集合对象</span></span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送键修改信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 将数据库设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">/* Create the destination set when it doesn&#x27;t exist */</span></span><br><span class="line">    <span class="comment">// 如果目标集合不存在，那么创建它</span></span><br><span class="line">    <span class="keyword">if</span> (!dstset) &#123;</span><br><span class="line">        dstset = setTypeCreate(ele);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">2</span>],dstset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* An extra key has changed when ele was successfully added to dstset */</span></span><br><span class="line">    <span class="comment">// 将元素添加到目标集合</span></span><br><span class="line">    <span class="keyword">if</span> (setTypeAdd(dstset,ele)) &#123;</span><br><span class="line">        <span class="comment">// 将数据库设为脏</span></span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_SET,<span class="string">&quot;sadd&quot;</span>,c-&gt;argv[<span class="number">2</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回复 1</span></span><br><span class="line">    addReply(c,shared.cone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sismember——sismemberCommand"><a href="#sismember——sismemberCommand" class="headerlink" title="sismember——sismemberCommand"></a>sismember——sismemberCommand</h2><p>示例：SISMEMBER KEY VALUE</p><ul><li>如果成员元素是集合的成员，返回 1 。 如果成员元素不是集合的成员，或 key 不存在，返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sismemberCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">// 取出集合对象</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,REDIS_SET)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 编码输入元素</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 检查是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (setTypeIsMember(<span class="built_in">set</span>,c-&gt;argv[<span class="number">2</span>]))</span><br><span class="line">        addReply(c,shared.cone);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多态 ismember 操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setTypeIsMember</span><span class="params">(robj *subject, robj *value)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> llval;</span><br><span class="line">    <span class="comment">// HT</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        <span class="keyword">return</span> dictFind((dict*)subject-&gt;ptr,value) != <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// INTSET</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isObjectRepresentableAsLongLong(value,&amp;llval) == REDIS_OK) &#123;</span><br><span class="line">            <span class="keyword">return</span> intsetFind((intset*)subject-&gt;ptr,llval);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 未知编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scard——scardCommand"><a href="#scard——scardCommand" class="headerlink" title="scard——scardCommand"></a>scard——scardCommand</h2><p>示例：SCARD KEY_NAME </p><ul><li>集合的数量。 当集合 key 不存在时，返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">scardCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 取出集合</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_SET)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 返回集合的基数</span></span><br><span class="line">    addReplyLongLong(c,setTypeSize(o));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 集合多态 size 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">setTypeSize</span><span class="params">(robj *subject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        <span class="keyword">return</span> dictSize((dict*)subject-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_INTSET) &#123;</span><br><span class="line">        <span class="keyword">return</span> intsetLen((intset*)subject-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="spop——spopCommand"><a href="#spop——spopCommand" class="headerlink" title="spop——spopCommand"></a>spop——spopCommand</h2><p>示例：SPOP KEY </p><ul><li>被移除的随机元素。 当集合不存在或是空集时，返回 nil 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">spopCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *<span class="built_in">set</span>, *ele, *aux;</span><br><span class="line">    <span class="type">int64_t</span> llele;</span><br><span class="line">    <span class="type">int</span> encoding;</span><br><span class="line">    <span class="comment">// 取出集合</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,REDIS_SET)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 从集合中随机取出一个元素</span></span><br><span class="line">    encoding = setTypeRandomElement(<span class="built_in">set</span>,&amp;ele,&amp;llele);</span><br><span class="line">    <span class="comment">// 将被取出元素从集合中删除</span></span><br><span class="line">    <span class="keyword">if</span> (encoding == REDIS_ENCODING_INTSET) &#123;</span><br><span class="line">        ele = createStringObjectFromLongLong(llele);</span><br><span class="line">        <span class="built_in">set</span>-&gt;ptr = intsetRemove(<span class="built_in">set</span>-&gt;ptr,llele,<span class="literal">NULL</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        incrRefCount(ele);</span><br><span class="line">        setTypeRemove(<span class="built_in">set</span>,ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_SET,<span class="string">&quot;spop&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">/* Replicate/AOF this command as an SREM operation */</span></span><br><span class="line">    <span class="comment">// 将这个命令当作 SREM 来传播，防止产生有害的随机性，导致数据不一致</span></span><br><span class="line">    <span class="comment">// （不同的服务器随机删除不同的元素）</span></span><br><span class="line">    aux = createStringObject(<span class="string">&quot;SREM&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    rewriteClientCommandVector(c,<span class="number">3</span>,aux,c-&gt;argv[<span class="number">1</span>],ele);</span><br><span class="line">    decrRefCount(ele);</span><br><span class="line">    decrRefCount(aux);</span><br><span class="line">    <span class="comment">// 返回回复</span></span><br><span class="line">    addReplyBulk(c,ele);</span><br><span class="line">    <span class="comment">// 如果集合已经为空，那么从数据库中删除它</span></span><br><span class="line">    <span class="keyword">if</span> (setTypeSize(<span class="built_in">set</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除集合</span></span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送键修改信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 将数据库设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setTypeRandomElement</span><span class="params">(robj *setobj, robj **objele, <span class="type">int64_t</span> *llele)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (setobj-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        dictEntry *de = dictGetRandomKey(setobj-&gt;ptr);</span><br><span class="line">        *objele = dictGetKey(de);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setobj-&gt;encoding == REDIS_ENCODING_INTSET) &#123;</span><br><span class="line">        *llele = intsetRandom(setobj-&gt;ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown set encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setobj-&gt;encoding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="srandmember——srandmemberCommand"><a href="#srandmember——srandmemberCommand" class="headerlink" title="srandmember——srandmemberCommand"></a>srandmember——srandmemberCommand</h2><p>示例：SRANDMEMBER KEY [count]</p><ul><li>只提供集合 key 参数时，返回一个元素；如果集合为空，返回 nil 。 如果提供了 count 参数，那么返回一个数组；如果集合为空，返回空数组。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">srandmemberCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *<span class="built_in">set</span>, *ele;</span><br><span class="line">    <span class="type">int64_t</span> llele;</span><br><span class="line">    <span class="type">int</span> encoding;</span><br><span class="line">    <span class="comment">// 如果带有 count 参数，那么调用 srandmemberWithCountCommand 来处理</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">3</span>) &#123;</span><br><span class="line">        srandmemberWithCountCommand(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 参数错误</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 随机取出单个元素就可以了</span></span><br><span class="line">    <span class="comment">// 取出集合对象</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,REDIS_SET)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 随机取出一个元素</span></span><br><span class="line">    encoding = setTypeRandomElement(<span class="built_in">set</span>,&amp;ele,&amp;llele);</span><br><span class="line">    <span class="comment">// 回复</span></span><br><span class="line">    <span class="keyword">if</span> (encoding == REDIS_ENCODING_INTSET) &#123;</span><br><span class="line">        addReplyBulkLongLong(c,llele);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyBulk(c,ele);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sinter——sinterCommand"><a href="#sinter——sinterCommand" class="headerlink" title="sinter——sinterCommand"></a>sinter——sinterCommand</h2><p>示例：SINTER KEY KEY1..KEYN</p><ul><li>交集成员的列表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sinterCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">sinterGenericCommand</span><span class="params">(redisClient *c, robj **setkeys, <span class="type">unsigned</span> <span class="type">long</span> setnum, robj *dstkey)</span> &#123;</span><br><span class="line">    <span class="comment">// 集合数组</span></span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *eleobj, *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int64_t</span> intobj;</span><br><span class="line">    <span class="type">void</span> *replylen = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> encoding;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        <span class="comment">// 取出对象</span></span><br><span class="line">        <span class="comment">// 第一次执行时，取出的是 dest 集合</span></span><br><span class="line">        <span class="comment">// 之后执行时，取出的都是 source 集合</span></span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="comment">// 对象不存在，放弃执行，进行清理</span></span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dbDelete(c-&gt;db,dstkey)) &#123;</span><br><span class="line">                    signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">                    server.dirty++;</span><br><span class="line">                &#125;</span><br><span class="line">                addReply(c,shared.czero);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReply(c,shared.emptymultibulk);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 检查对象的类型</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,REDIS_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组指针指向集合对象</span></span><br><span class="line">        sets[j] = createSetObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Sort sets from the smallest to largest, this will improve our</span></span><br><span class="line"><span class="comment">     * algorithm&#x27;s performance */</span></span><br><span class="line">    <span class="comment">// 按基数对集合进行排序，这样提升算法的效率</span></span><br><span class="line">    qsort(sets,setnum,<span class="keyword">sizeof</span>(robj*),qsortCompareSetsByCardinality);</span><br><span class="line">    <span class="comment">/* The first thing we should output is the total number of elements...</span></span><br><span class="line"><span class="comment">     * since this is a multi-bulk write, but at this stage we don&#x27;t know</span></span><br><span class="line"><span class="comment">     * the intersection set size, so we use a trick, append an empty object</span></span><br><span class="line"><span class="comment">     * to the output list and save the pointer to later modify it with the</span></span><br><span class="line"><span class="comment">     * right length */</span></span><br><span class="line">    <span class="comment">// 因为不知道结果集会有多少个元素，所有没有办法直接设置回复的数量</span></span><br><span class="line">    <span class="comment">// 这里使用了一个小技巧，直接使用一个 BUFF 列表，</span></span><br><span class="line">    <span class="comment">// 然后将之后的回复都添加到列表中</span></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        replylen = addDeferredMultiBulkLength(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we have a target key where to store the resulting set</span></span><br><span class="line"><span class="comment">         * create this key with an empty set inside */</span></span><br><span class="line">        dstset = createIntsetObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Iterate all the elements of the first (smallest) set, and test</span></span><br><span class="line"><span class="comment">     * the element against all the other sets, if at least one set does</span></span><br><span class="line"><span class="comment">     * not include the element it is discarded */</span></span><br><span class="line">    <span class="comment">// 遍历基数最小的第一个集合</span></span><br><span class="line">    <span class="comment">// 并将它的元素和所有其他集合进行对比</span></span><br><span class="line">    <span class="comment">// 如果有至少一个集合不包含这个元素，那么这个元素不属于交集</span></span><br><span class="line">    si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">while</span>((encoding = setTypeNext(si,&amp;eleobj,&amp;intobj)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历其他集合，检查元素是否在这些集合中存在</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="comment">// 跳过第一个集合，因为它是结果集的起始值</span></span><br><span class="line">            <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 元素的编码为 INTSET</span></span><br><span class="line">            <span class="comment">// 在其他集合中查找这个对象是否存在</span></span><br><span class="line">            <span class="keyword">if</span> (encoding == REDIS_ENCODING_INTSET) &#123;</span><br><span class="line">                <span class="comment">/* intset with intset is simple... and fast */</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j]-&gt;encoding == REDIS_ENCODING_INTSET &amp;&amp;</span><br><span class="line">                    !intsetFind((intset*)sets[j]-&gt;ptr,intobj))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* in order to compare an integer with an object we</span></span><br><span class="line"><span class="comment">                 * have to use the generic function, creating an object</span></span><br><span class="line"><span class="comment">                 * for this */</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sets[j]-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">                    eleobj = createStringObjectFromLongLong(intobj);</span><br><span class="line">                    <span class="keyword">if</span> (!setTypeIsMember(sets[j],eleobj)) &#123;</span><br><span class="line">                        decrRefCount(eleobj);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    decrRefCount(eleobj);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// 元素的编码为 字典</span></span><br><span class="line">            <span class="comment">// 在其他集合中查找这个对象是否存在</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">                <span class="comment">/* Optimization... if the source object is integer</span></span><br><span class="line"><span class="comment">                 * encoded AND the target set is an intset, we can get</span></span><br><span class="line"><span class="comment">                 * a much faster path. */</span></span><br><span class="line">                <span class="keyword">if</span> (eleobj-&gt;encoding == REDIS_ENCODING_INT &amp;&amp;</span><br><span class="line">                    sets[j]-&gt;encoding == REDIS_ENCODING_INTSET &amp;&amp;</span><br><span class="line">                    !intsetFind((intset*)sets[j]-&gt;ptr,(<span class="type">long</span>)eleobj-&gt;ptr))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/* else... object to object check is easy as we use the</span></span><br><span class="line"><span class="comment">                 * type agnostic API here. */</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!setTypeIsMember(sets[j],eleobj)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Only take action when all sets contain the member */</span></span><br><span class="line">        <span class="comment">// 如果所有集合都带有目标元素的话，那么执行以下代码</span></span><br><span class="line">        <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">            <span class="comment">// SINTER 命令，直接返回结果集元素</span></span><br><span class="line">            <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == REDIS_ENCODING_HT)</span><br><span class="line">                    addReplyBulk(c,eleobj);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    addReplyBulkLongLong(c,intobj);</span><br><span class="line">                cardinality++;</span><br><span class="line">            <span class="comment">// SINTERSTORE 命令，将结果添加到结果集中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (encoding == REDIS_ENCODING_INTSET) &#123;</span><br><span class="line">                    eleobj = createStringObjectFromLongLong(intobj);</span><br><span class="line">                    setTypeAdd(dstset,eleobj);</span><br><span class="line">                    decrRefCount(eleobj);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    setTypeAdd(dstset,eleobj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setTypeReleaseIterator(si);</span><br><span class="line">    <span class="comment">// SINTERSTORE 命令，将结果集关联到数据库</span></span><br><span class="line">    <span class="keyword">if</span> (dstkey) &#123;</span><br><span class="line">        <span class="comment">/* Store the resulting set into the target, if the intersection</span></span><br><span class="line"><span class="comment">         * is not an empty set. */</span></span><br><span class="line">        <span class="comment">// 删除现在可能有的 dstkey</span></span><br><span class="line">        <span class="type">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="comment">// 如果结果集非空，那么将它关联到数据库中</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_SET,<span class="string">&quot;sinterstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    <span class="comment">// SINTER 命令，回复结果集的基数</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setDeferredMultiBulkLength(c,replylen,cardinality);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sinterstore——sinterstoreCommand"><a href="#sinterstore——sinterstoreCommand" class="headerlink" title="sinterstore——sinterstoreCommand"></a>sinterstore——sinterstoreCommand</h2><p>示例：SINTERSTORE DESTINATION_KEY KEY KEY1..KEYN </p><ul><li>返回存储交集的集合的元素数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sinterstoreCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sunion——sunionCommand"><a href="#sunion——sunionCommand" class="headerlink" title="sunion——sunionCommand"></a>sunion——sunionCommand</h2><p>示例：SUNION KEY KEY1..KEYN</p><ul><li>并集成员的列表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sunionCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,REDIS_OP_UNION);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 命令的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_OP_UNION 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_OP_DIFF 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_OP_INTER 2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sunionDiffGenericCommand</span><span class="params">(redisClient *c, robj **setkeys, <span class="type">int</span> setnum, robj *dstkey, <span class="type">int</span> op)</span> &#123;</span><br><span class="line">    <span class="comment">// 集合数组</span></span><br><span class="line">    robj **sets = zmalloc(<span class="keyword">sizeof</span>(robj*)*setnum);</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    robj *ele, *dstset = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> j, cardinality = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> diff_algo = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 取出所有集合对象，并添加到集合数组中</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">        robj *setobj = dstkey ?</span><br><span class="line">            lookupKeyWrite(c-&gt;db,setkeys[j]) :</span><br><span class="line">            lookupKeyRead(c-&gt;db,setkeys[j]);</span><br><span class="line">        <span class="comment">// 不存在的集合当作 NULL 来处理</span></span><br><span class="line">        <span class="keyword">if</span> (!setobj) &#123;</span><br><span class="line">            sets[j] = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有对象不是集合，停止执行，进行清理</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,setobj,REDIS_SET)) &#123;</span><br><span class="line">            zfree(sets);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录对象</span></span><br><span class="line">        sets[j] = setobj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Select what DIFF algorithm to use.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 选择使用那个算法来执行计算</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Algorithm 1 is O(N*M) where N is the size of the element first set</span></span><br><span class="line"><span class="comment">     * and M the total number of sets.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法 1 的复杂度为 O(N*M) ，其中 N 为第一个集合的基数，</span></span><br><span class="line"><span class="comment">     * 而 M 则为其他集合的数量。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Algorithm 2 is O(N) where N is the total number of elements in all</span></span><br><span class="line"><span class="comment">     * the sets.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 算法 2 的复杂度为 O(N) ，其中 N 为所有集合中的元素数量总数。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We compute what is the best bet with the current input here.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 程序通过考察输入来决定使用那个算法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (op == REDIS_OP_DIFF &amp;&amp; sets[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> algo_one_work = <span class="number">0</span>, algo_two_work = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历所有集合</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sets[j] == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 计算 setnum 乘以 sets[0] 的基数之积</span></span><br><span class="line">            algo_one_work += setTypeSize(sets[<span class="number">0</span>]);</span><br><span class="line">            <span class="comment">// 计算所有集合的基数之和</span></span><br><span class="line">            algo_two_work += setTypeSize(sets[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Algorithm 1 has better constant times and performs less operations</span></span><br><span class="line"><span class="comment">         * if there are elements in common. Give it some advantage. */</span></span><br><span class="line">        <span class="comment">// 算法 1 的常数比较低，优先考虑算法 1</span></span><br><span class="line">        algo_one_work /= <span class="number">2</span>;</span><br><span class="line">        diff_algo = (algo_one_work &lt;= algo_two_work) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (diff_algo == <span class="number">1</span> &amp;&amp; setnum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/* With algorithm 1 it is better to order the sets to subtract</span></span><br><span class="line"><span class="comment">             * by decreasing size, so that we are more likely to find</span></span><br><span class="line"><span class="comment">             * duplicated elements ASAP. */</span></span><br><span class="line">            <span class="comment">// 如果使用的是算法 1 ，那么最好对 sets[0] 以外的其他集合进行排序</span></span><br><span class="line">            <span class="comment">// 这样有助于优化算法的性能</span></span><br><span class="line">            qsort(sets+<span class="number">1</span>,setnum<span class="number">-1</span>,<span class="keyword">sizeof</span>(robj*),</span><br><span class="line">                qsortCompareSetsByRevCardinality);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We need a temp set object to store our union. If the dstkey</span></span><br><span class="line"><span class="comment">     * is not NULL (that is, we are inside an SUNIONSTORE operation) then</span></span><br><span class="line"><span class="comment">     * this set object will be the resulting object to set into the target key</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 使用一个临时集合来保存结果集，如果程序执行的是 SUNIONSTORE 命令，</span></span><br><span class="line"><span class="comment">     * 那么这个结果将会成为将来的集合值对象。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dstset = createIntsetObject();</span><br><span class="line">    <span class="comment">// 执行的是并集计算</span></span><br><span class="line">    <span class="keyword">if</span> (op == REDIS_OP_UNION) &#123;</span><br><span class="line">        <span class="comment">/* Union is trivial, just add every element of every set to the</span></span><br><span class="line"><span class="comment">         * temporary set. */</span></span><br><span class="line">        <span class="comment">// 遍历所有集合，将元素添加到结果集里就可以了</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// setTypeAdd 只在集合不存在时，才会将元素添加到集合，并返回 1</span></span><br><span class="line">                <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                decrRefCount(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 执行的是差集计算，并且使用算法 1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == REDIS_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">/* DIFF Algorithm 1:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 差集算法 1 ：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * We perform the diff by iterating all the elements of the first set,</span></span><br><span class="line"><span class="comment">         * and only adding it to the target set if the element does not exist</span></span><br><span class="line"><span class="comment">         * into all the other sets.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 程序遍历 sets[0] 集合中的所有元素，</span></span><br><span class="line"><span class="comment">         * 并将这个元素和其他集合的所有元素进行对比，</span></span><br><span class="line"><span class="comment">         * 只有这个元素不存在于其他所有集合时，</span></span><br><span class="line"><span class="comment">         * 才将这个元素添加到结果集。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This way we perform at max N*M operations, where N is the size of</span></span><br><span class="line"><span class="comment">         * the first set, and M the number of sets.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 这个算法执行最多 N*M 步， N 是第一个集合的基数，</span></span><br><span class="line"><span class="comment">         * 而 M 是其他集合的数量。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        si = setTypeInitIterator(sets[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 检查元素在其他集合是否存在</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* no key is an empty set. */</span></span><br><span class="line">                <span class="keyword">if</span> (sets[j] == sets[<span class="number">0</span>]) <span class="keyword">break</span>; <span class="comment">/* same set! */</span></span><br><span class="line">                <span class="keyword">if</span> (setTypeIsMember(sets[j],ele)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 只有元素在所有其他集合中都不存在时，才将它添加到结果集中</span></span><br><span class="line">            <span class="keyword">if</span> (j == setnum) &#123;</span><br><span class="line">                <span class="comment">/* There is no other set with this element. Add it. */</span></span><br><span class="line">                setTypeAdd(dstset,ele);</span><br><span class="line">                cardinality++;</span><br><span class="line">            &#125;</span><br><span class="line">            decrRefCount(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">    <span class="comment">// 执行的是差集计算，并且使用算法 2</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == REDIS_OP_DIFF &amp;&amp; sets[<span class="number">0</span>] &amp;&amp; diff_algo == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* DIFF Algorithm 2:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 差集算法 2 ：</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Add all the elements of the first set to the auxiliary set.</span></span><br><span class="line"><span class="comment">         * Then remove all the elements of all the next sets from it.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 将 sets[0] 的所有元素都添加到结果集中，</span></span><br><span class="line"><span class="comment">         * 然后遍历其他所有集合，将相同的元素从结果集中删除。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This is O(N) where N is the sum of all the elements in every set.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 算法复杂度为 O(N) ，N 为所有集合的基数之和。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; setnum; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!sets[j]) <span class="keyword">continue</span>; <span class="comment">/* non existing keys are like empty sets */</span></span><br><span class="line">            si = setTypeInitIterator(sets[j]);</span><br><span class="line">            <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// sets[0] 时，将所有元素添加到集合</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (setTypeAdd(dstset,ele)) cardinality++;</span><br><span class="line">                <span class="comment">// 不是 sets[0] 时，将所有集合从结果集中移除</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (setTypeRemove(dstset,ele)) cardinality--;</span><br><span class="line">                &#125;</span><br><span class="line">                decrRefCount(ele);</span><br><span class="line">            &#125;</span><br><span class="line">            setTypeReleaseIterator(si);</span><br><span class="line">            <span class="comment">/* Exit if result set is empty as any additional removal</span></span><br><span class="line"><span class="comment">             * of elements will have no effect. */</span></span><br><span class="line">            <span class="keyword">if</span> (cardinality == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Output the content of the resulting set, if not in STORE mode */</span></span><br><span class="line">    <span class="comment">// 执行的是 SDIFF 或者 SUNION</span></span><br><span class="line">    <span class="comment">// 打印结果集中的所有元素</span></span><br><span class="line">    <span class="keyword">if</span> (!dstkey) &#123;</span><br><span class="line">        addReplyMultiBulkLen(c,cardinality);</span><br><span class="line">        <span class="comment">// 遍历并回复结果集中的元素</span></span><br><span class="line">        si = setTypeInitIterator(dstset);</span><br><span class="line">        <span class="keyword">while</span>((ele = setTypeNextObject(si)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReplyBulk(c,ele);</span><br><span class="line">            decrRefCount(ele);</span><br><span class="line">        &#125;</span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line">        decrRefCount(dstset);</span><br><span class="line">    <span class="comment">// 执行的是 SDIFFSTORE 或者 SUNIONSTORE</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If we have a target key where to store the resulting set</span></span><br><span class="line"><span class="comment">         * create this key with the result set inside */</span></span><br><span class="line">        <span class="comment">// 现删除现在可能有的 dstkey</span></span><br><span class="line">        <span class="type">int</span> deleted = dbDelete(c-&gt;db,dstkey);</span><br><span class="line">        <span class="comment">// 如果结果集不为空，将它关联到数据库中</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeSize(dstset) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dbAdd(c-&gt;db,dstkey,dstset);</span><br><span class="line">            <span class="comment">// 返回结果集的基数</span></span><br><span class="line">            addReplyLongLong(c,setTypeSize(dstset));</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_SET,</span><br><span class="line">                op == REDIS_OP_UNION ? <span class="string">&quot;sunionstore&quot;</span> : <span class="string">&quot;sdiffstore&quot;</span>,</span><br><span class="line">                dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 结果集为空</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            decrRefCount(dstset);</span><br><span class="line">            <span class="comment">// 返回 0</span></span><br><span class="line">            addReply(c,shared.czero);</span><br><span class="line">            <span class="keyword">if</span> (deleted)</span><br><span class="line">                notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                    dstkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,dstkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(sets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sunionstore——sunionstoreCommand"><a href="#sunionstore——sunionstoreCommand" class="headerlink" title="sunionstore——sunionstoreCommand"></a>sunionstore——sunionstoreCommand</h2><p>示例：SUNIONSTORE DESTINATION KEY KEY1..KEYN</p><ul><li>结果集中的元素数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sunionstoreCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],REDIS_OP_UNION);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sdiff——sdiffCommand"><a href="#sdiff——sdiffCommand" class="headerlink" title="sdiff——sdiffCommand"></a>sdiff——sdiffCommand</h2><p>示例：SDIFF FIRST_KEY OTHER_KEY1..OTHER_KEYN </p><ul><li>包含差集成员的列表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdiffCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>,REDIS_OP_DIFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sdiffstore——sdiffstoreCommand"><a href="#sdiffstore——sdiffstoreCommand" class="headerlink" title="sdiffstore——sdiffstoreCommand"></a>sdiffstore——sdiffstoreCommand</h2><p>示例：SDIFFSTORE DESTINATION_KEY KEY1..KEYN </p><ul><li>结果集中的元素数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sdiffstoreCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    sunionDiffGenericCommand(c,c-&gt;argv+<span class="number">2</span>,c-&gt;argc<span class="number">-2</span>,c-&gt;argv[<span class="number">1</span>],REDIS_OP_DIFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="smembers——sinterCommand"><a href="#smembers——sinterCommand" class="headerlink" title="smembers——sinterCommand"></a>smembers——sinterCommand</h2><p>示例：SMEMBERS key</p><ul><li>集合中的所有成员。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sinterCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    sinterGenericCommand(c,c-&gt;argv+<span class="number">1</span>,c-&gt;argc<span class="number">-1</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sscan——sscanCommand"><a href="#sscan——sscanCommand" class="headerlink" title="sscan——sscanCommand"></a>sscan——sscanCommand</h2><p>示例：SSCAN key cursor [MATCH pattern] [COUNT count]</p><ul><li>数组列表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sscanCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (parseScanCursorOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;cursor) == REDIS_ERR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptyscan)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,REDIS_SET)) <span class="keyword">return</span>;</span><br><span class="line">    scanGenericCommand(c,<span class="built_in">set</span>,cursor);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* This command implements SCAN, HSCAN and SSCAN commands.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这是 SCAN 、 HSCAN 、 SSCAN 命令的实现函数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If object &#x27;o&#x27; is passed, then it must be a Hash or Set object, otherwise</span></span><br><span class="line"><span class="comment"> * if &#x27;o&#x27; is NULL the command will operate on the dictionary associated with</span></span><br><span class="line"><span class="comment"> * the current database.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果给定了对象 o ，那么它必须是一个哈希对象或者集合对象，</span></span><br><span class="line"><span class="comment"> * 如果 o 为 NULL 的话，函数将使用当前数据库作为迭代对象。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When &#x27;o&#x27; is not NULL the function assumes that the first argument in</span></span><br><span class="line"><span class="comment"> * the client arguments vector is a key so it skips it before iterating</span></span><br><span class="line"><span class="comment"> * in order to parse options.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果参数 o 不为 NULL ，那么说明它是一个键对象，函数将跳过这些键对象，</span></span><br><span class="line"><span class="comment"> * 对给定的命令选项进行分析（parse）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In the case of a Hash object the function returns both the field and value</span></span><br><span class="line"><span class="comment"> * of every element on the Hash.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果被迭代的是哈希对象，那么函数返回的是键值对。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">scanGenericCommand</span><span class="params">(redisClient *c, robj *o, <span class="type">unsigned</span> <span class="type">long</span> cursor)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">char</span> buf[REDIS_LONGSTR_SIZE];</span><br><span class="line">    <span class="built_in">list</span> *keys = listCreate();</span><br><span class="line">    listNode *node, *nextnode;</span><br><span class="line">    <span class="type">long</span> count = <span class="number">10</span>;</span><br><span class="line">    sds pat;</span><br><span class="line">    <span class="type">int</span> patlen, use_pattern = <span class="number">0</span>;</span><br><span class="line">    dict *ht;</span><br><span class="line">    <span class="comment">/* Object must be NULL (to iterate keys names), or the type of the object</span></span><br><span class="line"><span class="comment">     * must be Set, Sorted Set, or Hash. */</span></span><br><span class="line">    <span class="comment">// 输入类型检查</span></span><br><span class="line">    redisAssert(o == <span class="literal">NULL</span> || o-&gt;type == REDIS_SET || o-&gt;type == REDIS_HASH ||</span><br><span class="line">                o-&gt;type == REDIS_ZSET);</span><br><span class="line">    <span class="comment">/* Set i to the first option argument. The previous one is the cursor. */</span></span><br><span class="line">    <span class="comment">// 设置第一个选项参数的索引位置</span></span><br><span class="line">    <span class="comment">// 0    1      2      3 </span></span><br><span class="line">    <span class="comment">// SCAN OPTION &lt;op_arg&gt;         SCAN 命令的选项值从索引 2 开始</span></span><br><span class="line">    <span class="comment">// HSCAN &lt;key&gt; OPTION &lt;op_arg&gt;  而其他 *SCAN 命令的选项值从索引 3 开始</span></span><br><span class="line">    i = (o == <span class="literal">NULL</span>) ? <span class="number">2</span> : <span class="number">3</span>; <span class="comment">/* Skip the key argument if needed. */</span></span><br><span class="line">    <span class="comment">/* Step 1: Parse options. */</span></span><br><span class="line">    <span class="comment">// 分析选项参数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; c-&gt;argc) &#123;</span><br><span class="line">        j = c-&gt;argc - i;</span><br><span class="line">        <span class="comment">// COUNT &lt;number&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">&quot;count&quot;</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getLongFromObjectOrReply(c, c-&gt;argv[i+<span class="number">1</span>], &amp;count, <span class="literal">NULL</span>)</span><br><span class="line">                != REDIS_OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// MATCH &lt;pattern&gt;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">&quot;match&quot;</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            pat = c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">            patlen = sdslen(pat);</span><br><span class="line">            <span class="comment">/* The pattern always matches if it is exactly &quot;*&quot;, so it is</span></span><br><span class="line"><span class="comment">             * equivalent to disabling it. */</span></span><br><span class="line">            use_pattern = !(pat[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; patlen == <span class="number">1</span>);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Iterate the collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that if the object is encoded with a ziplist, intset, or any other</span></span><br><span class="line"><span class="comment">     * representation that is not a hash table, we are sure that it is also</span></span><br><span class="line"><span class="comment">     * composed of a small number of elements. So to avoid taking state we</span></span><br><span class="line"><span class="comment">     * just return everything inside the object in a single call, setting the</span></span><br><span class="line"><span class="comment">     * cursor to zero to signal the end of the iteration. */</span></span><br><span class="line">     <span class="comment">// 如果对象的底层实现为 ziplist 、intset 而不是哈希表，</span></span><br><span class="line">     <span class="comment">// 那么这些对象应该只包含了少量元素，</span></span><br><span class="line">     <span class="comment">// 为了保持不让服务器记录迭代状态的设计</span></span><br><span class="line">     <span class="comment">// 我们将 ziplist 或者 intset 里面的所有元素都一次返回给调用者</span></span><br><span class="line">     <span class="comment">// 并向调用者返回游标（cursor） 0</span></span><br><span class="line">    <span class="comment">/* Handle the case of a hash table. */</span></span><br><span class="line">    ht = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 迭代目标为数据库</span></span><br><span class="line">        ht = c-&gt;db-&gt;dict;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET &amp;&amp; o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 迭代目标为 HT 编码的集合</span></span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH &amp;&amp; o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 迭代目标为 HT 编码的哈希</span></span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_ZSET &amp;&amp; o-&gt;encoding == REDIS_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="comment">// 迭代目标为 HT 编码的跳跃表</span></span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        ht = zs-&gt;dict;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ht) &#123;</span><br><span class="line">        <span class="type">void</span> *privdata[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/* We pass two pointers to the callback: the list to which it will</span></span><br><span class="line"><span class="comment">         * add new elements, and the object containing the dictionary so that</span></span><br><span class="line"><span class="comment">         * it is possible to fetch more data in a type-dependent way. */</span></span><br><span class="line">        <span class="comment">// 我们向回调函数传入两个指针：</span></span><br><span class="line">        <span class="comment">// 一个是用于记录被迭代元素的列表</span></span><br><span class="line">        <span class="comment">// 另一个是字典对象</span></span><br><span class="line">        <span class="comment">// 从而实现类型无关的数据提取操作</span></span><br><span class="line">        privdata[<span class="number">0</span>] = keys;</span><br><span class="line">        privdata[<span class="number">1</span>] = o;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            cursor = dictScan(ht, cursor, scanCallback, privdata);</span><br><span class="line">        &#125; <span class="keyword">while</span> (cursor &amp;&amp; listLength(keys) &lt; count);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET) &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int64_t</span> ll;</span><br><span class="line">        <span class="keyword">while</span>(intsetGet(o-&gt;ptr,pos++,&amp;ll))</span><br><span class="line">            listAddNodeTail(keys,createStringObjectFromLongLong(ll));</span><br><span class="line">        cursor = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH || o-&gt;type == REDIS_ZSET) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *p = ziplistIndex(o-&gt;ptr,<span class="number">0</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *vstr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vlen;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> vll;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vll);</span><br><span class="line">            listAddNodeTail(keys,</span><br><span class="line">                (vstr != <span class="literal">NULL</span>) ? createStringObject((<span class="type">char</span>*)vstr,vlen) :</span><br><span class="line">                                 createStringObjectFromLongLong(vll));</span><br><span class="line">            p = ziplistNext(o-&gt;ptr,p);</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Not handled encoding in SCAN.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: Filter elements. */</span></span><br><span class="line">    node = listFirst(keys);</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        nextnode = listNextNode(node);</span><br><span class="line">        <span class="type">int</span> filter = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Filter element if it does not match the pattern. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; use_pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sdsEncodedObject(kobj)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stringmatchlen(pat, patlen, kobj-&gt;ptr, sdslen(kobj-&gt;ptr), <span class="number">0</span>))</span><br><span class="line">                    filter = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">char</span> buf[REDIS_LONGSTR_SIZE];</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                redisAssert(kobj-&gt;encoding == REDIS_ENCODING_INT);</span><br><span class="line">                len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="type">long</span>)kobj-&gt;ptr);</span><br><span class="line">                <span class="keyword">if</span> (!stringmatchlen(pat, patlen, buf, len, <span class="number">0</span>)) filter = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Filter element if it is an expired key. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; expireIfNeeded(c-&gt;db, kobj)) filter = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* Remove the element and its associted value if needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">            decrRefCount(kobj);</span><br><span class="line">            listDelNode(keys, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* If this is a hash or a sorted set, we have a flat list of</span></span><br><span class="line"><span class="comment">         * key-value elements, so if this element was filtered, remove the</span></span><br><span class="line"><span class="comment">         * value, or skip it if it was not filtered: we only match keys. */</span></span><br><span class="line">        <span class="keyword">if</span> (o &amp;&amp; (o-&gt;type == REDIS_ZSET || o-&gt;type == REDIS_HASH)) &#123;</span><br><span class="line">            node = nextnode;</span><br><span class="line">            nextnode = listNextNode(node);</span><br><span class="line">            <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">                kobj = listNodeValue(node);</span><br><span class="line">                decrRefCount(kobj);</span><br><span class="line">                listDelNode(keys, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = nextnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: Reply to the client. */</span></span><br><span class="line">    addReplyMultiBulkLen(c, <span class="number">2</span>);</span><br><span class="line">    rv = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%lu&quot;</span>, cursor);</span><br><span class="line">    redisAssert(rv &lt; <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    addReplyBulkCBuffer(c, buf, rv);</span><br><span class="line">    addReplyMultiBulkLen(c, listLength(keys));</span><br><span class="line">    <span class="keyword">while</span> ((node = listFirst(keys)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        addReplyBulk(c, kobj);</span><br><span class="line">        decrRefCount(kobj);</span><br><span class="line">        listDelNode(keys, node);</span><br><span class="line">    &#125;</span><br><span class="line">cleanup:</span><br><span class="line">    listSetFreeMethod(keys,decrRefCountVoid);</span><br><span class="line">    listRelease(keys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th><th>intset编码时间复杂度</th><th>hashtable编码时间复杂度</th></tr></thead><tbody><tr><td>SADD</td><td>将一个或多个 <code>member</code> 元素加入到集合 <code>key</code> 当中</td><td>O(N)</td><td>O(1)</td></tr><tr><td>SCARD</td><td>返回指定集合所包含的元素数量</td><td>O(1)</td><td>O(1)</td></tr><tr><td>SISMEMBER</td><td>判断元素是否是指定集合中的成员</td><td>O(log(n))</td><td>O(1)</td></tr><tr><td>SMEMBERS</td><td>返回指定集合的所有成员</td><td>O(n)</td><td>O(n)</td></tr><tr><td>SRANDMEMBER</td><td>返回指定集合的count个随机成员</td><td>O(1)</td><td>O(1)</td></tr><tr><td>SPOP</td><td>移除并返回指定集合中的一个随机元素</td><td>O(N)</td><td>O(1)</td></tr><tr><td>SREM</td><td>移除指定集合中一个或者多个元素</td><td>O(N)</td><td>O(1)</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis-源码学习-hash</title>
      <link href="/p/57262336.html"/>
      <url>/p/57262336.html</url>
      
        <content type="html"><![CDATA[<p>基础的hash相关的命令,<code>t_hash.c</code></p><span id="more"></span><h2 id="hset——hsetCommand"><a href="#hset——hsetCommand" class="headerlink" title="hset——hsetCommand"></a>hset——hsetCommand</h2><p>示例：HSET KEY_NAME FIELD VALUE </p><ul><li>如果字段是哈希表中的一个新建字段，并且值设置成功，返回 1 。 如果哈希表中域字段已经存在且旧值已被新值覆盖，返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hsetCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> update;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 取出或新创建哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果需要的话，转换哈希对象的编码</span></span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 编码 field 和 value 对象以节约空间</span></span><br><span class="line">    hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class="number">2</span>], &amp;c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 设置 field 和 value 到 hash</span></span><br><span class="line">    update = hashTypeSet(o,c-&gt;argv[<span class="number">2</span>],c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="comment">// 返回状态：显示 field-value 对是新添加还是更新</span></span><br><span class="line">    addReply(c, update ? shared.czero : shared.cone);</span><br><span class="line">    <span class="comment">// 发送键修改信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,<span class="string">&quot;hset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 将服务器设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">hashTypeSet</span><span class="params">(robj *o, robj *field, robj *value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> update = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 添加到 ziplist</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *zl, *fptr, *vptr;</span><br><span class="line">        <span class="comment">// 解码成字符串或者数字</span></span><br><span class="line">        field = getDecodedObject(field);</span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        <span class="comment">// 遍历整个 ziplist ，尝试查找并更新 field （如果它已经存在的话）</span></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 定位到域 field</span></span><br><span class="line">            fptr = ziplistFind(fptr, field-&gt;ptr, sdslen(field-&gt;ptr), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Grab pointer to the value (fptr points to the field) */</span></span><br><span class="line">                <span class="comment">// 定位到域的值</span></span><br><span class="line">                vptr = ziplistNext(zl, fptr);</span><br><span class="line">                redisAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 标识这次操作为更新操作</span></span><br><span class="line">                update = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/* Delete value */</span></span><br><span class="line">                <span class="comment">// 删除旧的键值对</span></span><br><span class="line">                zl = ziplistDelete(zl, &amp;vptr);</span><br><span class="line">                <span class="comment">/* Insert new value */</span></span><br><span class="line">                <span class="comment">// 添加新的键值对</span></span><br><span class="line">                zl = ziplistInsert(zl, vptr, value-&gt;ptr, sdslen(value-&gt;ptr));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这不是更新操作，那么这就是一个添加操作</span></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            <span class="comment">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class="line">            <span class="comment">// 将新的 field-value 对推入到 ziplist 的末尾</span></span><br><span class="line">            zl = ziplistPush(zl, field-&gt;ptr, sdslen(field-&gt;ptr), ZIPLIST_TAIL);</span><br><span class="line">            zl = ziplistPush(zl, value-&gt;ptr, sdslen(value-&gt;ptr), ZIPLIST_TAIL);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 更新对象指针</span></span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line">        <span class="comment">// 释放临时对象</span></span><br><span class="line">        decrRefCount(field);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">        <span class="comment">/* Check if the ziplist needs to be converted to a hash table */</span></span><br><span class="line">        <span class="comment">// 检查在添加操作完成之后，是否需要将 ZIPLIST 编码转换成 HT 编码</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class="line">            hashTypeConvert(o, REDIS_ENCODING_HT);</span><br><span class="line">    <span class="comment">// 添加到字典</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 添加或替换键值对到字典</span></span><br><span class="line">        <span class="comment">// 添加返回 1 ，替换返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (dictReplace(o-&gt;ptr, field, value)) &#123; <span class="comment">/* Insert */</span></span><br><span class="line">            incrRefCount(field);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* Update */</span></span><br><span class="line">            update = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        incrRefCount(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown hash encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新/添加指示变量</span></span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hsetnx——hsetnxCommand"><a href="#hsetnx——hsetnxCommand" class="headerlink" title="hsetnx——hsetnxCommand"></a>hsetnx——hsetnxCommand</h2><p>示例：HSETNX KEY_NAME FIELD VALUE</p><ul><li>设置成功，返回 1 。 如果给定字段已经存在且没有操作被执行，返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hsetnxCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 取出或新创建哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果需要的话，转换哈希对象的编码</span></span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 如果 field-value 对已经存在</span></span><br><span class="line">    <span class="comment">// 那么回复 0</span></span><br><span class="line">    <span class="keyword">if</span> (hashTypeExists(o, c-&gt;argv[<span class="number">2</span>])) &#123;</span><br><span class="line">        addReply(c, shared.czero);</span><br><span class="line">    <span class="comment">// 否则，设置 field-value 对</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对 field 和 value 对象编码，以节省空间</span></span><br><span class="line">        hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class="number">2</span>], &amp;c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">        <span class="comment">// 设置</span></span><br><span class="line">        hashTypeSet(o,c-&gt;argv[<span class="number">2</span>],c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">        <span class="comment">// 回复 1 ，表示设置成功</span></span><br><span class="line">        addReply(c, shared.cone);</span><br><span class="line">        <span class="comment">// 发送键修改信号</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_HASH,<span class="string">&quot;hset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 将数据库设为脏</span></span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hget——hgetCommand"><a href="#hget——hgetCommand" class="headerlink" title="hget——hgetCommand"></a>hget——hgetCommand</h2><p>示例：HGET KEY_NAME FIELD_NAME </p><ul><li>返回给定字段的值。如果给定的字段或 key 不存在时，返回 nil 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hgetCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_HASH)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出并返回域的值</span></span><br><span class="line">    addHashFieldToReply(c, o, c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hmset——hmsetCommand"><a href="#hmset——hmsetCommand" class="headerlink" title="hmset——hmsetCommand"></a>hmset——hmsetCommand</h2><p>示例：HMSET KEY_NAME FIELD1 VALUE1 …FIELDN VALUEN </p><ul><li>如果命令执行成功，返回 OK 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hmsetCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// field-value 参数必须成对出现</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;wrong number of arguments for HMSET&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取出或新创建哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果需要的话，转换哈希对象的编码</span></span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 遍历并设置所有 field-value 对</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 编码 field-value 对，以节约空间</span></span><br><span class="line">        hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[i], &amp;c-&gt;argv[i+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 设置</span></span><br><span class="line">        hashTypeSet(o,c-&gt;argv[i],c-&gt;argv[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向客户端发送回复</span></span><br><span class="line">    addReply(c, shared.ok);</span><br><span class="line">    <span class="comment">// 发送键修改信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,<span class="string">&quot;hset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 将数据库设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hmget——hmgetCommand"><a href="#hmget——hmgetCommand" class="headerlink" title="hmget——hmgetCommand"></a>hmget——hmgetCommand</h2><p>示例：HMGET KEY_NAME FIELD1…FIELDN </p><ul><li>一个包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hmgetCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* Don&#x27;t abort when the key cannot be found. Non-existing keys are empty</span></span><br><span class="line"><span class="comment">     * hashes, where HMGET should respond with a series of null bulks. */</span></span><br><span class="line">    <span class="comment">// 取出哈希对象</span></span><br><span class="line">    o = lookupKeyRead(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 对象存在，检查类型</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; o-&gt;type != REDIS_HASH) &#123;</span><br><span class="line">        addReply(c, shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取多个 field 的值</span></span><br><span class="line">    addReplyMultiBulkLen(c, c-&gt;argc<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i++) &#123;</span><br><span class="line">        addHashFieldToReply(c, o, c-&gt;argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hincrby——hincrbyCommand"><a href="#hincrby——hincrbyCommand" class="headerlink" title="hincrby——hincrbyCommand"></a>hincrby——hincrbyCommand</h2><p>示例：HINCRBY KEY_NAME FIELD_NAME INCR_BY_NUMBER </p><ul><li>执行 HINCRBY 命令之后，哈希表中字段的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hincrbyCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> value, incr, oldvalue;</span><br><span class="line">    robj *o, *current, *new;</span><br><span class="line">    <span class="comment">// 取出 incr 参数的值，并创建对象</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;incr,<span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出或新创建哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出 field 的当前值</span></span><br><span class="line">    <span class="keyword">if</span> ((current = hashTypeGetObject(o,c-&gt;argv[<span class="number">2</span>])) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 取出值的整数表示</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,current,&amp;value,</span><br><span class="line">            <span class="string">&quot;hash value is not an integer&quot;</span>) != REDIS_OK) &#123;</span><br><span class="line">            decrRefCount(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果值当前不存在，那么默认为 0</span></span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查计算是否会造成溢出</span></span><br><span class="line">    oldvalue = value;</span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; oldvalue &lt; <span class="number">0</span> &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</span><br><span class="line">        (incr &gt; <span class="number">0</span> &amp;&amp; oldvalue &gt; <span class="number">0</span> &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;increment or decrement would overflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    value += incr;</span><br><span class="line">    <span class="comment">// 为结果创建新的值对象</span></span><br><span class="line">    new = createStringObjectFromLongLong(value);</span><br><span class="line">    <span class="comment">// 编码值对象</span></span><br><span class="line">    hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 关联键和新的值对象，如果已经有对象存在，那么用新对象替换它</span></span><br><span class="line">    hashTypeSet(o,c-&gt;argv[<span class="number">2</span>],new);</span><br><span class="line">    decrRefCount(new);</span><br><span class="line">    <span class="comment">// 将计算结果用作回复</span></span><br><span class="line">    addReplyLongLong(c,value);</span><br><span class="line">    <span class="comment">// 发送键修改信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,<span class="string">&quot;hincrby&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 将数据库设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hincrbyfloat——hincrbyfloatCommand"><a href="#hincrbyfloat——hincrbyfloatCommand" class="headerlink" title="hincrbyfloat——hincrbyfloatCommand"></a>hincrbyfloat——hincrbyfloatCommand</h2><p>示例：HINCRBYFLOAT KEY_NAME FIELD_NAME INCR_BY_NUMBER </p><ul><li>执行 Hincrbyfloat 命令之后，哈希表中字段的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hincrbyfloatCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="type">long</span> value, incr;</span><br><span class="line">    robj *o, *current, *new, *aux;</span><br><span class="line">    <span class="comment">// 取出 incr 参数</span></span><br><span class="line">    <span class="keyword">if</span> (getLongDoubleFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;incr,<span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出或新创建哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出值对象</span></span><br><span class="line">    <span class="keyword">if</span> ((current = hashTypeGetObject(o,c-&gt;argv[<span class="number">2</span>])) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 从值对象中取出浮点值</span></span><br><span class="line">        <span class="keyword">if</span> (getLongDoubleFromObjectOrReply(c,current,&amp;value,</span><br><span class="line">            <span class="string">&quot;hash value is not a valid float&quot;</span>) != REDIS_OK) &#123;</span><br><span class="line">            decrRefCount(current);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        decrRefCount(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 值对象不存在，默认值为 0</span></span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算结果</span></span><br><span class="line">    value += incr;</span><br><span class="line">    <span class="comment">// 为计算结果创建值对象</span></span><br><span class="line">    new = createStringObjectFromLongDouble(value);</span><br><span class="line">    <span class="comment">// 编码值对象</span></span><br><span class="line">    hashTypeTryObjectEncoding(o,&amp;c-&gt;argv[<span class="number">2</span>],<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 关联键和新的值对象，如果已经有对象存在，那么用新对象替换它</span></span><br><span class="line">    hashTypeSet(o,c-&gt;argv[<span class="number">2</span>],new);</span><br><span class="line">    <span class="comment">// 返回新的值对象作为回复</span></span><br><span class="line">    addReplyBulk(c,new);</span><br><span class="line">    <span class="comment">// 发送键修改信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_HASH,<span class="string">&quot;hincrbyfloat&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 将数据库设置脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">/* Always replicate HINCRBYFLOAT as an HSET command with the final value</span></span><br><span class="line"><span class="comment">     * in order to make sure that differences in float pricision or formatting</span></span><br><span class="line"><span class="comment">     * will not create differences in replicas or after an AOF restart. */</span></span><br><span class="line">    <span class="comment">// 在传播 INCRBYFLOAT 命令时，总是用 SET 命令来替换 INCRBYFLOAT 命令</span></span><br><span class="line">    <span class="comment">// 从而防止因为不同的浮点精度和格式化造成 AOF 重启时的数据不一致</span></span><br><span class="line">    aux = createStringObject(<span class="string">&quot;HSET&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    rewriteClientCommandArgument(c,<span class="number">0</span>,aux);</span><br><span class="line">    decrRefCount(aux);</span><br><span class="line">    rewriteClientCommandArgument(c,<span class="number">3</span>,new);</span><br><span class="line">    decrRefCount(new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hdel——hdelCommand"><a href="#hdel——hdelCommand" class="headerlink" title="hdel——hdelCommand"></a>hdel——hdelCommand</h2><p>示例：HDEL KEY_NAME FIELD1.. FIELDN </p><ul><li>被成功删除字段的数量，不包括被忽略的字段。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hdelCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">int</span> j, deleted = <span class="number">0</span>, keyremoved = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取出对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_HASH)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 删除指定域值对</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTypeDelete(o,c-&gt;argv[j])) &#123;</span><br><span class="line">            <span class="comment">// 成功删除一个域值对时进行计数</span></span><br><span class="line">            deleted++;</span><br><span class="line">            <span class="comment">// 如果哈希已经为空，那么删除这个对象</span></span><br><span class="line">            <span class="keyword">if</span> (hashTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">                dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">                keyremoved = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只要有至少一个域值对被修改了，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">        <span class="comment">// 发送键修改信号</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_HASH,<span class="string">&quot;hdel&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        <span class="keyword">if</span> (keyremoved)</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],</span><br><span class="line">                                c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 将数据库设为脏</span></span><br><span class="line">        server.dirty += deleted;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将成功删除的域值对数量作为结果返回给客户端</span></span><br><span class="line">    addReplyLongLong(c,deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hlen——hlenCommand"><a href="#hlen——hlenCommand" class="headerlink" title="hlen——hlenCommand"></a>hlen——hlenCommand</h2><p>示例：HLEN KEY_NAME </p><ul><li>哈希表中字段的数量。 当 key 不存在时，返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hlenCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 取出哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_HASH)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 回复</span></span><br><span class="line">    addReplyLongLong(c,hashTypeLength(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hkeys——hkeysCommand"><a href="#hkeys——hkeysCommand" class="headerlink" title="hkeys——hkeysCommand"></a>hkeys——hkeysCommand</h2><p>示例：HKEYS key </p><ul><li>包含哈希表中所有域（field）列表。 当 key 不存在时，返回一个空列表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hkeysCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    genericHgetallCommand(c,REDIS_HASH_KEY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">genericHgetallCommand</span><span class="params">(redisClient *c, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    hashTypeIterator *hi;</span><br><span class="line">    <span class="type">int</span> multiplier = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length, count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取出哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymultibulk)) == <span class="literal">NULL</span></span><br><span class="line">        || checkType(c,o,REDIS_HASH)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算要取出的元素数量</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; REDIS_HASH_KEY) multiplier++;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; REDIS_HASH_VALUE) multiplier++;</span><br><span class="line">    length = hashTypeLength(o) * multiplier;</span><br><span class="line">    addReplyMultiBulkLen(c, length);</span><br><span class="line">    <span class="comment">// 迭代节点，并取出元素</span></span><br><span class="line">    hi = hashTypeInitIterator(o);</span><br><span class="line">    <span class="keyword">while</span> (hashTypeNext(hi) != REDIS_ERR) &#123;</span><br><span class="line">        <span class="comment">// 取出键</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; REDIS_HASH_KEY) &#123;</span><br><span class="line">            addHashIteratorCursorToReply(c, hi, REDIS_HASH_KEY);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取出值</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; REDIS_HASH_VALUE) &#123;</span><br><span class="line">            addHashIteratorCursorToReply(c, hi, REDIS_HASH_VALUE);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    hashTypeReleaseIterator(hi);</span><br><span class="line">    redisAssert(count == length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hvals——hvalsCommand"><a href="#hvals——hvalsCommand" class="headerlink" title="hvals——hvalsCommand"></a>hvals——hvalsCommand</h2><p>示例：HVALS KEY_NAME</p><ul><li>一个包含哈希表中所有域(field)值的列表。 当 key 不存在时，返回一个空表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hvalsCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    genericHgetallCommand(c,REDIS_HASH_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hgetall——hgetallCommand"><a href="#hgetall——hgetallCommand" class="headerlink" title="hgetall——hgetallCommand"></a>hgetall——hgetallCommand</h2><p>示例：HGETALL KEY_NAME </p><ul><li>以列表形式返回哈希表的字段及字段值。 若 key 不存在，返回空列表。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hgetallCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">   genericHgetallCommand(c,REDIS_HASH_KEY|REDIS_HASH_VALUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hexists——hexistsCommand"><a href="#hexists——hexistsCommand" class="headerlink" title="hexists——hexistsCommand"></a>hexists——hexistsCommand</h2><p>示例：HEXISTS KEY_NAME FIELD_NAME </p><ul><li>如果哈希表含有给定字段，返回 1 。 如果哈希表不含有给定字段，或 key 不存在，返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hexistsCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 取出哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_HASH)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 检查给定域是否存在</span></span><br><span class="line">    addReply(c, hashTypeExists(o,c-&gt;argv[<span class="number">2</span>]) ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hscan——hscanCommand"><a href="#hscan——hscanCommand" class="headerlink" title="hscan——hscanCommand"></a>hscan——hscanCommand</h2><p>示例：HSCAN key cursor [MATCH pattern] [COUNT count]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hscanCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (parseScanCursorOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;cursor) == REDIS_ERR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptyscan)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_HASH)) <span class="keyword">return</span>;</span><br><span class="line">    scanGenericCommand(c,o,cursor);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//db.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">scanGenericCommand</span><span class="params">(redisClient *c, robj *o, <span class="type">unsigned</span> <span class="type">long</span> cursor)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rv;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">char</span> buf[REDIS_LONGSTR_SIZE];</span><br><span class="line">    <span class="built_in">list</span> *keys = listCreate();</span><br><span class="line">    listNode *node, *nextnode;</span><br><span class="line">    <span class="type">long</span> count = <span class="number">10</span>;</span><br><span class="line">    sds pat;</span><br><span class="line">    <span class="type">int</span> patlen, use_pattern = <span class="number">0</span>;</span><br><span class="line">    dict *ht;</span><br><span class="line">    <span class="comment">/* Object must be NULL (to iterate keys names), or the type of the object</span></span><br><span class="line"><span class="comment">     * must be Set, Sorted Set, or Hash. */</span></span><br><span class="line">    <span class="comment">// 输入类型检查</span></span><br><span class="line">    redisAssert(o == <span class="literal">NULL</span> || o-&gt;type == REDIS_SET || o-&gt;type == REDIS_HASH ||</span><br><span class="line">                o-&gt;type == REDIS_ZSET);</span><br><span class="line">    <span class="comment">/* Set i to the first option argument. The previous one is the cursor. */</span></span><br><span class="line">    <span class="comment">// 设置第一个选项参数的索引位置</span></span><br><span class="line">    <span class="comment">// 0    1      2      3 </span></span><br><span class="line">    <span class="comment">// SCAN OPTION &lt;op_arg&gt;         SCAN 命令的选项值从索引 2 开始</span></span><br><span class="line">    <span class="comment">// HSCAN &lt;key&gt; OPTION &lt;op_arg&gt;  而其他 *SCAN 命令的选项值从索引 3 开始</span></span><br><span class="line">    i = (o == <span class="literal">NULL</span>) ? <span class="number">2</span> : <span class="number">3</span>; <span class="comment">/* Skip the key argument if needed. */</span></span><br><span class="line">    <span class="comment">/* Step 1: Parse options. */</span></span><br><span class="line">    <span class="comment">// 分析选项参数</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; c-&gt;argc) &#123;</span><br><span class="line">        j = c-&gt;argc - i;</span><br><span class="line">        <span class="comment">// COUNT &lt;number&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">&quot;count&quot;</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getLongFromObjectOrReply(c, c-&gt;argv[i+<span class="number">1</span>], &amp;count, <span class="literal">NULL</span>)</span><br><span class="line">                != REDIS_OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// MATCH &lt;pattern&gt;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">&quot;match&quot;</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            pat = c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">            patlen = sdslen(pat);</span><br><span class="line">            <span class="comment">/* The pattern always matches if it is exactly &quot;*&quot;, so it is</span></span><br><span class="line"><span class="comment">             * equivalent to disabling it. */</span></span><br><span class="line">            use_pattern = !(pat[<span class="number">0</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; patlen == <span class="number">1</span>);</span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 2: Iterate the collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that if the object is encoded with a ziplist, intset, or any other</span></span><br><span class="line"><span class="comment">     * representation that is not a hash table, we are sure that it is also</span></span><br><span class="line"><span class="comment">     * composed of a small number of elements. So to avoid taking state we</span></span><br><span class="line"><span class="comment">     * just return everything inside the object in a single call, setting the</span></span><br><span class="line"><span class="comment">     * cursor to zero to signal the end of the iteration. */</span></span><br><span class="line">     <span class="comment">// 如果对象的底层实现为 ziplist 、intset 而不是哈希表，</span></span><br><span class="line">     <span class="comment">// 那么这些对象应该只包含了少量元素，</span></span><br><span class="line">     <span class="comment">// 为了保持不让服务器记录迭代状态的设计</span></span><br><span class="line">     <span class="comment">// 我们将 ziplist 或者 intset 里面的所有元素都一次返回给调用者</span></span><br><span class="line">     <span class="comment">// 并向调用者返回游标（cursor） 0</span></span><br><span class="line">    <span class="comment">/* Handle the case of a hash table. */</span></span><br><span class="line">    ht = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 迭代目标为数据库</span></span><br><span class="line">        ht = c-&gt;db-&gt;dict;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET &amp;&amp; o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 迭代目标为 HT 编码的集合</span></span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH &amp;&amp; o-&gt;encoding == REDIS_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 迭代目标为 HT 编码的哈希</span></span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_ZSET &amp;&amp; o-&gt;encoding == REDIS_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="comment">// 迭代目标为 HT 编码的跳跃表</span></span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        ht = zs-&gt;dict;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ht) &#123;</span><br><span class="line">        <span class="type">void</span> *privdata[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/* We pass two pointers to the callback: the list to which it will</span></span><br><span class="line"><span class="comment">         * add new elements, and the object containing the dictionary so that</span></span><br><span class="line"><span class="comment">         * it is possible to fetch more data in a type-dependent way. */</span></span><br><span class="line">        <span class="comment">// 我们向回调函数传入两个指针：</span></span><br><span class="line">        <span class="comment">// 一个是用于记录被迭代元素的列表</span></span><br><span class="line">        <span class="comment">// 另一个是字典对象</span></span><br><span class="line">        <span class="comment">// 从而实现类型无关的数据提取操作</span></span><br><span class="line">        privdata[<span class="number">0</span>] = keys;</span><br><span class="line">        privdata[<span class="number">1</span>] = o;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            cursor = dictScan(ht, cursor, scanCallback, privdata);</span><br><span class="line">        &#125; <span class="keyword">while</span> (cursor &amp;&amp; listLength(keys) &lt; count);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_SET) &#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int64_t</span> ll;</span><br><span class="line">        <span class="keyword">while</span>(intsetGet(o-&gt;ptr,pos++,&amp;ll))</span><br><span class="line">            listAddNodeTail(keys,createStringObjectFromLongLong(ll));</span><br><span class="line">        cursor = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == REDIS_HASH || o-&gt;type == REDIS_ZSET) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *p = ziplistIndex(o-&gt;ptr,<span class="number">0</span>);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *vstr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vlen;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> vll;</span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vll);</span><br><span class="line">            listAddNodeTail(keys,</span><br><span class="line">                (vstr != <span class="literal">NULL</span>) ? createStringObject((<span class="type">char</span>*)vstr,vlen) :</span><br><span class="line">                                 createStringObjectFromLongLong(vll));</span><br><span class="line">            p = ziplistNext(o-&gt;ptr,p);</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Not handled encoding in SCAN.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 3: Filter elements. */</span></span><br><span class="line">    node = listFirst(keys);</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        nextnode = listNextNode(node);</span><br><span class="line">        <span class="type">int</span> filter = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Filter element if it does not match the pattern. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; use_pattern) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sdsEncodedObject(kobj)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stringmatchlen(pat, patlen, kobj-&gt;ptr, sdslen(kobj-&gt;ptr), <span class="number">0</span>))</span><br><span class="line">                    filter = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">char</span> buf[REDIS_LONGSTR_SIZE];</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                redisAssert(kobj-&gt;encoding == REDIS_ENCODING_INT);</span><br><span class="line">                len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="type">long</span>)kobj-&gt;ptr);</span><br><span class="line">                <span class="keyword">if</span> (!stringmatchlen(pat, patlen, buf, len, <span class="number">0</span>)) filter = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Filter element if it is an expired key. */</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; expireIfNeeded(c-&gt;db, kobj)) filter = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* Remove the element and its associted value if needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">            decrRefCount(kobj);</span><br><span class="line">            listDelNode(keys, node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* If this is a hash or a sorted set, we have a flat list of</span></span><br><span class="line"><span class="comment">         * key-value elements, so if this element was filtered, remove the</span></span><br><span class="line"><span class="comment">         * value, or skip it if it was not filtered: we only match keys. */</span></span><br><span class="line">        <span class="keyword">if</span> (o &amp;&amp; (o-&gt;type == REDIS_ZSET || o-&gt;type == REDIS_HASH)) &#123;</span><br><span class="line">            node = nextnode;</span><br><span class="line">            nextnode = listNextNode(node);</span><br><span class="line">            <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">                kobj = listNodeValue(node);</span><br><span class="line">                decrRefCount(kobj);</span><br><span class="line">                listDelNode(keys, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = nextnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Step 4: Reply to the client. */</span></span><br><span class="line">    addReplyMultiBulkLen(c, <span class="number">2</span>);</span><br><span class="line">    rv = <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;%lu&quot;</span>, cursor);</span><br><span class="line">    redisAssert(rv &lt; <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    addReplyBulkCBuffer(c, buf, rv);</span><br><span class="line">    addReplyMultiBulkLen(c, listLength(keys));</span><br><span class="line">    <span class="keyword">while</span> ((node = listFirst(keys)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        addReplyBulk(c, kobj);</span><br><span class="line">        decrRefCount(kobj);</span><br><span class="line">        listDelNode(keys, node);</span><br><span class="line">    &#125;</span><br><span class="line">cleanup:</span><br><span class="line">    listSetFreeMethod(keys,decrRefCountVoid);</span><br><span class="line">    listRelease(keys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th><th>ziplist编码时间复杂度</th><th>hashtable编码时间复杂度</th></tr></thead><tbody><tr><td>HSET</td><td>设置指定的哈希表中 key 的值</td><td>平均O(n), 最坏O(N2)</td><td>O(1)</td></tr><tr><td>HGET</td><td>获取指定的哈希表中 key 的值</td><td>O(N2)</td><td>O(1)</td></tr><tr><td>HEXISTS</td><td>判断哈希表中的 field 的值是否存在</td><td>O(N2)</td><td>O(1)</td></tr><tr><td>HDEL</td><td>删除指定哈希表中的field，可以为多个</td><td>O(N2)</td><td>O(1)</td></tr><tr><td>HLEN</td><td>返回指定哈希表中的长度</td><td>O(1)</td><td>O(1)</td></tr><tr><td>HGETALL</td><td>返回指定哈希表中的所有元素</td><td>O(n)</td><td>O(n)</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis-源码学习-list</title>
      <link href="/p/2518244256.html"/>
      <url>/p/2518244256.html</url>
      
        <content type="html"><![CDATA[<p>基础的list相关的命令,<code>t_list.c</code></p><span id="more"></span><h2 id="rpush——rpushCommand"><a href="#rpush——rpushCommand" class="headerlink" title="rpush——rpushCommand"></a>rpush——rpushCommand</h2><p>示例：RPUSH KEY_NAME VALUE1..VALUEN</p><ul><li>执行 RPUSH 操作后，列表的长度。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rpushCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    pushGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">pushGenericCommand</span><span class="params">(redisClient *c, <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j, waiting = <span class="number">0</span>, pushed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取出列表对象</span></span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 如果列表对象不存在，那么可能有客户端在等待这个键的出现</span></span><br><span class="line">    <span class="type">int</span> may_have_waiting_clients = (lobj == <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (lobj &amp;&amp; lobj-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将列表状态设置为就绪</span></span><br><span class="line">    <span class="keyword">if</span> (may_have_waiting_clients) signalListAsReady(c,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 遍历所有输入值，并将它们添加到列表中</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 编码值</span></span><br><span class="line">        c-&gt;argv[j] = tryObjectEncoding(c-&gt;argv[j]);</span><br><span class="line">        <span class="comment">// 如果列表对象不存在，那么创建一个，并关联到数据库</span></span><br><span class="line">        <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">            lobj = createZiplistObject();</span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将值推入到列表</span></span><br><span class="line">        listTypePush(lobj,c-&gt;argv[j],where);</span><br><span class="line">        pushed++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回添加的节点数量</span></span><br><span class="line">    addReplyLongLong(c, waiting + (lobj ? listTypeLength(lobj) : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 如果至少有一个元素被成功推入，那么执行以下代码</span></span><br><span class="line">    <span class="keyword">if</span> (pushed) &#123;</span><br><span class="line">        <span class="type">char</span> *event = (where == REDIS_HEAD) ? <span class="string">&quot;lpush&quot;</span> : <span class="string">&quot;rpush&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送键修改信号</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += pushed;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/* The function pushes an element to the specified list object &#x27;subject&#x27;,</span></span><br><span class="line"><span class="comment"> * at head or tail position as specified by &#x27;where&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将给定元素添加到列表的表头或表尾。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数 where 决定了新元素添加的位置：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - REDIS_HEAD 将新元素添加到表头</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  - REDIS_TAIL 将新元素添加到表尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There is no need for the caller to increment the refcount of &#x27;value&#x27; as</span></span><br><span class="line"><span class="comment"> * the function takes care of it if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调用者无须担心 value 的引用计数，因为这个函数会负责这方面的工作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">listTypePush</span><span class="params">(robj *subject, robj *value, <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    <span class="comment">/* Check if we need to convert the ziplist */</span></span><br><span class="line">    <span class="comment">// 是否需要转换编码？</span></span><br><span class="line">    listTypeTryConversion(subject,value);</span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST &amp;&amp;</span><br><span class="line">        ziplistLen(subject-&gt;ptr) &gt;= server.list_max_ziplist_entries)</span><br><span class="line">            listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">    <span class="comment">// ZIPLIST</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">int</span> pos = (where == REDIS_HEAD) ? ZIPLIST_HEAD : ZIPLIST_TAIL;</span><br><span class="line">        <span class="comment">// 取出对象的值，因为 ZIPLIST 只能保存字符串或整数</span></span><br><span class="line">        value = getDecodedObject(value);</span><br><span class="line">        subject-&gt;ptr = ziplistPush(subject-&gt;ptr,value-&gt;ptr,sdslen(value-&gt;ptr),pos);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">    <span class="comment">// 双端链表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="keyword">if</span> (where == REDIS_HEAD) &#123;</span><br><span class="line">            listAddNodeHead(subject-&gt;ptr,value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            listAddNodeTail(subject-&gt;ptr,value);</span><br><span class="line">        &#125;</span><br><span class="line">        incrRefCount(value);</span><br><span class="line">    <span class="comment">// 未知编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：需要判断是压缩列表还是双端链表，并且根据value值，判断是否需要从压缩列表转换到双端列表；并根据插入列头还是列尾选用不同的方式。</p><p>复杂度：压缩列表O(N), 最坏O(N2) 连锁更新; 双端列表：O(1)</p><h2 id="lpush——lpushCommand"><a href="#lpush——lpushCommand" class="headerlink" title="lpush——lpushCommand"></a>lpush——lpushCommand</h2><p>示例: LPUSH KEY_NAME VALUE1.. VALUEN</p><ul><li>执行 LPUSH 命令后，列表的长度。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lpushCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    pushGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明\复杂度： 同rpushCommand</p><h2 id="rpushx——rpushxCommand"><a href="#rpushx——rpushxCommand" class="headerlink" title="rpushx——rpushxCommand"></a>rpushx——rpushxCommand</h2><p>示例：RPUSHX KEY_NAME VALUE1..VALUEN </p><ul><li>执行 Rpushx 操作后，列表的长度。如果列表不存在，则操作无效</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rpushxCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    pushxGenericCommand(c,<span class="literal">NULL</span>,c-&gt;argv[<span class="number">2</span>],REDIS_TAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明\复杂度： 同rpushCommand</p><h2 id="lpushx——lpushxCommand"><a href="#lpushx——lpushxCommand" class="headerlink" title="lpushx——lpushxCommand"></a>lpushx——lpushxCommand</h2><p>示例：LPUSHX KEY_NAME VALUE1.. VALUEN</p><ul><li>LPUSHX 命令执行之后，列表的长度。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lpushxCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    pushxGenericCommand(c,<span class="literal">NULL</span>,c-&gt;argv[<span class="number">2</span>],REDIS_HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明\复杂度： 同rpushCommand</p><h2 id="linsert——linsertCommand"><a href="#linsert——linsertCommand" class="headerlink" title="linsert——linsertCommand"></a>linsert——linsertCommand</h2><p>示例：LINSERT key BEFORE|AFTER pivot value</p><ul><li>如果命令执行成功，返回插入操作完成之后，列表的长度。 如果没有找到指定元素 ，返回 -1 。 如果 key 不存在或为空列表，返回 0 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">linsertCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 编码 refval 对象</span></span><br><span class="line">    c-&gt;argv[<span class="number">4</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">4</span>]);</span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;after&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        pushxGenericCommand(c,c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">4</span>],REDIS_TAIL);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;before&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        pushxGenericCommand(c,c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">4</span>],REDIS_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">pushxGenericCommand</span><span class="params">(redisClient *c, robj *refval, robj *val, <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    robj *subject;</span><br><span class="line">    listTypeIterator *iter;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="type">int</span> inserted = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取出列表对象</span></span><br><span class="line">    <span class="keyword">if</span> ((subject = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,subject,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 执行的是 LINSERT 命令</span></span><br><span class="line">    <span class="keyword">if</span> (refval != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* We&#x27;re not sure if this value can be inserted yet, but we cannot</span></span><br><span class="line"><span class="comment">         * convert the list inside the iterator. We don&#x27;t want to loop over</span></span><br><span class="line"><span class="comment">         * the list twice (once to see if the value can be inserted and once</span></span><br><span class="line"><span class="comment">         * to do the actual insert), so we assume this value can be inserted</span></span><br><span class="line"><span class="comment">         * and convert the ziplist to a regular list if necessary. */</span></span><br><span class="line">        <span class="comment">// 看保存值 value 是否需要将列表编码转换为双端链表</span></span><br><span class="line">        listTypeTryConversion(subject,val);</span><br><span class="line">        <span class="comment">/* Seek refval from head to tail */</span></span><br><span class="line">        <span class="comment">// 在列表中查找 refval 对象</span></span><br><span class="line">        iter = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">        <span class="keyword">while</span> (listTypeNext(iter,&amp;entry)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (listTypeEqual(&amp;entry,refval)) &#123;</span><br><span class="line">                <span class="comment">// 找到了，将值插入到节点的前面或后面</span></span><br><span class="line">                listTypeInsert(&amp;entry,val,where);</span><br><span class="line">                inserted = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        listTypeReleaseIterator(iter);</span><br><span class="line">        <span class="keyword">if</span> (inserted) &#123;</span><br><span class="line">            <span class="comment">/* Check if the length exceeds the ziplist length threshold. */</span></span><br><span class="line">            <span class="comment">// 查看插入之后是否需要将编码转换为双端链表</span></span><br><span class="line">            <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST &amp;&amp;</span><br><span class="line">                ziplistLen(subject-&gt;ptr) &gt; server.list_max_ziplist_entries)</span><br><span class="line">                    listTypeConvert(subject,REDIS_ENCODING_LINKEDLIST);</span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,<span class="string">&quot;linsert&quot;</span>,</span><br><span class="line">                                c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Notify client of a failed insert */</span></span><br><span class="line">            <span class="comment">// refval 不存在，插入失败</span></span><br><span class="line">            addReply(c,shared.cnegone);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 执行的是 LPUSHX 或 RPUSHX 命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *event = (where == REDIS_HEAD) ? <span class="string">&quot;lpush&quot;</span> : <span class="string">&quot;rpush&quot;</span>;</span><br><span class="line">        listTypePush(subject,val,where);</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,listTypeLength(subject));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：列表中插入新节点，双向列表很容易插入；压缩列表可能引起连锁更新</p><p>复杂度：压缩列表O(N), 最坏O(N2) 连锁更新; 双端列表：O(1)</p><h2 id="rpop——rpopCommand"><a href="#rpop——rpopCommand" class="headerlink" title="rpop——rpopCommand"></a>rpop——rpopCommand</h2><p>示例：RPOP KEY_NAME </p><ul><li>列表的最后一个元素。 当列表不存在时，返回 nil 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rpopCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    popGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 说明：列表中删除新节点，双向列表很容易删除；压缩列表可能引起连锁更新</p><p>复杂度：压缩列表O(N), 最坏O(N2) 连锁更新; 双端列表：O(1)</p><h2 id="lpop——lpopCommand"><a href="#lpop——lpopCommand" class="headerlink" title="lpop——lpopCommand"></a>lpop——lpopCommand</h2><p>示例：Lpop KEY_NAME </p><ul><li>列表的第一个元素。 当列表 key 不存在时，返回 nil 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lpopCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    popGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">popGenericCommand</span><span class="params">(redisClient *c, <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    <span class="comment">// 取出列表对象</span></span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 弹出列表元素</span></span><br><span class="line">    robj *value = listTypePop(o,where);</span><br><span class="line">    <span class="comment">// 根据弹出元素是否为空，决定后续动作</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *event = (where == REDIS_HEAD) ? <span class="string">&quot;lpop&quot;</span> : <span class="string">&quot;rpop&quot;</span>;</span><br><span class="line">        addReplyBulk(c,value);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                                c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：列表中删除新节点，双向列表很容易删除；压缩列表可能引起连锁更新</p><p>复杂度：压缩列表O(N), 最坏O(N2) 连锁更新; 双端列表：O(1)</p><h2 id="brpop——brpopCommand"><a href="#brpop——brpopCommand" class="headerlink" title="brpop——brpopCommand"></a>brpop——brpopCommand</h2><p>示例：BRPOP LIST1 LIST2 .. LISTN TIMEOUT </p><ul><li>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">brpopCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    blockingPopGenericCommand(c,REDIS_TAIL);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Blocking RPOP/LPOP */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">blockingPopGenericCommand</span><span class="params">(redisClient *c, <span class="type">int</span> where)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">mstime_t</span> timeout;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// 取出 timeout 参数</span></span><br><span class="line">    <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[c-&gt;argc<span class="number">-1</span>],&amp;timeout,UNIT_SECONDS)</span><br><span class="line">        != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 遍历所有列表键</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc<span class="number">-1</span>; j++) &#123;</span><br><span class="line">        <span class="comment">// 取出列表键</span></span><br><span class="line">        o = lookupKeyWrite(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="comment">// 有非空列表？</span></span><br><span class="line">        <span class="keyword">if</span> (o != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">                addReply(c,shared.wrongtypeerr);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 非空列表</span></span><br><span class="line">                <span class="keyword">if</span> (listTypeLength(o) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">/* Non empty list, this is like a non normal [LR]POP. */</span></span><br><span class="line">                    <span class="type">char</span> *event = (where == REDIS_HEAD) ? <span class="string">&quot;lpop&quot;</span> : <span class="string">&quot;rpop&quot;</span>;</span><br><span class="line">                    <span class="comment">// 弹出值</span></span><br><span class="line">                    robj *value = listTypePop(o,where);</span><br><span class="line">                    redisAssert(value != <span class="literal">NULL</span>);</span><br><span class="line">                    <span class="comment">// 回复客户端</span></span><br><span class="line">                    addReplyMultiBulkLen(c,<span class="number">2</span>);</span><br><span class="line">                    <span class="comment">// 回复弹出元素的列表</span></span><br><span class="line">                    addReplyBulk(c,c-&gt;argv[j]);</span><br><span class="line">                    <span class="comment">// 回复弹出值</span></span><br><span class="line">                    addReplyBulk(c,value);</span><br><span class="line">                    decrRefCount(value);</span><br><span class="line">                    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,event,</span><br><span class="line">                                        c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">                    <span class="comment">// 删除空列表</span></span><br><span class="line">                    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">                        dbDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">                        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                                            c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">                    &#125;</span><br><span class="line">                    signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">                    server.dirty++;</span><br><span class="line">                    <span class="comment">/* Replicate it as an [LR]POP instead of B[LR]POP. */</span></span><br><span class="line">                    <span class="comment">// 传播一个 [LR]POP 而不是 B[LR]POP</span></span><br><span class="line">                    rewriteClientCommandVector(c,<span class="number">2</span>,</span><br><span class="line">                        (where == REDIS_HEAD) ? shared.lpop : shared.rpop,</span><br><span class="line">                        c-&gt;argv[j]);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we are inside a MULTI/EXEC and the list is empty the only thing</span></span><br><span class="line"><span class="comment">     * we can do is treating it as a timeout (even with timeout 0). */</span></span><br><span class="line">    <span class="comment">// 如果命令在一个事务中执行，那么为了不产生死等待</span></span><br><span class="line">    <span class="comment">// 服务器只能向客户端发送一个空回复</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</span><br><span class="line">        addReply(c,shared.nullmultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If the list is empty or the key does not exists we must block */</span></span><br><span class="line">    <span class="comment">// 所有输入列表键都不存在，只能阻塞了</span></span><br><span class="line">    blockForKeys(c, c-&gt;argv + <span class="number">1</span>, c-&gt;argc - <span class="number">2</span>, timeout, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">blockForKeys</span><span class="params">(redisClient *c, robj **keys, <span class="type">int</span> numkeys, <span class="type">mstime_t</span> timeout, robj *target)</span> &#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *l;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">// 设置阻塞状态的超时和目标选项</span></span><br><span class="line">    c-&gt;bpop.timeout = timeout;</span><br><span class="line">    <span class="comment">// target 在执行 RPOPLPUSH 命令时使用</span></span><br><span class="line">    c-&gt;bpop.target = target;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">NULL</span>) incrRefCount(target);</span><br><span class="line">    <span class="comment">// 关联阻塞客户端和键的相关信息</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        <span class="comment">/* If the key already exists in the dict ignore it. */</span></span><br><span class="line">        <span class="comment">// c-&gt;bpop.keys 是一个集合（值为 NULL 的字典）</span></span><br><span class="line">        <span class="comment">// 它记录所有造成客户端阻塞的键</span></span><br><span class="line">        <span class="comment">// 以下语句在键不存在于集合的时候，将它添加到集合</span></span><br><span class="line">        <span class="keyword">if</span> (dictAdd(c-&gt;bpop.keys,keys[j],<span class="literal">NULL</span>) != DICT_OK) <span class="keyword">continue</span>;</span><br><span class="line">        incrRefCount(keys[j]);</span><br><span class="line">        <span class="comment">/* And in the other &quot;side&quot;, to map keys -&gt; clients */</span></span><br><span class="line">        <span class="comment">// c-&gt;db-&gt;blocking_keys 字典的键为造成客户端阻塞的键</span></span><br><span class="line">        <span class="comment">// 而值则是一个链表，链表中包含了所有被阻塞的客户端</span></span><br><span class="line">        <span class="comment">// 以下程序将阻塞键和被阻塞客户端关联起来</span></span><br><span class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 链表不存在，新创建一个，并将它关联到字典中</span></span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line">            <span class="comment">/* For every key we take a list of clients blocked for it */</span></span><br><span class="line">            l = listCreate();</span><br><span class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</span><br><span class="line">            incrRefCount(keys[j]);</span><br><span class="line">            redisAssertWithInfo(c,keys[j],retval == DICT_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将客户端填接到被阻塞客户端的链表中</span></span><br><span class="line">        listAddNodeTail(l,c);</span><br><span class="line">    &#125;</span><br><span class="line">    blockClient(c,REDIS_BLOCKED_LIST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：如果多个列表中，任意有一个有value，则直接返回value，删除列表中的value；</p><p>都无value，则直接阻塞，会在db-&gt;blocking_keys 的dict中记录对应的客户端，如key是LIST1，value是列表，列表中记录阻塞的客户端</p><p>其中，timeout是必传项，如果最后一个不是整数，会报错</p><p>复杂度：压缩列表O(N), 最坏O(N2) 连锁更新; 双端列表：O(1)</p><h2 id="brpoplpush——brpoplpushCommand"><a href="#brpoplpush——brpoplpushCommand" class="headerlink" title="brpoplpush——brpoplpushCommand"></a>brpoplpush——brpoplpushCommand</h2><p>示例：BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT </p><ul><li>假如在指定时间内没有任何元素被弹出，则返回一个 nil 和等待时长。 反之，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">brpoplpushCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">mstime_t</span> timeout;</span><br><span class="line">    <span class="comment">// 取出 timeout 参数</span></span><br><span class="line">    <span class="keyword">if</span> (getTimeoutFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;timeout,UNIT_SECONDS)</span><br><span class="line">        != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出列表键</span></span><br><span class="line">    robj *key = lookupKeyWrite(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 键为空，阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_MULTI) &#123;</span><br><span class="line">            <span class="comment">/* Blocking against an empty list in a multi state</span></span><br><span class="line"><span class="comment">             * returns immediately. */</span></span><br><span class="line">            addReply(c, shared.nullbulk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The list is empty and the client blocks. */</span></span><br><span class="line">            blockForKeys(c, c-&gt;argv + <span class="number">1</span>, <span class="number">1</span>, timeout, c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 键非空，执行 RPOPLPUSH</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key-&gt;type != REDIS_LIST) &#123;</span><br><span class="line">            addReply(c, shared.wrongtypeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The list exists and has elements, so</span></span><br><span class="line"><span class="comment">             * the regular rpoplpushCommand is executed. */</span></span><br><span class="line">            redisAssertWithInfo(c,key,listTypeLength(key) &gt; <span class="number">0</span>);</span><br><span class="line">            rpoplpushCommand(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：pop和push的命令组合</p><h2 id="blpop——blpopCommand"><a href="#blpop——blpopCommand" class="headerlink" title="blpop——blpopCommand"></a>blpop——blpopCommand</h2><p>示例：BLPOP LIST1 LIST2 .. LISTN TIMEOUT</p><ul><li>如果列表为空，返回一个 nil 。 否则，返回一个含有两个元素的列表，第一个元素是被弹出元素所属的 key ，第二个元素是被弹出元素的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">blpopCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    blockingPopGenericCommand(c,REDIS_HEAD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：同brpopCommand</p><h2 id="llen——llenCommand"><a href="#llen——llenCommand" class="headerlink" title="llen——llenCommand"></a>llen——llenCommand</h2><p>示例：LLEN KEY_NAME </p><ul><li>列表的长度。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">llenCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    addReplyLongLong(c,listTypeLength(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：获取列表长度</p><p>复杂度：O(1)</p><h2 id="lindex——lindexCommand"><a href="#lindex——lindexCommand" class="headerlink" title="lindex——lindexCommand"></a>lindex——lindexCommand</h2><p>示例:LINDEX KEY_NAME INDEX_POSITION </p><ul><li>列表中下标为指定索引值的元素。 如果指定索引值不在列表的区间范围内，返回 nil 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lindexCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    robj *value = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 取出整数值对象 index</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;index, <span class="literal">NULL</span>) != REDIS_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 根据索引，遍历 ziplist ，直到指定位置</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *p;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *vstr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vlen;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> vlong;</span><br><span class="line">        p = ziplistIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                value = createStringObject((<span class="type">char</span>*)vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = createStringObjectFromLongLong(vlong);</span><br><span class="line">            &#125;</span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">            decrRefCount(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 根据索引，遍历双端链表，直到指定位置</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln = listIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ln != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            value = listNodeValue(ln);</span><br><span class="line">            addReplyBulk(c,value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：获取index节点的value</p><p>复杂度: O(N)</p><h2 id="lset——lsetCommand"><a href="#lset——lsetCommand" class="headerlink" title="lset——lsetCommand"></a>lset——lsetCommand</h2><p>示例：LSET KEY_NAME INDEX VALUE</p><ul><li>操作成功返回 ok ，否则返回错误信息。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lsetCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 取出列表对象</span></span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nokeyerr);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">long</span> index;</span><br><span class="line">    <span class="comment">// 取出值对象 value</span></span><br><span class="line">    robj *value = (c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]));</span><br><span class="line">    <span class="comment">// 取出整数值对象 index</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;index, <span class="literal">NULL</span>) != REDIS_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 查看保存 value 值是否需要转换列表的底层编码</span></span><br><span class="line">    listTypeTryConversion(o,value);</span><br><span class="line">    <span class="comment">// 设置到 ziplist</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *p, *zl = o-&gt;ptr;</span><br><span class="line">        <span class="comment">// 查找索引</span></span><br><span class="line">        p = ziplistIndex(zl,index);</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.outofrangeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除现有的值</span></span><br><span class="line">            o-&gt;ptr = ziplistDelete(o-&gt;ptr,&amp;p);</span><br><span class="line">            <span class="comment">// 插入新值到指定索引</span></span><br><span class="line">            value = getDecodedObject(value);</span><br><span class="line">            o-&gt;ptr = ziplistInsert(o-&gt;ptr,p,value-&gt;ptr,sdslen(value-&gt;ptr));</span><br><span class="line">            decrRefCount(value);</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,<span class="string">&quot;lset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 设置到双端链表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln = listIndex(o-&gt;ptr,index);</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            addReply(c,shared.outofrangeerr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除旧值对象</span></span><br><span class="line">            decrRefCount((robj*)listNodeValue(ln));</span><br><span class="line">            <span class="comment">// 指向新对象</span></span><br><span class="line">            listNodeValue(ln) = value;</span><br><span class="line">            incrRefCount(value);</span><br><span class="line">            addReply(c,shared.ok);</span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_LIST,<span class="string">&quot;lset&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：在index节点的插入key，value</p><p>复杂度：压缩列表O(N), 最坏O(N2) 连锁更新; 双端列表：O(1)，只要涉及到列表的新增，删除，修改，压缩列表最坏情况都是O(N2)；所以在复杂度上压缩列表整体更好，只是在内存占用上有优势，性能和内存折中的结果。</p><h2 id="lrange——lrangeCommand"><a href="#lrange——lrangeCommand" class="headerlink" title="lrange——lrangeCommand"></a>lrange——lrangeCommand</h2><p>示例：LRANGE KEY_NAME START END</p><ul><li>一个列表，包含指定区间内的元素。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lrangeCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">long</span> start, end, llen, rangelen;</span><br><span class="line">    <span class="comment">// 取出索引值 start 和 end</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != REDIS_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != REDIS_OK)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出列表对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymultibulk)) == <span class="literal">NULL</span></span><br><span class="line">         || checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出列表长度</span></span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line">    <span class="comment">/* convert negative indexes */</span></span><br><span class="line">    <span class="comment">// 将负数索引转换成正数索引</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        addReply(c,shared.emptymultibulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    rangelen = (end-start)+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Return the result in form of a multi-bulk reply */</span></span><br><span class="line">    addReplyMultiBulkLen(c,rangelen);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *p = ziplistIndex(o-&gt;ptr,start);</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> *vstr;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> vlen;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> vlong;</span><br><span class="line">        <span class="comment">// 遍历 ziplist ，并将指定索引上的值添加到回复中</span></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vlong);</span><br><span class="line">            <span class="keyword">if</span> (vstr) &#123;</span><br><span class="line">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyBulkLongLong(c,vlong);</span><br><span class="line">            &#125;</span><br><span class="line">            p = ziplistNext(o-&gt;ptr,p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        <span class="comment">/* If we are nearest to the end of the list, reach the element</span></span><br><span class="line"><span class="comment">         * starting from tail and going backward, as it is faster. */</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; llen/<span class="number">2</span>) start -= llen;</span><br><span class="line">        ln = listIndex(o-&gt;ptr,start);</span><br><span class="line">        <span class="comment">// 遍历双端链表，将指定索引上的值添加到回复</span></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            addReplyBulk(c,ln-&gt;value);</span><br><span class="line">            ln = ln-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;List encoding is not LINKEDLIST nor ZIPLIST!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ltrim——ltrimCommand"><a href="#ltrim——ltrimCommand" class="headerlink" title="ltrim——ltrimCommand"></a>ltrim——ltrimCommand</h2><p>示例：LTRIM KEY_NAME START STOP</p><ul><li>命令执行成功时，返回 ok 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ltrimCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="type">long</span> start, end, llen, j, ltrim, rtrim;</span><br><span class="line">    <span class="built_in">list</span> *<span class="built_in">list</span>;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">// 取出索引值 start 和 end</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != REDIS_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != REDIS_OK)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出列表对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.ok)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 列表长度</span></span><br><span class="line">    llen = listTypeLength(o);</span><br><span class="line">    <span class="comment">/* convert negative indexes */</span></span><br><span class="line">    <span class="comment">// 将负数索引转换成正数索引</span></span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        <span class="comment">/* Out of range start or start &gt; end result in empty list */</span></span><br><span class="line">        ltrim = llen;</span><br><span class="line">        rtrim = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">        ltrim = start;</span><br><span class="line">        rtrim = llen-end<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Remove list elements to perform the trim */</span></span><br><span class="line">    <span class="comment">// 删除指定列表两端的元素</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="comment">// 删除左端元素</span></span><br><span class="line">        o-&gt;ptr = ziplistDeleteRange(o-&gt;ptr,<span class="number">0</span>,ltrim);</span><br><span class="line">        <span class="comment">// 删除右端元素</span></span><br><span class="line">        o-&gt;ptr = ziplistDeleteRange(o-&gt;ptr,-rtrim,rtrim);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == REDIS_ENCODING_LINKEDLIST) &#123;</span><br><span class="line">        <span class="built_in">list</span> = o-&gt;ptr;</span><br><span class="line">        <span class="comment">// 删除左端元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ltrim; j++) &#123;</span><br><span class="line">            ln = listFirst(<span class="built_in">list</span>);</span><br><span class="line">            listDelNode(<span class="built_in">list</span>,ln);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除右端元素</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; rtrim; j++) &#123;</span><br><span class="line">            ln = listLast(<span class="built_in">list</span>);</span><br><span class="line">            listDelNode(<span class="built_in">list</span>,ln);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        redisPanic(<span class="string">&quot;Unknown list encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_LIST,<span class="string">&quot;ltrim&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 如果列表已经为空，那么删除它</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">        dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：删除某一端的一段数据</p><h2 id="lrem——lremCommand"><a href="#lrem——lremCommand" class="headerlink" title="lrem——lremCommand"></a>lrem——lremCommand</h2><p>示例：LREM KEY_NAME COUNT VALUE</p><ul><li>被移除元素的数量。 列表不存在时返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lremCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *subject, *obj;</span><br><span class="line">    <span class="comment">// 编码目标对象 elem</span></span><br><span class="line">    obj = c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    <span class="type">long</span> toremove;</span><br><span class="line">    <span class="type">long</span> removed = <span class="number">0</span>;</span><br><span class="line">    listTypeEntry entry;</span><br><span class="line">    <span class="comment">// 取出指定删除模式的 count 参数</span></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;toremove, <span class="literal">NULL</span>) != REDIS_OK))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出列表对象</span></span><br><span class="line">    subject = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero);</span><br><span class="line">    <span class="keyword">if</span> (subject == <span class="literal">NULL</span> || checkType(c,subject,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* Make sure obj is raw when we&#x27;re dealing with a ziplist */</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST)</span><br><span class="line">        obj = getDecodedObject(obj);</span><br><span class="line">    listTypeIterator *li;</span><br><span class="line">    <span class="comment">// 根据 toremove 参数，决定是从表头还是表尾开始进行删除</span></span><br><span class="line">    <span class="keyword">if</span> (toremove &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        toremove = -toremove;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">-1</span>,REDIS_HEAD);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        li = listTypeInitIterator(subject,<span class="number">0</span>,REDIS_TAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找，比对对象，并进行删除</span></span><br><span class="line">    <span class="keyword">while</span> (listTypeNext(li,&amp;entry)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (listTypeEqual(&amp;entry,obj)) &#123;</span><br><span class="line">            listTypeDelete(&amp;entry);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            removed++;</span><br><span class="line">            <span class="comment">// 已经满足删除数量，停止</span></span><br><span class="line">            <span class="keyword">if</span> (toremove &amp;&amp; removed == toremove) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    listTypeReleaseIterator(li);</span><br><span class="line">    <span class="comment">/* Clean up raw encoded object */</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == REDIS_ENCODING_ZIPLIST)</span><br><span class="line">        decrRefCount(obj);</span><br><span class="line">    <span class="comment">// 删除空列表</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(subject) == <span class="number">0</span>) dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    addReplyLongLong(c,removed);</span><br><span class="line">    <span class="keyword">if</span> (removed) signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rpoplpush——rpoplpushCommand"><a href="#rpoplpush——rpoplpushCommand" class="headerlink" title="rpoplpush——rpoplpushCommand"></a>rpoplpush——rpoplpushCommand</h2><p>示例：RPOPLPUSH SOURCE_KEY_NAME DESTINATION_KEY_NAME</p><ul><li>被弹出的元素。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rpoplpushCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *sobj, *value;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 来源列表</span></span><br><span class="line">    <span class="keyword">if</span> ((sobj = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,sobj,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 空列表，没有元素可 pop ，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (listTypeLength(sobj) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* This may only happen after loading very old RDB files. Recent</span></span><br><span class="line"><span class="comment">         * versions of Redis delete keys of empty lists. */</span></span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    <span class="comment">// 源列表非空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        robj *dobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        robj *touchedkey = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 检查目标对象是否列表</span></span><br><span class="line">        <span class="keyword">if</span> (dobj &amp;&amp; checkType(c,dobj,REDIS_LIST)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 从源列表中弹出值</span></span><br><span class="line">        value = listTypePop(sobj,REDIS_TAIL);</span><br><span class="line">        <span class="comment">/* We saved touched key, and protect it, since rpoplpushHandlePush</span></span><br><span class="line"><span class="comment">         * may change the client command argument vector (it does not</span></span><br><span class="line"><span class="comment">         * currently). */</span></span><br><span class="line">        incrRefCount(touchedkey);</span><br><span class="line">        <span class="comment">// 将值推入目标列表中，如果目标列表不存在，那么创建一个新列表</span></span><br><span class="line">        rpoplpushHandlePush(c,c-&gt;argv[<span class="number">2</span>],dobj,value);</span><br><span class="line">        <span class="comment">/* listTypePop returns an object with its refcount incremented */</span></span><br><span class="line">        decrRefCount(value);</span><br><span class="line">        <span class="comment">/* Delete the source list when it is empty */</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_LIST,<span class="string">&quot;rpop&quot;</span>,touchedkey,c-&gt;db-&gt;id);</span><br><span class="line">        <span class="comment">// 如果源列表已经为空，那么将它删除</span></span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(sobj) == <span class="number">0</span>) &#123;</span><br><span class="line">            dbDelete(c-&gt;db,touchedkey);</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,<span class="string">&quot;del&quot;</span>,</span><br><span class="line">                                touchedkey,c-&gt;db-&gt;id);</span><br><span class="line">        &#125;</span><br><span class="line">        signalModifiedKey(c-&gt;db,touchedkey);</span><br><span class="line">        decrRefCount(touchedkey);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th><th>ziplist编码时间复杂度</th><th>linkedlist编码时间复杂度</th></tr></thead><tbody><tr><td>LPUSH</td><td>将所有指定的值插入到存于 key 的列表的头部</td><td>平均O(n), 最坏O(N2)</td><td>O(1)</td></tr><tr><td>RPUSH</td><td>将所有指定的值插入到存于 key 的列表的尾部</td><td>平均O(n), 最坏O(N2)</td><td>O(1)</td></tr><tr><td>LPOP</td><td>移除并返回列表 key 的头元素</td><td>平均O(n), 最坏O(N2)</td><td>O(1)</td></tr><tr><td>RPOP</td><td>移除并返回列表 key 的尾元素</td><td>平均O(n), 最坏O(N2)</td><td>O(1)</td></tr><tr><td>LINDEX</td><td>返回列表 key 中，下标为 index 的元素</td><td>O(n)</td><td>O(n)，N为链表长度</td></tr><tr><td>LLEN</td><td>返回列表 key 的长度</td><td>O(1)</td><td>O(1)</td></tr><tr><td>LINSERT</td><td>向列表 key 中指定的元素前或者后插入元素</td><td>平均O(n), 最坏O(N2)</td><td>O(n)</td></tr><tr><td>LREM</td><td>移除列表 key 中\</td><td>count\</td><td>个与参数value相等的值</td><td>平均O(n), 最坏O(N2)</td><td>O(n)</td></tr><tr><td>LTRIM</td><td>保留列表 key 中指定区间的值，其他的全部移除</td><td>平均O(n), 最坏O(N2)</td><td>O(n)</td></tr><tr><td>LSET</td><td>将列表 key 中指定下标的值设置为value</td><td>平均O(n), 最坏O(N2)</td><td>O(n)</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis-源码学习-string</title>
      <link href="/p/4252874394.html"/>
      <url>/p/4252874394.html</url>
      
        <content type="html"><![CDATA[<p>基础的string相关的命令</p><span id="more"></span><h2 id="get——getCommand"><a href="#get——getCommand" class="headerlink" title="get——getCommand"></a>get——getCommand</h2><p>示例： GET KEY_NAME</p><ul><li>返回 key 的值，如果 key 不存在时，返回 nil。 如果 key 不是字符串类型，那么返回一个错误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    getGenericCommand(c);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="type">int</span> <span class="title function_">getGenericCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 尝试从数据库中取出键 c-&gt;argv[1] 对应的值对象</span></span><br><span class="line">    <span class="comment">// 如果键不存在时，向客户端发送回复信息，并返回 NULL</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    <span class="comment">// 值对象存在，检查它的类型</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type != REDIS_STRING) &#123;</span><br><span class="line">        <span class="comment">// 类型错误</span></span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 类型正确，向客户端返回对象的值</span></span><br><span class="line">        addReplyBulk(c,o);</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：先判断db的expires字典中查找key并判断是否已过期，如果已过期，则返回空；如果未过期，则继续在db的dict中查找key，找到则返回，若未找到则返回null。</p><h2 id="set——setCommand"><a href="#set——setCommand" class="headerlink" title="set——setCommand"></a>set——setCommand</h2><p>示例： SET key value [NX] [XX] [EX <seconds>] [PX <milliseconds>]</p><ul><li>EX second ：设置键的过期时间为 second 秒。 SET key value EX second 效果等同于 SETEX key second value 。</li><li>PX millisecond ：设置键的过期时间为 millisecond 毫秒。 SET key value PX millisecond 效果等同于 PSETEX keymillisecond value 。</li><li>NX ：只在键不存在时，才对键进行设置操作。 SET key value NX 效果等同于 SETNX key value 。</li><li>XX ：只在键已经存在时，才对键进行设置操作。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="comment">/* SET key value [NX] [XX] [EX &lt;seconds&gt;] [PX &lt;milliseconds&gt;] */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    robj *expire = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> unit = UNIT_SECONDS;</span><br><span class="line">    <span class="type">int</span> flags = REDIS_SET_NO_FLAGS;</span><br><span class="line">    <span class="comment">// 设置选项参数</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="type">char</span> *a = c-&gt;argv[j]-&gt;ptr;</span><br><span class="line">        robj *next = (j == c-&gt;argc<span class="number">-1</span>) ? <span class="literal">NULL</span> : c-&gt;argv[j+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;n&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;N&#x27;</span>) &amp;&amp;</span><br><span class="line">            (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            flags |= REDIS_SET_NX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            flags |= REDIS_SET_XX;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;e&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;E&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; next) &#123;</span><br><span class="line">            unit = UNIT_SECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a[<span class="number">0</span>] == <span class="string">&#x27;p&#x27;</span> || a[<span class="number">0</span>] == <span class="string">&#x27;P&#x27;</span>) &amp;&amp;</span><br><span class="line">                   (a[<span class="number">1</span>] == <span class="string">&#x27;x&#x27;</span> || a[<span class="number">1</span>] == <span class="string">&#x27;X&#x27;</span>) &amp;&amp; a[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span> &amp;&amp; next) &#123;</span><br><span class="line">            unit = UNIT_MILLISECONDS;</span><br><span class="line">            expire = next;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试对值对象进行编码</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">setGenericCommand</span><span class="params">(redisClient *c, <span class="type">int</span> flags, robj *key, robj *val, robj *expire, <span class="type">int</span> unit, robj *ok_reply, robj *abort_reply)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></span><br><span class="line">    <span class="comment">// 取出过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        <span class="comment">// 取出 expire 参数的值</span></span><br><span class="line">        <span class="comment">// T = O(N)</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// expire 参数的值不正确时报错</span></span><br><span class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,<span class="string">&quot;invalid expire time in SETEX&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不论输入的过期时间是秒还是毫秒</span></span><br><span class="line">        <span class="comment">// Redis 实际都以毫秒的形式保存过期时间</span></span><br><span class="line">        <span class="comment">// 如果输入的过期时间为秒，那么将它转换为毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果设置了 NX 或者 XX 参数，那么检查条件是否不符合这两个设置</span></span><br><span class="line">    <span class="comment">// 在条件不符合时报错，报错的内容由 abort_reply 参数决定</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; REDIS_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) ||</span><br><span class="line">        (flags &amp; REDIS_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将键值关联到数据库</span></span><br><span class="line">    setKey(c-&gt;db,key,val);</span><br><span class="line">    <span class="comment">// 将数据库设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">// 为键设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) setExpire(c-&gt;db,key,mstime()+milliseconds);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,<span class="string">&quot;set&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (expire) notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,</span><br><span class="line">        <span class="string">&quot;expire&quot;</span>,key,c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 设置成功，向客户端发送回复</span></span><br><span class="line">    <span class="comment">// 回复的内容由 ok_reply 决定</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li>先尝试对value进行编码节省内存（只有编码为RAW或者EMBSTR时尝试编码），EMBSTR 转 INT(字节长度小于21且可以转成整数), RAW  转 EMBSTR（字符串长度小于长度39）</li><li>在dict中，如果没有该key，则添加key，value；否则覆盖，其中覆盖后，需要是否原有value</li><li>如果EX，需要添加到expires字典中；如果是NX，则判断如果已有key，则不进行第二步的dict添加操作操作</li></ol><h2 id="setnx——setnxCommand"><a href="#setnx——setnxCommand" class="headerlink" title="setnx——setnxCommand"></a>setnx——setnxCommand</h2><p>示例：SETNX KEY_NAME VALUE</p><ul><li>返回 key 的值，如果 key 不存在时，返回 nil。 如果 key 不是字符串类型，那么返回一个错误。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setnxCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,REDIS_SET_NX,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],<span class="literal">NULL</span>,<span class="number">0</span>,shared.cone,shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：复用“setGenericCommand”方法，通过flags=REDIS_SET_NX，标识</p><h2 id="setex——setexCommand"><a href="#setex——setexCommand" class="headerlink" title="setex——setexCommand"></a>setex——setexCommand</h2><p>示例：SETEX KEY_NAME TIMEOUT VALUE</p><ul><li>设置成功时返回 OK 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setexCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    setGenericCommand(c,REDIS_SET_NO_FLAGS,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">2</span>],UNIT_SECONDS,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：复用“setGenericCommand”方法，通过 expire =UNIT_SECONDS 设置过期时间</p><h2 id="psetex——psetexCommand"><a href="#psetex——psetexCommand" class="headerlink" title="psetex——psetexCommand"></a>psetex——psetexCommand</h2><p>示例：PSETEX key1 EXPIRY_IN_MILLISECONDS value1</p><ul><li>设置成功时返回 OK 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">psetexCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    c-&gt;argv[<span class="number">3</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">3</span>]);</span><br><span class="line">    setGenericCommand(c,REDIS_SET_NO_FLAGS,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">3</span>],c-&gt;argv[<span class="number">2</span>],UNIT_MILLISECONDS,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：复用“setGenericCommand”方法，通过 expire =UNIT_MILLISECONDS 设置过期时间</p><h2 id="append——appendCommand"><a href="#append——appendCommand" class="headerlink" title="append——appendCommand"></a>append——appendCommand</h2><p>示例：APPEND KEY_NAME NEW_VALUE</p><ul><li>追加指定值之后， key 中字符串的长度。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">appendCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> totlen;</span><br><span class="line">    robj *o, *append;</span><br><span class="line">    <span class="comment">// 取出键相应的值对象</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 键值对不存在。。。</span></span><br><span class="line">        <span class="comment">/* Create the key */</span></span><br><span class="line">        <span class="comment">// 键值对不存在，创建一个新的</span></span><br><span class="line">        c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        incrRefCount(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">        totlen = stringObjectLen(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 键值对存在。。。</span></span><br><span class="line">        <span class="comment">/* Key exists, check type */</span></span><br><span class="line">        <span class="comment">// 检查类型</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,REDIS_STRING))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* &quot;append&quot; is an argument, so always an sds */</span></span><br><span class="line">        <span class="comment">// 检查追加操作之后，字符串的长度是否符合 Redis 的限制</span></span><br><span class="line">        append = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        totlen = stringObjectLen(o)+sdslen(append-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (checkStringLength(c,totlen) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* Append the value */</span></span><br><span class="line">        <span class="comment">// 执行追加操作</span></span><br><span class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        o-&gt;ptr = sdscatlen(o-&gt;ptr,append-&gt;ptr,sdslen(append-&gt;ptr));</span><br><span class="line">        totlen = sdslen(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向数据库发送键被修改的信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,<span class="string">&quot;append&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 将服务器设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">// 发送回复</span></span><br><span class="line">    addReplyLongLong(c,totlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：查找dict中的key是否存在，如果不存在，则直接新增key=&gt;value；如果存在，则追加value。</p><h2 id="strlen——strlenCommand"><a href="#strlen——strlenCommand" class="headerlink" title="strlen——strlenCommand"></a>strlen——strlenCommand</h2><p>示例：STRLEN KEY_NAME</p><ul><li>字符串值的长度。 当 key 不存在时，返回 0。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">strlenCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="comment">// 取出值对象，并进行类型检查</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 返回字符串值的长度</span></span><br><span class="line">    addReplyLongLong(c,stringObjectLen(o));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：查找dict中的key是否存在，如果存在则获取value,计算value的长度</p><h2 id="del——delCommand"><a href="#del——delCommand" class="headerlink" title="del——delCommand"></a>del——delCommand</h2><p>示例：DEL key [key …]</p><ul><li>被删除 key 的数量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//db.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> deleted = <span class="number">0</span>, j;</span><br><span class="line">    <span class="comment">// 遍历所有输入键</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 先删除过期的键</span></span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="comment">// 尝试删除键</span></span><br><span class="line">        <span class="keyword">if</span> (dbDelete(c-&gt;db,c-&gt;argv[j])) &#123;</span><br><span class="line">            <span class="comment">// 删除键成功，发送通知</span></span><br><span class="line">            signalModifiedKey(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(REDIS_NOTIFY_GENERIC,</span><br><span class="line">                <span class="string">&quot;del&quot;</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            <span class="comment">// 成功删除才增加 deleted 计数器的值</span></span><br><span class="line">            deleted++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回被删除键的数量</span></span><br><span class="line">    addReplyLongLong(c,deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：遍历每个要删除的key，先删除expires的过期key，再删除dict中的key</p><h2 id="exists——existsCommand"><a href="#exists——existsCommand" class="headerlink" title="exists——existsCommand"></a>exists——existsCommand</h2><p>示例：EXISTS KEY_NAME</p><ul><li>若 key 存在返回 1 ，否则返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//db.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">existsCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查键是否已经过期，如果已过期的话，那么将它删除</span></span><br><span class="line">    <span class="comment">// 这可以避免已过期的键被误认为存在</span></span><br><span class="line">    expireIfNeeded(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 在数据库中查找</span></span><br><span class="line">    <span class="keyword">if</span> (dbExists(c-&gt;db,c-&gt;argv[<span class="number">1</span>])) &#123;</span><br><span class="line">        addReply(c, shared.cone);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c, shared.czero);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：先判断expires是否有该key，如果key已过期，则删除该key；查询dict中是否有该key，如果有则返回1，否认返回0</p><h2 id="incr——incrCommand"><a href="#incr——incrCommand" class="headerlink" title="incr——incrCommand"></a>incr——incrCommand</h2><p>示例：INCR KEY_NAME </p><ul><li>执行 INCR 命令之后 key 的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">incrDecrCommand</span><span class="params">(redisClient *c, <span class="type">long</span> <span class="type">long</span> incr)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> value, oldvalue;</span><br><span class="line">    robj *o, *new;</span><br><span class="line">    <span class="comment">// 取出值对象</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 检查对象是否存在，以及类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取出对象的整数值，并保存到 value 参数中</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 检查加法操作执行之后值释放会溢出</span></span><br><span class="line">    <span class="comment">// 如果是的话，就向客户端发送一个出错回复，并放弃设置操作</span></span><br><span class="line">    oldvalue = value;</span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; oldvalue &lt; <span class="number">0</span> &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</span><br><span class="line">        (incr &gt; <span class="number">0</span> &amp;&amp; oldvalue &gt; <span class="number">0</span> &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;increment or decrement would overflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行加法计算，并将值保存到新的值对象中</span></span><br><span class="line">    <span class="comment">// 然后用新的值对象替换原来的值对象</span></span><br><span class="line">    value += incr;</span><br><span class="line">    new = createStringObjectFromLongLong(value);</span><br><span class="line">    <span class="keyword">if</span> (o)</span><br><span class="line">        dbOverwrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>],new);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],new);</span><br><span class="line">    <span class="comment">// 向数据库发送键被修改的信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,<span class="string">&quot;incrby&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 将服务器设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">// 返回回复</span></span><br><span class="line">    addReply(c,shared.colon);</span><br><span class="line">    addReply(c,new);</span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：如果对象不存在，则初始化为0，获取value后，执行value+1。执行过程符合原子性特点</p><h2 id="decr——delCommand"><a href="#decr——delCommand" class="headerlink" title="decr——delCommand"></a>decr——delCommand</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：DECR KEY_NAME </span><br></pre></td></tr></table></figure><ul><li>执行命令之后 key 的值。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    incrDecrCommand(c,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：同上一个方法，执行value-1</p><h2 id="incrby——incrbyCommand"><a href="#incrby——incrbyCommand" class="headerlink" title="incrby——incrbyCommand"></a>incrby——incrbyCommand</h2><p>示例：INCRBY KEY_NAME INCR_AMOUNT</p><ul><li>加上指定的增量值之后， key 的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrbyCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> incr;</span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;incr, <span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    incrDecrCommand(c,incr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：同上面的方法，value + incr</p><h2 id="decrby——decrbyCommand"><a href="#decrby——decrbyCommand" class="headerlink" title="decrby——decrbyCommand"></a>decrby——decrbyCommand</h2><p>示例：DECRBY KEY_NAME DECREMENT_AMOUNT</p><ul><li>减去指定减量值之后， key 的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">decrbyCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> incr;</span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;incr, <span class="literal">NULL</span>) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">    incrDecrCommand(c,-incr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：同上面的方法，value - incr</p><h2 id="incrbyfloat——incrbyfloatCommand"><a href="#incrbyfloat——incrbyfloatCommand" class="headerlink" title="incrbyfloat——incrbyfloatCommand"></a>incrbyfloat——incrbyfloatCommand</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：INCRBYFLOAT KEY_NAME INCR_AMOUNT</span><br></pre></td></tr></table></figure><ul><li>执行命令之后 key 的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">incrbyfloatCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> incr, value;</span><br><span class="line">    robj *o, *new, *aux;</span><br><span class="line">    <span class="comment">// 取出值对象</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 检查对象是否存在，以及类型是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,REDIS_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将对象的整数值保存到 value 参数中</span></span><br><span class="line">    <span class="comment">// 并取出 incr 参数的值</span></span><br><span class="line">    <span class="keyword">if</span> (getLongDoubleFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != REDIS_OK ||</span><br><span class="line">        getLongDoubleFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;incr,<span class="literal">NULL</span>) != REDIS_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 进行加法计算，并检查是否溢出</span></span><br><span class="line">    value += incr;</span><br><span class="line">    <span class="keyword">if</span> (isnan(value) || isinf(value)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;increment would produce NaN or Infinity&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用一个包含新值的新对象替换现有的值对象</span></span><br><span class="line">    new = createStringObjectFromLongDouble(value);</span><br><span class="line">    <span class="keyword">if</span> (o)</span><br><span class="line">        dbOverwrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>],new);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],new);</span><br><span class="line">    <span class="comment">// 向数据库发送键被修改的信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,<span class="string">&quot;incrbyfloat&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 将服务器设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">    <span class="comment">// 回复</span></span><br><span class="line">    addReplyBulk(c,new);</span><br><span class="line">    <span class="comment">/* Always replicate INCRBYFLOAT as a SET command with the final value</span></span><br><span class="line"><span class="comment">     * in order to make sure that differences in float precision or formatting</span></span><br><span class="line"><span class="comment">     * will not create differences in replicas or after an AOF restart. */</span></span><br><span class="line">    <span class="comment">// 在传播 INCRBYFLOAT 命令时，总是用 SET 命令来替换 INCRBYFLOAT 命令</span></span><br><span class="line">    <span class="comment">// 从而防止因为不同的浮点精度和格式化造成 AOF 重启时的数据不一致</span></span><br><span class="line">    aux = createStringObject(<span class="string">&quot;SET&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    rewriteClientCommandArgument(c,<span class="number">0</span>,aux);</span><br><span class="line">    decrRefCount(aux);</span><br><span class="line">    rewriteClientCommandArgument(c,<span class="number">2</span>,new);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：同上类似，int改成float</p><h2 id="mget——mgetCommand"><a href="#mget——mgetCommand" class="headerlink" title="mget——mgetCommand"></a>mget——mgetCommand</h2><p>示例：MGET KEY1 KEY2 .. KEYN</p><ul><li>一个包含所有给定 key 的值的列表。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mgetCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    addReplyMultiBulkLen(c,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 查找并返回所有输入键的值</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 查找键 c-&gt;argc[j] 的值</span></span><br><span class="line">        robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 值不存在，向客户端发送空回复</span></span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o-&gt;type != REDIS_STRING) &#123;</span><br><span class="line">                <span class="comment">// 值存在，但不是字符串类型</span></span><br><span class="line">                addReply(c,shared.nullbulk);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 值存在，并且是字符串</span></span><br><span class="line">                addReplyBulk(c,o);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：从dict中查找，如果存在则返回；如果没有则返回空。这里没有调用过期函数。 </p><h2 id="getset——getsetCommand"><a href="#getset——getsetCommand" class="headerlink" title="getset——getsetCommand"></a>getset——getsetCommand</h2><p>示例：GETSET KEY_NAME VALUE</p><ul><li><p>返回给定 key 的旧值。 当 key 没有旧值时，即 key 不存在时，返回 nil 。</p><p>  当 key 存在但不是字符串类型时，返回一个错误。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">getsetCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    <span class="comment">// 取出并返回键的值对象</span></span><br><span class="line">    <span class="keyword">if</span> (getGenericCommand(c) == REDIS_ERR) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 编码键的新值 c-&gt;argv[2]</span></span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 将数据库中关联键 c-&gt;argv[1] 和新值对象 c-&gt;argv[2]</span></span><br><span class="line">    setKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_STRING,<span class="string">&quot;set&quot;</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    <span class="comment">// 将服务器设为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 说明：结合了get和set方法，无法解决并发计数问题</p><h2 id="mset——msetCommand"><a href="#mset——msetCommand" class="headerlink" title="mset——msetCommand"></a>mset——msetCommand</h2><p>示例：MSET key1 value1 key2 value2 .. keyN valueN </p><ul><li>总是返回 OK 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msetCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    msetGenericCommand(c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">msetGenericCommand</span><span class="params">(redisClient *c, <span class="type">int</span> nx)</span> &#123;</span><br><span class="line">    <span class="type">int</span> j, busykeys = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 键值参数不是成相成对出现的，格式不正确</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;wrong number of arguments for MSET&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Handle the NX flag. The MSETNX semantic is to return zero and don&#x27;t</span></span><br><span class="line"><span class="comment">     * set nothing at all if at least one already key exists. */</span></span><br><span class="line">    <span class="comment">// 如果 nx 参数为真，那么检查所有输入键在数据库中是否存在</span></span><br><span class="line">    <span class="comment">// 只要有一个键是存在的，那么就向客户端发送空回复</span></span><br><span class="line">    <span class="comment">// 并放弃执行接下来的设置操作</span></span><br><span class="line">    <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lookupKeyWrite(c-&gt;db,c-&gt;argv[j]) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                busykeys++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 键存在</span></span><br><span class="line">        <span class="comment">// 发送空白回复，并放弃执行接下来的设置操作</span></span><br><span class="line">        <span class="keyword">if</span> (busykeys) &#123;</span><br><span class="line">            addReply(c, shared.czero);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置所有键值对</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对值对象进行解码</span></span><br><span class="line">        c-&gt;argv[j+<span class="number">1</span>] = tryObjectEncoding(c-&gt;argv[j+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 将键值对关联到数据库</span></span><br><span class="line">        <span class="comment">// c-&gt;argc[j] 为键</span></span><br><span class="line">        <span class="comment">// c-&gt;argc[j+1] 为值</span></span><br><span class="line">        setKey(c-&gt;db,c-&gt;argv[j],c-&gt;argv[j+<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_STRING,<span class="string">&quot;set&quot;</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将服务器设为脏</span></span><br><span class="line">    server.dirty += (c-&gt;argc<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 设置成功</span></span><br><span class="line">    <span class="comment">// MSET 返回 OK ，而 MSETNX 返回 1</span></span><br><span class="line">    addReply(c, nx ? shared.cone : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 说明：结合多个set方法</p><h2 id="msetnx——msetnxCommand"><a href="#msetnx——msetnxCommand" class="headerlink" title="msetnx——msetnxCommand"></a>msetnx——msetnxCommand</h2><p>示例：MSETNX key1 value1 key2 value2 .. keyN valueN </p><ul><li>当所有 key 都成功设置，返回 1 。 如果所有给定 key 都设置失败(至少有一个 key 已经存在)，那么返回 0 。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//t_string.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msetnxCommand</span><span class="params">(redisClient *c)</span> &#123;</span><br><span class="line">    msetGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：同上</p><div class="table-container"><table><thead><tr><th>命令</th><th>作用</th><th>int编码时间复杂度</th><th>embstr编码时间复杂度</th><th>raw编码实现时间复杂度</th></tr></thead><tbody><tr><td>SET</td><td>设置给定 key 的值</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>GET</td><td>获取给定 key 的值</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>APPEND</td><td>将值附加到key原有的string后面</td><td>O(n),n为被添加string的长度</td><td>O(n)</td><td>O(n)</td></tr><tr><td>INCRBYFLOAT</td><td>为 key 中所储存的值加上指定的浮点数增量值</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>INCRBY</td><td>为 key 所储存的值加上指定值</td><td>O(1)</td><td>ERROR (不允许这种操作）</td><td>ERROR</td></tr><tr><td>DECRBY</td><td>为 key 所储存的值减去指定额值</td><td>O(1)</td><td>ERROR</td><td>ERROR</td></tr><tr><td>STRLEN</td><td>计算字符串的长度</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>SETRANGE</td><td>用value参数覆写给定key所储存的字符串值，从偏移量offset开始</td><td>O(n)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>GETRANGE</td><td>获取存储在指定 key 中字符串的子字符串</td><td>O(n),<code>N</code> 为要返回的字符串的长度</td><td>O(n)</td><td>O(n)</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>redis-源码学习-基础数据类型</title>
      <link href="/p/4161149344.html"/>
      <url>/p/4161149344.html</url>
      
        <content type="html"><![CDATA[<p>Redis构建了自己的类型系统</p><ul><li>redisObject 对象</li><li>基于 redisObject 对象的类型检查</li><li>基于 redisObject 对象的显式多态函数</li><li>对 redisObject 进行分配、共享和销毁的机制</li></ul><span id="more"></span><h1 id="RedisObject-编码结构"><a href="#RedisObject-编码结构" class="headerlink" title="RedisObject 编码结构"></a><strong>RedisObject 编码结构</strong></h1><p>redisObject 是 Redis 类型系统的核心，数据库中的每个键、值，以及 Redis 本身处理的参数，都表示为这种数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">     <span class="comment">// 类型</span></span><br><span class="line">     <span class="type">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">     <span class="comment">// 编码</span></span><br><span class="line">     <span class="type">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">     <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">     <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line">     <span class="comment">// 引用计数</span></span><br><span class="line">     <span class="type">int</span> refcount;</span><br><span class="line">     <span class="comment">// 指向实际值的指针</span></span><br><span class="line">     <span class="type">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p>说明：type 、 encoding 和 ptr 是最重要的三个属性</p><ul><li>type（类型）<ul><li>REDIS_STRING 0 // 字符串</li><li>REDIS_LIST 1      // 列表</li><li>REDIS_SET 2       // 集合</li><li>REDIS_ZSET 3     // 有序集</li><li>REDIS_HASH 4    // 哈希表</li></ul></li><li>encoding（编码）<ul><li>REDIS_ENCODING_RAW 0             // 编码为字符串</li><li>REDIS_ENCODING_INT 1               // 编码为整数</li><li>REDIS_ENCODING_HT 2                // 编码为字典</li><li>REDIS_ENCODING_ZIPMAP 3        // 编码为 zipmap</li><li>REDIS_ENCODING_LINKEDLIST 4   // 编码为双端链表</li><li>REDIS_ENCODING_ZIPLIST 5          // 编码为压缩列表</li><li>REDIS_ENCODING_INTSET 6          // 编码为整数集合</li><li>REDIS_ENCODING_SKIPLIST 7        // 编码为跳跃表</li></ul></li><li>ptr<ul><li>指向实际保存值得数据结构<ul><li>这个数据结构由type属性 和encoding 属性决定</li></ul></li><li>例子<ul><li>redisObject 的 type属性为REDIS_LIST，encoding属性为REDIS_ENCODING_LINKEDLIST</li><li>那么这个对象就是一个Redis列表，它的值保存在一个双端链表内，而ptr指针就指向这个双端链表</li></ul></li></ul></li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/1.png" class=""><p><strong>命令的类型检查和多态</strong></p><p>当执行一个处理数据类型的命令时，Redis执行以下步骤：</p><ul><li>根据给定 key ，在数据库字典中查找和它像对应的 redisObject ，如果没找到，就返回NULL 。</li><li>检查 redisObject 的 type 属性和执行命令所需的类型是否相符，如果不相符，返回类型错误。</li><li>根据 redisObject 的 encoding 属性所指定的编码，选择合适的操作函数来处理底层的数据结构。</li><li>返回数据结构的操作结果作为命令的返回值</li></ul><h2 id="REDIS-ENCODING-INT"><a href="#REDIS-ENCODING-INT" class="headerlink" title="REDIS_ENCODING_INT"></a>REDIS_ENCODING_INT</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/2.png" class=""><p>如果一个字符串对象保存的是整数值，并且这个整数值可以用long类型来表示，那么字符串对象会将整数值保存在字符串对象结构 的ptr属性里面（将void* 转换成long），并将字符串对象的编码设置为int。</p><h2 id="REDIS-ENCODING-RAW"><a href="#REDIS-ENCODING-RAW" class="headerlink" title="REDIS_ENCODING_RAW"></a>REDIS_ENCODING_RAW</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/3.png" class=""><p>如果字符串对象保存的是一个字符串字符串值， 并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS） 来保存这个字符串值，并将 对象的编码设置为raw。</p><h2 id="REDIS-ENCODING-EMBSTR"><a href="#REDIS-ENCODING-EMBSTR" class="headerlink" title="REDIS_ENCODING_EMBSTR"></a>REDIS_ENCODING_EMBSTR</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/4.png" class=""><p>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节，那么字符串对象将使用embstr编码的方式来保存这个字符串值。</p><ul><li>embstr 编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。</li><li>释放embstr编码的字符串对象只需要调用一次内存释放函数，而释放raw编码的字符串对象需要调用两次内存释放函数。</li><li>因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够 更好地利用缓存带来的优势。</li></ul><h2 id="REDIS-ENCODING-ZIPLIST"><a href="#REDIS-ENCODING-ZIPLIST" class="headerlink" title="REDIS_ENCODING_ZIPLIST"></a>REDIS_ENCODING_ZIPLIST</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/5.png" class=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/6.png" class=""><p>当列表对想可以同时满足以下两个条件时，列表对象使用ziplist编码：</p><ul><li>列表对象保存的所有字符串元素的长度都小于64字节</li><li>列表对象保存的元素数量小于512个，不能满足这两个条件的列表对象需要使用linkedlist编码</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/7.png" class=""><p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码</p><ul><li>哈希对象保存所有键值对的键和值的字符串长度都小于64字节</li><li>哈希对象保存的键值对梳理小于512个，不能满足这两个条件的哈希对象需要使用hashtable编码</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/8.png" class=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/9.png" class=""><h2 id="REDIS-ENCODING-LINKEDLIST"><a href="#REDIS-ENCODING-LINKEDLIST" class="headerlink" title="REDIS_ENCODING_LINKEDLIST"></a>REDIS_ENCODING_LINKEDLIST</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/10.png" class=""><h2 id="REDIS-ENCODING-HT"><a href="#REDIS-ENCODING-HT" class="headerlink" title="REDIS_ENCODING_HT"></a>REDIS_ENCODING_HT</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/11.png" class=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/12.png" class=""><h2 id="REDIS-ENCODING-SKIPLIST"><a href="#REDIS-ENCODING-SKIPLIST" class="headerlink" title="REDIS_ENCODING_SKIPLIST"></a>REDIS_ENCODING_SKIPLIST</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/13.png" class=""><h2 id="REDIS-ENCODING-INTSET"><a href="#REDIS-ENCODING-INTSET" class="headerlink" title="REDIS_ENCODING_INTSET"></a>REDIS_ENCODING_INTSET</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/4161149344/14.png" class=""><p>当集合对象可以同事满足以下两个条件时，对象使用intset编码：</p><ul><li>集合对象保存的所有元素都是整数值</li><li>集合对象保存的元素数量不超过512个</li></ul><p>不满足这两个条件的集合对象需要使用hashtable编码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *对象类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_STRING 0  <span class="comment">// 字符串</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_LIST   1  <span class="comment">// 列表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_SET    2  <span class="comment">// 集合</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ZSET   3  <span class="comment">// 有序集</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_HASH   4  <span class="comment">// 哈希表</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对象编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_RAW          0   <span class="comment">// 编码为字符串</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_INT          1   <span class="comment">// 编码为整数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_HT           2   <span class="comment">// 编码为哈希表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_ZIPMAP       3   <span class="comment">// 编码为 zipmap</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_LINKEDLIST   4   <span class="comment">// 编码为双端链表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_ZIPLIST      5   <span class="comment">// 编码为压缩列表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_INTSET       6   <span class="comment">// 编码为整数集合</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_SKIPLIST     7   <span class="comment">// 编码为跳跃表</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_ENCODING_EMBSTR       8   <span class="comment">// 编码为内嵌的sds字符串类型</span></span></span><br></pre></td></tr></table></figure><p>Redis 数据结构和常见数据结构的实现对比</p><div class="table-container"><table><thead><tr><th></th><th>分类（常见算法）</th><th>Redis（实现算法）</th><th>是否有序</th><th>运行元素重复</th></tr></thead><tbody><tr><td><strong>字符串</strong></td><td>字符串</td><td><strong>String</strong>——(整数，动态字符串)</td><td>*</td><td>*</td></tr><tr><td><strong>列表</strong></td><td>列表——（数组/链表）</td><td><strong>List</strong>——（双向链表，压缩列表）</td><td>是</td><td>是</td></tr><tr><td><strong>集合</strong></td><td>集合——（基于字典)</td><td><strong>Set</strong> ——（基于字典，数组）</td><td>否</td><td>否</td></tr><tr><td>有序集合——（二叉树）</td><td><strong>Zset</strong>——（跳跃表，压缩列表）</td><td>是</td><td></td><td></td></tr><tr><td><strong>字典</strong></td><td>字典——（哈希表）</td><td><strong>Hash</strong>——（哈希表，压缩列表）</td><td>否</td><td>key不能重复</td></tr><tr><td>有序字典——（二叉树）</td><td>*</td><td>是</td><td></td><td></td></tr></tbody></table></div><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h1><h2 id="simple-dynamic-string-SDS"><a href="#simple-dynamic-string-SDS" class="headerlink" title="simple dynamic string(SDS)"></a>simple dynamic string(SDS)</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存字符串对象的结构，之前的版本2.9</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// buf 中已占用空间的长度</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="comment">// buf 中剩余可用空间的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 数据空间</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2.4版本</span></span><br><span class="line"><span class="comment">/* Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//3.2.4版本</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr16</span> &#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint16_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr32</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint32_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="type">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="type">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="type">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="压缩列表-ziplist"><a href="#压缩列表-ziplist" class="headerlink" title="压缩列表-ziplist"></a>压缩列表-ziplist</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 虚拟 ziplist 结构，实际上无该结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&#123;</span></span><br><span class="line">     <span class="type">uint32_t</span> zlbytes;      <span class="comment">/*整个压缩列表占用内存字节数*/</span></span><br><span class="line">     <span class="type">uint32_t</span> zltail;       <span class="comment">/*尾部距离列表起始位置有多少字节*/</span></span><br><span class="line">     <span class="type">uint16_t</span> zllen;        <span class="comment">/*存储节点个数*/</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span>* entryList[]; <span class="comment">/*列表节点*/</span></span><br><span class="line">     <span class="type">unit8_t</span> <span class="type">char</span> zlend;    <span class="comment">/*尾部标识,特殊标识0XFF(十进制255)*/</span></span><br><span class="line">&#125;ziplist;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 保存 ziplist 节点信息的结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prevrawlensize, prevrawlen;  <span class="comment">/*前置节点的长度,</span></span><br><span class="line"><span class="comment">                                                编码prevrawlen所需的字节大小*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> lensize, len;  <span class="comment">/*当前节点值的长度, 编码 len 所需的字节大小*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> headersize;    <span class="comment">/*当前节点 header 的大小</span></span><br><span class="line"><span class="comment">                                  值 = prevrawlensize + lensize*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> encoding;     <span class="comment">/*当前节点值所使用的编码类型*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p;           <span class="comment">/*指向当前节点的指针*/</span></span><br><span class="line">&#125;zlentry;</span><br></pre></td></tr></table></figure><h2 id="双端链表-list"><a href="#双端链表-list" class="headerlink" title="双端链表-list"></a>双端链表-list</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;     <span class="comment">/* 表头节点  */</span></span><br><span class="line">    listNode *tail;     <span class="comment">/* 表尾节点  */</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr);  <span class="comment">/* 节点值复制函数  */</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr);  <span class="comment">/* 节点值释放函数  */</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr, <span class="type">void</span> *key);   <span class="comment">/* 节点值对比函数 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len;    <span class="comment">/* 链表所包含的节点数量 */</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 双端链表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span>   <span class="comment">/* 前置节点 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span>   <span class="comment">/* 后置节点 */</span></span><br><span class="line">    <span class="type">void</span> *value;             <span class="comment">/* 节点的值 */</span></span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><h2 id="字典-DICT"><a href="#字典-DICT" class="headerlink" title="字典-DICT"></a>字典-DICT</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;     <span class="comment">/* 类型特定函数 */</span></span><br><span class="line">    <span class="type">void</span> *privdata;     <span class="comment">/* 私有数据 */</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];       <span class="comment">/* 哈希表 */</span></span><br><span class="line">    <span class="type">int</span> rehashidx;      <span class="comment">/* rehash 索引,当 rehash 不在进行时，值为 -1 */</span></span><br><span class="line">    <span class="type">int</span> iterators;      <span class="comment">/* 目前正在运行的安全迭代器的数量*/</span></span><br><span class="line">&#125; dict;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;      <span class="comment">/* 哈希表数组 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;     <span class="comment">/* 哈希表大小 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask; <span class="comment">/* 哈希表大小掩码，用于计算索引值，</span></span><br><span class="line"><span class="comment">                            总是等于 size - 1*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;     <span class="comment">/* 该哈希表已有节点的数量 */</span></span><br><span class="line">&#125; dictht;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 哈希表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;      <span class="comment">/* 键 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span>         <span class="comment">/* 值 */</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        <span class="type">uint64_t</span> u64;</span><br><span class="line">        <span class="type">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">/* 指向下个哈希表节点，形成链表*/</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><h2 id="整数集合-intset"><a href="#整数集合-intset" class="headerlink" title="整数集合-intset"></a>整数集合-intset</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  整数集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;  <span class="comment">/* 编码方式 */</span></span><br><span class="line">    <span class="type">uint32_t</span> length;    <span class="comment">/* 集合包含的元素数量 */</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">/* 保存元素的数组 */</span></span><br><span class="line">&#125; intset;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * intset 的编码方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure><h2 id="跳跃表-skiplist"><a href="#跳跃表-skiplist" class="headerlink" title="跳跃表-skiplist"></a>跳跃表-skiplist</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 有序集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字典，键为成员，值为分值</span></span><br><span class="line">    <span class="comment">// 用于支持 O(1) 复杂度的按成员取分值操作</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// 跳跃表，按分值排序成员</span></span><br><span class="line">    <span class="comment">// 用于支持平均复杂度为 O(log N) 的按分值定位成员操作</span></span><br><span class="line">    <span class="comment">// 以及范围操作</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点的数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">    <span class="type">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * zset使用一个特殊版本的跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="type">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回一个随机值，用作新跳跃表节点的层数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回值介乎 1 和 ZSKIPLIST_MAXLEVEL 之间（包含 ZSKIPLIST_MAXLEVEL），</span></span><br><span class="line"><span class="comment"> * 根据随机算法所使用的幂次定律，越大的值生成的几率越小。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * T = O(N)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">zslRandomLevel</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        <span class="comment">//这里取小于0xffff的数，有0.25的概率level+1，因此level有1/4概率为2, 1/16的概率为3等等</span></span><br><span class="line"> </span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>safe-利用redis渗透</title>
      <link href="/p/381497824.html"/>
      <url>/p/381497824.html</url>
      
        <content type="html"><![CDATA[<p>主要利用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config set dir//设置备份目录</span><br><span class="line"></span><br><span class="line">config set dbfilename//设置备份文件名称</span><br></pre></td></tr></table></figure><p>可以自己测试备份一下，备份的内容会有你写入的所有的kv，所以如果写入一个kv是这样<code>&lt;?php eval($_GET[&#39;cmd&#39;]);</code>的话，会写入dir/dbfilename中，所以写入到一个php的目录即可达到效果</p><p>也可以用来写入ssh公钥到.ssh/authorized_keys中可以免密登陆服务器</p>]]></content>
      
      
      <categories>
          
          <category> Safe </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>json库精度丢失问题</title>
      <link href="/p/2379945963.html"/>
      <url>/p/2379945963.html</url>
      
        <content type="html"><![CDATA[<p>当用<code>enconding/json</code>包的时候，数字默认是处理为float64类型的，这就导致了int64可能会丢失精度</p><span id="more"></span><p>举个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">err</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;&#123;\&quot;id\&quot;: 1153273393983037404&#125;&quot;</span></span><br><span class="line">mm := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">_ = json.Unmarshal([]<span class="type">byte</span>(s), &amp;mm)</span><br><span class="line">jstr, _ := json.Marshal(mm)</span><br><span class="line">fmt.Println(<span class="type">string</span>(jstr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1153273393983037400</span>&#125;</span><br></pre></td></tr></table></figure><p>本来json里面的id是1153273393983037404,转成<code>interface&#123;&#125;</code>后会变成<code>float64</code>类型，再转回json的时候精度丢失就发生了</p><p>解决方案</p><ol><li><p>直接用string存，然后自行用<code>strconv</code>转换</p></li><li><p>使用<code>json.decoder</code>来替换<code>Unmarshal</code>，其实底层也是用<code>string</code>存，不过是封装好了的。。，上个实例</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">right</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;&#123;\&quot;id\&quot;: 1153273393983037404&#125;&quot;</span></span><br><span class="line">mm := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">decoder := json.NewDecoder(bytes.NewReader([]<span class="type">byte</span>(s)))</span><br><span class="line">decoder.UseNumber()</span><br><span class="line">_ = decoder.Decode(&amp;mm)</span><br><span class="line">fmt.Println(mm)</span><br><span class="line">jstr, _ := json.Marshal(mm)</span><br><span class="line">fmt.Println(<span class="type">string</span>(jstr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line"><span class="keyword">map</span>[id:<span class="number">1153273393983037404</span>]</span><br><span class="line">&#123;<span class="string">&quot;id&quot;</span>:<span class="number">1153273393983037404</span>&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-base-attr</title>
      <link href="/p/4043410464.html"/>
      <url>/p/4043410464.html</url>
      
        <content type="html"><![CDATA[<p>在 Python 中，数据的属性和处理数据的方法统称属性（attribute）。其实，方法只是可调用的属性。除了这二者之外，我们还可以创建特性（property），在不改变类接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性<br><span id="more"></span></p><h1 id="property"><a href="#property" class="headerlink" title="property"></a>property</h1><p><code>property</code>可以把一个实例方法变成其同名属性，以支持.号访问，它亦可标记设置限制，加以规范<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._t1=<span class="number">0</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;getter&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._t1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @t1.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t1</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;setter&#x27;</span>)</span><br><span class="line">        self._t1 = value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.t1=<span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(a.t1)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">setter</span><br><span class="line">getter</span><br><span class="line"><span class="number">123</span></span><br><span class="line"></span><br><span class="line">也可以老式写法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._t1=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t1_getter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;getter&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._t1</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">t1_setter</span>(<span class="params">self,value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;setter&#x27;</span>)</span><br><span class="line">        self._t1 = value</span><br><span class="line">    t1 = <span class="built_in">property</span>(t1_getter,t1_setter)</span><br></pre></td></tr></table></figure></p><p>除了特性，Python 还提供了丰富的 API，用于控制属性的访问权限，以及实现动态属性。使用点号访问属性时（如 <code>obj.attr</code>），Python 解释器会调用特殊的方法（如 <code>__getattr__</code> 和 <code>__setattr__</code>）计算属性。用户自己定义的类可以通过 <code>__getattr__</code> 方法实现“虚拟属性”，当访问不存在的属性时（如 <code>obj.no_such_attribute</code>），即时计算属性的值。</p><h1 id="attr"><a href="#attr" class="headerlink" title="attr"></a>attr</h1><h2 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a><code>__dict__</code></h2><p>　　一个映射，存储对象或类的可写属性。有 <code>__dict__</code> 属性的对象，任何时候都能随意设置新属性。如果类有 <code>__slots__</code> 属性，它的实例可能没有 <code>__dict__</code> 属性。</p><h2 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a><code>__slots__</code></h2><p>　　类可以定义这个这属性，限制实例能有哪些属性。<code>__slots__</code> 属性的值是一个字符串组成的元组，指明允许有的属性。如果 <code>__slots__</code> 中没有 <code>__dict__</code>，那么该类的实例没有 <code>__dict__</code> 属性，实例只允许有指定名称的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    __slots__ = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>]</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.a = <span class="number">1</span></span><br><span class="line">a.b = <span class="number">2</span></span><br><span class="line">a.c = <span class="number">3</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">AttributeError: <span class="string">&#x27;A&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;c&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    __slots__ = (<span class="string">&#x27;__dict__&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a.a = <span class="number">1</span></span><br><span class="line">a.b = <span class="number">2</span></span><br><span class="line">a.c = <span class="number">3</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">不报错</span><br></pre></td></tr></table></figure><h2 id="一些处理属性的内置函数"><a href="#一些处理属性的内置函数" class="headerlink" title="一些处理属性的内置函数"></a>一些处理属性的内置函数</h2><h3 id="dir-object"><a href="#dir-object" class="headerlink" title="dir([object])"></a><code>dir([object])</code></h3><p>　　列出对象的大多数属性。<a href="https://docs.python.org/3/library/functions.html#dir">官方文档</a>说，dir 函数的目的是交互式使用，因此没有提供完整的属性列表，只列出一组“重要的”属性名。<code>dir</code> 函数能审查有或没有<code>__dict__</code> 属性的对象。<code>dir</code> 函数不会列出 <code>__dict__</code> 属性本身，但会列出其中的键。<code>dir</code> 函数也不会列出类的几个特殊属性，例如 <code>__mro__</code>、<code>__bases__</code> 和 <code>__name__</code>。如果没有指定可选的 <code>object</code> 参数，dir 函数会列出当前作用域中的名称。</p><h3 id="getattr-object-name-default"><a href="#getattr-object-name-default" class="headerlink" title="getattr(object, name[, default])"></a><code>getattr(object, name[, default])</code></h3><p>　　从 <code>object</code> 对象中获取 <code>name</code> 字符串对应的属性。获取的属性可能来自对象所属的类或超类。如果没有指定的属性，<code>getattr</code> 函数抛出 <code>AttributeError</code> 异常，或者返回 <code>default</code> 参数的值（如果设定了这个参数的话）。</p><h3 id="hasattr-object-name"><a href="#hasattr-object-name" class="headerlink" title="hasattr(object, name)"></a><code>hasattr(object, name)</code></h3><p>　　如果 <code>object</code> 对象中存在指定的属性，或者能以某种方式（例如继承）通过 <code>object</code> 对象获取指定的属性，返回<code>True</code>。<a href="https://docs.python.org/3/library/functions.html#hasattr">官方文档</a>说道：“这个函数的实现方法是调用 <code>getattr(object, name)</code>函数，看看是否抛出 <code>AttributeError</code> 异常。　</p><h3 id="setattr-object-name-value"><a href="#setattr-object-name-value" class="headerlink" title="setattr(object, name, value)"></a><code>setattr(object, name, value)</code></h3><p>　　把 <code>object</code> 对象指定属性的值设为 <code>value</code>，前提是 <code>object</code> 对象能接受那个值。这个函数可能会创建一个新属性，或者覆盖现有的属性。</p><h3 id="vars-object"><a href="#vars-object" class="headerlink" title="vars([object])"></a><code>vars([object])</code></h3><p>　　返回 object 对象的 <code>__dict__</code> 属性；如果实例所属的类定义了 <code>__slots__</code> 属性，实例没有 <code>__dict__</code> 属性，那么 <code>vars</code> 函数不能处理那个实例（相反，<code>dir</code> 函数能处理这样的实例）。如果没有指定参数，那么 <code>vars()</code> 函数的作用与 <code>locals()</code> 函数一样：返回表示本地作用域的字典。　　</p><h2 id="处理属性的特殊方法"><a href="#处理属性的特殊方法" class="headerlink" title="处理属性的特殊方法"></a>处理属性的特殊方法</h2><p>　　使用点号或内置的 <code>getattr</code>、<code>hasattr</code>和 <code>setattr</code> 函数存取属性都会触发相应的特殊方法。但是，直接通过实例的 <code>__dict__</code> 属性读写属性不会触发这些特殊方法——如果需要，通常会使用这种方式跳过特殊方法。</p><h3 id="getattribute-obj-39-attr-39"><a href="#getattribute-obj-39-attr-39" class="headerlink" title="__getattribute__(obj, &#39;attr&#39;)"></a><code>__getattribute__(obj, &#39;attr&#39;)</code></h3><p>　　<code>obj.attr</code> 和 <code>getattr(obj, &#39;attr&#39;, 42)</code> 都会触发 <code>Class.__getattribute__(obj, &#39;attr&#39;)</code> 方法。</p><h3 id="delattr-self-name"><a href="#delattr-self-name" class="headerlink" title="__delattr__(self, name)"></a><code>__delattr__(self, name)</code></h3><p>　　只要使用 del 语句删除属性，就会调用这个方法。例如，<code>del obj.attr</code> 语句触发 <code>Class.__delattr__(obj, &#39;attr&#39;)</code> 方法。</p><h3 id="dir-self"><a href="#dir-self" class="headerlink" title="__dir__(self)"></a><code>__dir__(self)</code></h3><p>　　把对象传给 <code>dir</code> 函数时调用，列出属性。例如，<code>dir(obj)</code> 触发 <code>Class.__dir__(obj)</code> 方法。</p><h3 id="getattr-self-name"><a href="#getattr-self-name" class="headerlink" title="__getattr__(self, name)"></a><code>__getattr__(self, name)</code></h3><p>　　仅当获取指定的属性失败，搜索过 <code>obj</code>、<code>Class</code> 和超类之后调用。表达式 <code>obj.no_such_attr、getattr(obj, &#39;no_such_attr&#39;)</code> 和 <code>hasattr(obj, &#39;no_such_attr&#39;)</code> 可能会触发 <code>Class.__getattr__(obj, &#39;no_such_attr&#39;)</code> 方法，但是，仅当在 <code>obj</code>、<code>Class</code> 和超类中找不到指定的属性时才会触发。</p><h3 id="getattribute-self-name"><a href="#getattribute-self-name" class="headerlink" title="__getattribute__(self, name)"></a><code>__getattribute__(self, name)</code></h3><p>　　尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法时除外。点号与 <code>getattr</code> 和 <code>hasattr</code> 内置函数会触发这个方法。调用 <code>__getattribute__</code> 方法且抛出 <code>AttributeError</code> 异常时，才会调用 <code>__getattr__</code> 方法。为了在获取 <code>obj</code> 实例的属性时不导致无限递归，<code>__getattribute__</code> 方法的实现要使用 <code>super().__getattribute__(obj, name)</code>。</p><h3 id="setattr-self-name-value"><a href="#setattr-self-name-value" class="headerlink" title="__setattr__(self, name, value)"></a><code>__setattr__(self, name, value)</code></h3><p>　　尝试设置指定的属性时总会调用这个方法。点号和 <code>setattr</code> 内置函数会触发这个方法。例如，<code>obj.attr = 42</code> 和 <code>setattr(obj, &#39;attr&#39;, 42)</code> 都会触发 <code>Class.__setattr__(obj, ‘attr’, 42)</code> 方法</p><p><strong><code>__getattribute__</code> 和<code>__setattr__</code> 不管怎样都会调用</strong></p><p>查找属性时，如<code>obj.attr</code>，如果<code>Python</code>发现这个属性<code>attr</code>有个<code>__get__</code>方法，Python会调用<code>attr</code>的<code>__get__</code>方法，返回<code>__get__</code>方法的返回值，而不是返回<code>attr</code>(这一句话并不准确，我只是希望你能对descriptor有个初步的概念)。</p><p>Python中iterator(怎么扯到Iterator了？)是实现了iterator协议的对象，也就是说它实现了下面两个方法<code>__iter__</code>和<code>next()</code>。类似的，descriptor也是实现了某些特定方法的对象。descriptor的特定方法是<code>__get__</code>,<code>__set__</code>和<code>__delete__</code>，其中<code>__set__</code>和<code>__delete__</code>方法是可选的。iterator必须依附某个对象而存在(由对象的<code>__iter__</code>方法返回)，descriptor也必须依附对象，作为对象的一个属性，它而不能单独存在。还有一点，descriptor必须存在于类的<code>__dict__</code>中，这句话的意思是只有在类的<code>__dict__</code>中找到属性，Python才会去看看它有没有<code>__get__</code>等方法，对一个在实例的<code>__dict__</code>中找到的属性，Python根本不理会它有没有<code>__get__</code>等方法，直接返回属性本身。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self._value = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, instance_type</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;call __get__&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self._value.get(instance, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__set__</span>(<span class="params">self, instance, value</span>):</span><br><span class="line">        self._value[instance] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Another0</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.test = Test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Another1</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    test = Test()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(Another0().test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(Another1.test)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>)</span><br><span class="line">    <span class="built_in">print</span>(Another1().test)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;__main__.Test <span class="built_in">object</span> at <span class="number">0x107bc8860</span>&gt;</span><br><span class="line">--------------------</span><br><span class="line">call __get__</span><br><span class="line"><span class="number">0</span></span><br><span class="line">--------------------</span><br><span class="line">call __get__</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>math-machine_learning-svm</title>
      <link href="/p/3148169752.html"/>
      <url>/p/3148169752.html</url>
      
        <content type="html"><![CDATA[<p>支持向量机（SVM）是90年代中期发展起来的基于统计学习理论的一种机器学习方法，通过寻求结构化风险最小来提高学习机泛化能力，实现经验风险和置信范围的最小化，从而达到在统计样本量较少的情况下，亦能获得良好统计规律的目的。</p><p>通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，即支持向量机的学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p><span id="more"></span><p>由简至繁支持向量机(support vector machine,SVM)可分类为三类：</p><ol><li>线性可分（linear SVM in linearly separable case）的线性SVM<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3148169752/hard.png" class="" title="hard"></li><li>线性不可分的线性SVM <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3148169752/soft.png" class="" title="soft"></li><li>非线性（nonlinear）SVM<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3148169752/kernel.png" class="" title="kernel"></li></ol><p>也可以称为：</p><ol><li>hard-margin SVM</li><li>soft-margin SVM</li><li>kernel SVM</li></ol><h1 id="什么是线性可分"><a href="#什么是线性可分" class="headerlink" title="什么是线性可分"></a>什么是线性可分</h1><p>给定一个数据集，如果存在某个超平面$w^T \cdot x + b = 0$能将测试机的正实例和负实例完全正确的划分到超平面两侧，即</p><script type="math/tex; mode=display">\left\{ \begin{array} { l l } { w^T \cdot x_i +b > 0 } & { y_i = +1 } \\ { w^T \cdot x_i +b < 0 } & { y_i = -1 } \end{array} \right.</script><p>称数据集为线性可分数据集（linearly separable data set） 否则，称为线性不可分数据集</p><p>如何找到这个超平面呢？</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3148169752/1.png" class="" title="多个超平面"><p>对于一个数据集，可能有很多的线来分割,直观来看，黄色这条线应该是适应性最好的，离直线两边的数据的间隔最大，对训练集的数据的局限性或噪声有最大的“容忍”能力。</p><h1 id="为什么叫SVM"><a href="#为什么叫SVM" class="headerlink" title="为什么叫SVM"></a>为什么叫SVM</h1><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3148169752/2.png" class="" title="SVM"><p>怎么找到这个平面呢？将距离分离超平面最近的两个不同类别的样本点称为支持向量（Support Vector）的，构成了两条平行于分离超平面的长带，二者之间的距离称之为Margin。显然，Margin更大，则分类正确的确信度更高（与超平面的距离表示分类的确信度，距离越远则分类正确的确信度越高）。</p><p>SVM就是求解支持向量的，所以叫支持向量机。</p><h1 id="间隔"><a href="#间隔" class="headerlink" title="间隔"></a>间隔</h1><p>那么找到这个平面的问题就转换成了，怎么找到这个最大Margin。找到这个Margin就要知道间隔的定义了。<br>间隔分为函数间隔 (functional margin) 和几何间隔 (geometric margin)</p><h2 id="函数间隔"><a href="#函数间隔" class="headerlink" title="函数间隔"></a>函数间隔</h2><p>函数间隔的定义为</p><script type="math/tex; mode=display">\hat { \gamma } = y \left( \boldsymbol { w } ^ { \mathrm { T } } \boldsymbol { x } + b \right) = y f ( \boldsymbol { x } )</script><p>函数间隔其实就是类别标签乘上了f(x)的值，可以看到，该值永远是大于等于0的，正好符合了距离的概念，距离总不能是负的吧。</p><p>函数间隔越大, 代表我们对于分类的结果非常确定. 我们希望函数间隔越大越好. 看上去好像没什么毛病, 但这里的确有一个问题, 就是其实我们可以在不改变这个超平面的情况下可以让函数间隔任意大, 为什么?</p><p>由超平面的解析式： </p><script type="math/tex; mode=display">w^Tx+ b=0</script><p>方程两边同时乘以常数 C，即</p><script type="math/tex; mode=display">C\ w^Tx+ C\ b=0</script><p>显然以上两个方程的解是一致的，超平面没有发生变化。换句话说，参数 w 和 b 同比例缩放对超平面并没有影响。然而参数 w 和 b 放大或缩小 C 倍，函数间隔：</p><script type="math/tex; mode=display">\hat\gamma = y(Cw^Tx + Cb) = Cy(w^Tx + b)=C \hat\gamma</script><p>这意味着函数间隔 $\hat \gamma$ 也会放大和缩小相同的倍数。</p><p>而几何间隔：</p><script type="math/tex; mode=display">\tilde \gamma = \frac{C\hat\gamma}{C||w||_2} = \tilde \gamma</script><p>这意味着几何间隔不变。</p><p>为了解决这个问题, 我们就需要加上一些限制条件,所以，需要将$w$的大小固定，如$||w||=1$，使得函数间隔固定。这时的间隔也就是几何间隔 .(看完后面几何间隔的定义就明白了)</p><h2 id="几何间隔"><a href="#几何间隔" class="headerlink" title="几何间隔"></a>几何间隔</h2><p>对二维空间来说,点$P(x_0,y_0)$到直线$ax+by+c=0$的公式是</p><script type="math/tex; mode=display">\mathrm { d } = \frac { \left| a x _ { 0 } + b y _ { 0 } + c \right| } { \sqrt { a ^ { 2 } + b ^ { 2 } } }</script><p>高维空间呢？</p><script type="math/tex; mode=display">\gamma = \frac { y \left( w ^ { T } x + b \right) } { \| w \| _ { 2 } }</script><p>这个式子是怎么推导出来的</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3148169752/geometric.png" class="" title="geometric"><p>对于超平面$w^Tx+b$，$x$在超平面上的投影是$x_0$,$w$是超平面的法向量，那么有</p><script type="math/tex; mode=display">x = x_0 + \gamma \frac {w}{||w||}</script><p>那么</p><script type="math/tex; mode=display">f(x) = f(x_0 + \gamma \frac {w}{||w||})\\=w^Tx_0+w^T\gamma \frac {w}{||w||}+b\\=f(x_0)+w^T\gamma \frac {w}{||w||}\\=0 +\gamma \frac {w^Tw}{||w||}\\=\gamma \frac {||w||^2}{||w||}\\=\gamma||w||\\\Downarrow\\\gamma=\frac{f(x)}{||w||}</script><p>这里的$\gamma$其实是带符号的，我们需要的是绝对值，乘上对应的类别 y 即可，因此实际上我们定义几何间隔为：</p><script type="math/tex; mode=display">\tilde { \gamma } = y \gamma = \frac { \hat { \gamma } } { \| \boldsymbol { w } \| }</script><p>也就是上面的</p><script type="math/tex; mode=display">\frac { y \left( w ^ { T } x + b \right) } { \| w \| _ { 2 } }</script><p>函数间隔$y(w^Tx+b)=yf(x)$实际上就是<script type="math/tex">|f(x)|</script>，只是人为定义的一个间隔度量；而几何间隔$\frac{|f(x)|}{||w||}$才是直观上的点到超平面距离。</p><hr><p>间隔我们也知道了，所以我们可以求这个Margin了</p><p>上面说过，对于超平面来说函数间隔其实并不固定，所以我们不妨设$\hat y = 1$,那么几何间隔就是 $\frac {1}{||w||}$,最大化这个几何间隔就是最小化$||w||$即可.</p><p>另外一种推法：</p><p>设Margin为<script type="math/tex">2\lambda</script>对于任意正样本<script type="math/tex">x_+</script>，负样本$ x_- $来说</p><script type="math/tex; mode=display">\left\{ \begin{array} { l } { w^T \cdot x_+ +b \ge \lambda}\\ { w^T \cdot x_- +b \le -\lambda  }\end{array} \right.\ \ \ \ \ \y_i=\left\{ \begin{array} { l r } { +1 } & {x_+}\\ { -1 } & {x_-}\end{array} \right.</script><p>结合一下</p><script type="math/tex; mode=display">y_i(w^Tx_i+b)-\lambda \ge 0</script><p>距离其实就是 <script type="math/tex">x_+-x_-​</script> 在法向量 $w​$ 上的投影</p><script type="math/tex; mode=display">\frac {(x_+-x_-)w^T}{|w|}\\w \ \  w^T都是表示的法向量，一个是行表示一个是列表示</script><p>把上面式子代进去</p><script type="math/tex; mode=display">\frac {(\lambda-b)+(\lambda+b)}{|w|}\\ \Downarrow \\\frac {2\lambda}{||w||}\\ 注: |w| = ||w||_2 = \sqrt{w_1^2 + w_2^2 + \cdots}\\</script><hr><p>所以就是求这个最大的Margin了，也就是</p><script type="math/tex; mode=display">max(\frac{1}{||w||})\\ \Downarrow \\min(||w||)\\ \Downarrow \\min (\frac{1}{2}||w||_2^2) \qquad s.t \;\; y_i(w^Tx_i + b) \geq 1 (i =1,2,...m) \\</script><p><strong>转化为拉格朗日函数</strong></p><script type="math/tex; mode=display">\mathcal { L }(w,b,\alpha) = \frac{1}{2}||w||_2^2 - \sum\limits_{i=1}^{m}\alpha_i[y_i(w^Tx_i + b) - 1] \qquad s.t \ \alpha_i \geq 0 \\</script><p>也就是求这个函数的极值</p><script type="math/tex; mode=display">L' = (\frac{\partial{L}}{\partial{w}},\frac{\partial{L}}{\partial{b}})\\\frac{\partial{L}}{\partial{w}}=0 \Rightarrow w^T-\sum_i\alpha_iy_ix_i=0\\\frac{\partial{L}}{\partial{b}}=0 \Rightarrow \sum_i\alpha_iy_i=0</script><p>代回去</p><script type="math/tex; mode=display">\begin{align} \min _ { w , b } \max _ { \alpha _ { i } \geq 0 } \mathcal { L } ( w , b , \alpha ) & = \frac{1}{2}||w||_2^2 - \sum\limits_{i=1}^{m}\alpha_i[y_i(w^Tx_i + b) - 1] \\ & = \frac{1}{2}w^Tw-\sum\limits_{i=1}^{m}\alpha_iy_iw^Tx_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i \\ & = \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i -\sum\limits_{i=1}^{m}\alpha_iy_iw^Tx_i - \sum\limits_{i=1}^{m}\alpha_iy_ib + \sum\limits_{i=1}^{m}\alpha_i \\ & = \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i - b\sum\limits_{i=1}^{m}\alpha_iy_i + \sum\limits_{i=1}^{m}\alpha_i \\ & = - \frac{1}{2}w^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i + \sum\limits_{i=1}^{m}\alpha_i \\ & = -\frac{1}{2}(\sum\limits_{i=1}^{m}\alpha_iy_ix_i)^T(\sum\limits_{i=1}^{m}\alpha_iy_ix_i) + \sum\limits_{i=1}^{m}\alpha_i \\ & = -\frac{1}{2}\sum\limits_{i=1}^{m}\alpha_iy_ix_i^T\sum\limits_{i=1}^{m}\alpha_iy_ix_i + \sum\limits_{i=1}^{m}\alpha_i \\ & = -\frac{1}{2}\sum\limits_{i=1,j=1}^{m}\alpha_iy_ix_i^T\alpha_jy_jx_j + \sum\limits_{i=1}^{m}\alpha_i \end{align} \\</script><p>调一下顺序</p><script type="math/tex; mode=display">\min _ { w , b } \max _ { \alpha _ { i } \geq 0 } \mathcal { L } ( w , b , \alpha )= - \frac { 1 } { 2 } \sum _ { i = 1 , j = 1 } ^ { m } \alpha _ { i }\alpha _ { j }  y _ { i }y _ { j } x _ { i } ^ { T }  x _ { j } + \sum _ { i = 1 } ^ { m } \alpha _ { i }\\\begin{array} { c } { \text {s.t.} , \alpha _ { i } \geq 0 , i = 1 , \ldots , n } \\ { \sum _ { i = 1 } ^ { n } \alpha _ { i } y = 0 } \end{array}</script><p>这个$\alpha$是什么东西呢，其实就是如果$(x_i,y_i)$不是支持向量，那么它就是0，如果是就是一个非0的值。</p><script type="math/tex; mode=display">\max _ { \alpha _ { i } \geq 0 } \mathcal { L } ( w , b , \alpha ) = \max _ { \alpha _ { i } \geq 0 } \frac { 1 } { 2 } \| w \| ^ { 2 } - \sum _ { i = 1 } ^ { n } \alpha _ { i } \color{red}{ \left( y _ { i } \left( w ^ { T } x _ { i } + b \right) - 1 \right)}</script><p>注意到如果 $x_i$ 是支持向量的话，上式中红颜色的部分是等于 0 的（因为支持向量的 functional margin 等于 1 ），而对于非支持向量来说，functional margin 会大于 1 ，因此红颜色部分是大于零的，而又是非负的，为了满足最大化，必须等于 0 。这也就是这些非Supporting Vector 的点的局限性。 </p><p>求$\alpha$可以用SMO,KKT等方式，这就不说了太高深，这也不重要。</p><h1 id="松弛变量"><a href="#松弛变量" class="headerlink" title="松弛变量"></a>松弛变量</h1><p>数据有的时候是线性可分，但是因为数据中总会有一些噪音的影响而导致线性不可分</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3148169752/noise.png" class="" title="noise"><p>为了处理这种情况，SVM 允许数据点在一定程度上偏离一下超平面。</p><p>我们原来的约束条件是</p><script type="math/tex; mode=display">y _ { i } \left( w ^ { T } x _ { i } + b \right) \geq 1 , \quad i = 1 , \ldots , n</script><p>考虑到噪音</p><script type="math/tex; mode=display">y _ { i } \left( w ^ { T } x _ { i } + b \right) \geq 1 - \xi _ { i } , \quad i = 1 , \ldots , n</script><p>其中$\xi _ { i } \ge 0$称为松弛变量 (slack variable) ,对应数据点$x_i$允许偏离的 functional margin 的量,那么</p><script type="math/tex; mode=display">\min \frac { 1 } { 2 } \| w \| ^ { 2 } + \color{red}{C \sum _ { i = 1 } ^ { n } \xi _ { i }}\\\text {s.t.} \begin{array} { l } {  y _ { i } \left( w ^ { T } x _ { i } + b \right) \geq 1 - \xi _ { i } , i = 1 , \ldots , n } \\ { \xi _ { i } \geq 0 , i = 1 , \ldots , n } \end{array}</script><p>引入拉格朗日，最后结果为</p><script type="math/tex; mode=display">\max _ { \alpha } \sum _ { i = 1 } ^ { n } \alpha _ { i } - \frac { 1 } { 2 } \sum _ { i , j = 1 } ^ { n } \alpha _ { i } \alpha _ { j } y _ { i } y _ { j } \left\langle x _ { i } , x _ { j } \right\rangle\\\begin{array} { c } { \text { s.t., } 0 \leq \alpha _ { i } \leq C , i = 1 , \ldots , n } \\ { \sum _ { i = 1 } ^ { n } \alpha _ { i } y _ { i } = 0 } \end{array}</script><p>区别就在于多了一个上限$C$</p><h1 id="kernel"><a href="#kernel" class="headerlink" title="kernel"></a>kernel</h1><p>kernel又是干嘛的呢？</p><p>事实上，大部分时候数据并不是线性可分的，这个时候满足这样条件的超平面就根本不存在。在上文中，我们已经了解到了SVM处理线性可分的情况，那对于非线性的数据SVM咋处理呢？对于非线性的情况，SVM 的处理方法是选择一个核函数 $k(⋅,⋅)$ 通过将数据映射到高维空间，来解决在原始空间中线性不可分的问题。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/3148169752/space_map.png" class="" title="space_map"><p>这里有个很简单的思想</p><ol><li>首先使用一个非线性映射将数据变换到一个特征空间F，使其线性可分，</li><li>然后在特征空间使用线性学习器分类。</li></ol><p>也就是非线性数据，就找一个映射$k(·，·)$，然后一股脑把原来的数据映射到新空间中，再做线性 SVM 即可。不过事实上好像并没有这么简单。</p><p>如果原始空间是三维（一阶、二阶和三阶的组合），那么我们会得到：3(一次)+3(二次交叉)+3(平方)+3(立方)+1(x1<em>x2</em>x3)+2<em>3(交叉，一个一次一个二次，类似x1</em>x2^2) = 19维的新空间，这个数目是呈指数级爆炸性增长的，从而势必这给的计算带来非常大的困难，而且如果遇到无穷维的情况，就根本无从计算了。</p><p>kernel则是<strong>直接在原来的低维空间中进行计算，而不需要显式地写出映射后的结果</strong>，也就是直接将$k(x_i,x_j)$视为新空间中的$x_ix_j$</p><p>那么</p><script type="math/tex; mode=display">min(L)= - \frac { 1 } { 2 } \sum _ { i = 1 , j = 1 } ^ { m } \alpha _ { i }\alpha _ { j }  y _ { i }y _ { j } x _ { i } ^ { T }  x _ { j } + \sum _ { i = 1 } ^ { m } \alpha _ { i }\\ \Downarrow \\min(L)= - \frac { 1 } { 2 } \sum _ { i = 1 , j = 1 } ^ { m } \alpha _ { i }\alpha _ { j }  y _ { i }y _ { j } k(x_i,x_j)+ \sum _ { i = 1 } ^ { m } \alpha _ { i }</script><p>这样一来计算的问题就算解决了，避开了直接在高维空间中进行计算，而结果却是等价的！</p><p>但是kernel的选择确实很困难的，一般会采用以下几种</p><p>多项式核 </p><script type="math/tex; mode=display">\kappa ( x , y ) = \left( a x ^ { T } y + c \right) ^ { d }</script><p>高斯核 </p><script type="math/tex; mode=display">\kappa \left( x _ { 1 } , x _ { 2 } \right) = \exp \left( - \frac { \left\| x _ { 1 } - x _ { 2 } \right\| ^ { 2 } } { 2 \sigma ^ { 2 } } \right)</script><p>线性核</p><script type="math/tex; mode=display">\kappa \left( x _ { 1 } , x _ { 2 } \right) = \left\langle x _ { 1 } , x _ { 2 } \right\rangle</script>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Machine_Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-lib-asyncio</title>
      <link href="/p/1315325560.html"/>
      <url>/p/1315325560.html</url>
      
        <content type="html"><![CDATA[<p>这个包使用事件循环驱动的协程实现并发</p><p><code>asyncio</code>包使用的协程是比较严格的定义，适合 <code>asyncio API</code> 的协程在定义体中必须使用 <code>yield from</code>，而不能使用 <code>yield</code>;或者把协程传给 <code>asyncio</code> 包中的某个函数，例如 <code>asyncio.async(...)</code> ，从而驱动协程</p><span id="more"></span><h1 id="asyncio-gather-和asyncio-wait"><a href="#asyncio-gather-和asyncio-wait" class="headerlink" title="asyncio.gather 和asyncio.wait"></a><code>asyncio.gather</code> 和<code>asyncio.wait</code></h1><p><code>asyncio.gather</code> 和<code>asyncio.wait</code>都是同时运行<code>aws</code>中的<code>awaitable objects</code>，但是有一点点区别</p><h2 id="asyncio-gather-aws-loop-None-return-exceptions-False"><a href="#asyncio-gather-aws-loop-None-return-exceptions-False" class="headerlink" title="asyncio.gather(*aws, loop=None, return_exceptions=False)"></a><code>asyncio.gather(*aws, loop=None, return_exceptions=False)</code></h2><p>如果所有的任务都成功完成了，按照<code>aws</code>中的顺序返回值的汇总列表<br>如果<code>return_exceptions</code>是<code>False</code>（默认）,那么第一个异常会冒泡到<code>gather()</code>，其他的任务不会被取消并且继续执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleepcoro</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 如果使用time.sleep()会阻塞整个应用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;testcoro&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">te</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;te <span class="subst">&#123;n&#125;</span> begin&#x27;</span>)</span><br><span class="line">    m = <span class="keyword">yield</span> <span class="keyword">from</span> sleepcoro(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">f&#x27;err:<span class="subst">&#123;n&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;te <span class="subst">&#123;n&#125;</span> end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">a = asyncio.gather(*[te(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    done = loop.run_until_complete(a)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">te <span class="number">2</span> begin</span><br><span class="line">te <span class="number">0</span> begin</span><br><span class="line">te <span class="number">3</span> begin</span><br><span class="line">te <span class="number">4</span> begin</span><br><span class="line">te <span class="number">1</span> begin</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">2</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">0</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">4</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">1</span> end</span><br><span class="line">err:<span class="number">3</span></span><br></pre></td></tr></table></figure><br>如果<code>return_exceptions</code>是<code>True</code>,那么异常会像成功的结果一样添加到结果列表中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = asyncio.gather(*[te(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)],return_exceptions=<span class="literal">True</span>)</span><br><span class="line">done = loop.run_until_complete(a)</span><br><span class="line"><span class="built_in">print</span>(done)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, Exception(<span class="string">&#x27;err:3&#x27;</span>,), <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p><p>如果<code>gather()</code>被取消。所有没完成的任务也会被取消<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleepcoro</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 如果使用time.sleep()会阻塞整个应用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;testcoro&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">te</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;te <span class="subst">&#123;n&#125;</span> begin&#x27;</span>)</span><br><span class="line">    m = <span class="keyword">yield</span> <span class="keyword">from</span> sleepcoro(n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">3</span>:</span><br><span class="line">        a.cancel()</span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;te <span class="subst">&#123;n&#125;</span> end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">ls = [te(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">a = asyncio.gather(*ls)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    done = loop.run_until_complete(a)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">te <span class="number">2</span> begin</span><br><span class="line">te <span class="number">0</span> begin</span><br><span class="line">te <span class="number">3</span> begin</span><br><span class="line">te <span class="number">4</span> begin</span><br><span class="line">te <span class="number">1</span> begin</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">2</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">0</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">3</span> end</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="asyncio-wait-aws-loop-None-timeout-None-return-when-ALL-COMPLETED"><a href="#asyncio-wait-aws-loop-None-timeout-None-return-when-ALL-COMPLETED" class="headerlink" title="asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED)"></a><code>asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</code></h2><p>同时运行<code>aws</code>中的<code>awaitable objects</code>并<strong>阻塞</strong>，直到<code>return_when</code>指定的条件<br><code>loop</code>参数将被废弃<br><code>timeout</code>可以指定等待的最大秒数，这个不会引发<code>asyncio.TimeoutError</code>，未完成的任务会在pending中返回<br><code>return_when</code>必须是以下常量之一:</p><div class="table-container"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>FIRST_COMPLETED</td><td>任何一个完成或者取消时返回</td></tr><tr><td>FIRST_EXCEPTION</td><td>任何一个因为引发异常完成时返回，如果都没有与ALL_COMPLETED相同</td></tr><tr><td>ALL_COMPLETED</td><td>所有的结束或者取消时返回</td></tr></tbody></table></div><p>返回两个列表,done和pending,需通过<code>future.result</code>调用Task的result。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleepcoro</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(<span class="number">1</span>) <span class="comment"># 如果使用time.sleep()会阻塞整个应用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;testcoro&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">te</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;te <span class="subst">&#123;n&#125;</span> begin&#x27;</span>)</span><br><span class="line">    m = <span class="keyword">yield</span> <span class="keyword">from</span> sleepcoro(n)</span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;te <span class="subst">&#123;n&#125;</span> end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">ls = [te(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)]</span><br><span class="line">a = asyncio.wait(ls)</span><br><span class="line">done, pending = loop.run_until_complete(a)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> done:</span><br><span class="line">    <span class="built_in">print</span>(i.result())</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">te <span class="number">2</span> begin</span><br><span class="line">te <span class="number">0</span> begin</span><br><span class="line">te <span class="number">3</span> begin</span><br><span class="line">te <span class="number">4</span> begin</span><br><span class="line">te <span class="number">1</span> begin</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">2</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">0</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">3</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">4</span> end</span><br><span class="line">testcoro</span><br><span class="line">te <span class="number">1</span> end</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br><del><code>aws</code>直接传递协程对象</del>已经被弃用</p><h1 id="run-until-complete-future"><a href="#run-until-complete-future" class="headerlink" title="run_until_complete(future)"></a><code>run_until_complete(future)</code></h1><p>参数是一个futrue对象,如果传入了一个协程对象，会被隐式的转换成<code>asyncio.Task</code></p><h1 id="asyncio-ensure-future-obj-loop-None"><a href="#asyncio-ensure-future-obj-loop-None" class="headerlink" title="asyncio.ensure_future(obj, *, loop=None)"></a><code>asyncio.ensure_future(obj, *, loop=None)</code></h1><p><code>obj</code>是一个<code>Future-like object</code>(<code>isfuture()</code>)<br>会返回一个<code>asyncio.Task</code>实例，Task 对象可以取消,即调用实例的<code>cancel</code>方法；取消后会在协程当前暂停的 <code>yield</code> 处抛出 <code>asyncio.CancelledError</code> 异常。协程可以捕获这个异常，也可以延迟取消，甚至拒绝取消。<strong>Python3.7之后推荐用<code>create_task()</code>方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sleepcoro</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> asyncio.sleep(n)  <span class="comment"># 如果使用time.sleep()会阻塞整个应用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;testcoro&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">te</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;o&#x27;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            m = <span class="keyword">yield</span> <span class="keyword">from</span> sleepcoro(<span class="number">.1</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">            <span class="built_in">print</span>(e.__class__)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    a = asyncio.ensure_future(te())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a:&#x27;</span>,a)</span><br><span class="line">    res = <span class="keyword">yield</span> <span class="keyword">from</span> sleepcoro(<span class="number">1</span>)</span><br><span class="line">    a.cancel()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    res = loop.run_until_complete(main())</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line">a: &lt;Task pending coro=&lt;te() running at test.py:<span class="number">10</span>&gt;&gt;</span><br><span class="line">oooooooooo</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;concurrent.futures._base.CancelledError&#x27;</span>&gt;</span><br><span class="line">testcoro</span><br></pre></td></tr></table></figure><h1 id="asyncio-run-in-executor-executor-func-args"><a href="#asyncio-run-in-executor-executor-func-args" class="headerlink" title="asyncio.run_in_executor(executor, func, *args)"></a><code>asyncio.run_in_executor(executor, func, *args)</code></h1><p>第一个参数是 <code>Executor</code> 实例；如果设为 <code>None</code>，使用事件循环的默认 <code>ThreadPoolExecutor</code> 实例。</p><p>阻塞型 I/O 调用在背后会释放 GIL，因此另一个线程可以继续。<code>asyncio</code> 的事件循环在背后维护着一个 <code>ThreadPoolExecutor</code> 对象，我们可以调用 <code>run_in_executor</code> 方法，把可调用的对象发给它执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">sl</span>():</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;t.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        s = <span class="string">&#x27;a&#x27;</span>*<span class="number">1000000000</span></span><br><span class="line">        f.write(s)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    result = <span class="keyword">await</span> sl()</span><br><span class="line">    t3(*result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main2</span>():</span><br><span class="line">    result = <span class="keyword">await</span> sl()</span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_in_executor(<span class="literal">None</span>,t3,*result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t3</span>(<span class="params">a,b,c</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    st = time.time()</span><br><span class="line">    l = asyncio.get_event_loop()</span><br><span class="line">    l.run_until_complete(asyncio.gather(*[main(),main(),main()]))</span><br><span class="line">    <span class="built_in">print</span>(time.time()-st)</span><br><span class="line">    st = time.time()</span><br><span class="line">    l = asyncio.get_event_loop()</span><br><span class="line">    l.run_until_complete(asyncio.gather(*[main2(),main2(),main2()]))</span><br><span class="line">    l.close()</span><br><span class="line">    <span class="built_in">print</span>(time.time()-st)</span><br><span class="line">    </span><br><span class="line"><span class="comment">###</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.47020411491394</span></span><br><span class="line"><span class="number">6.83022403717041</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-lib-contextlib</title>
      <link href="/p/101661151.html"/>
      <url>/p/101661151.html</url>
      
        <content type="html"><![CDATA[<p>一些常用的上下文管理库</p><span id="more"></span><h1 id="closing"><a href="#closing" class="headerlink" title="closing"></a><code>closing</code></h1><p>如果对象提供了 close() 方法，但没有实现 <strong>enter</strong>/<strong>exit</strong> 协议，那么可以使用这个函数构建上下文管理器。</p><h1 id="suppress"><a href="#suppress" class="headerlink" title="suppress"></a><code>suppress</code></h1><p>“构建临时忽略指定异常的上下文管理器。</p><h1 id="contextmanager"><a href="#contextmanager" class="headerlink" title="@contextmanager"></a><code>@contextmanager</code></h1><p>　　这个装饰器把简单的生成器函数变成上下文管理器，这样就不用创建类去实现管理器协议了。</p><p>能减少创建上下文管理器的样板代码量，因为不用编写一个完整的类，定义 <strong>enter</strong> 和 <strong>exit</strong> 方法，而只需实现有一个 yield 语句的生成器，生成想让 <strong>enter</strong> 方法返回的值。</p><p>在使用 @contextmanager 装饰的生成器中，yield 语句的作用是把函数的定义体分成两部分：yield 语句前面的所有代码在 with 块开始时（即解释器调用 <strong>enter</strong> 方法时）执行， yield 语句后面的代码在 with 块结束时（即调用 <strong>exit</strong> 方法时）执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;begin&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&#x27;ttt&#x27;</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;after&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> t() <span class="keyword">as</span> tt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;withing&#x27;</span>,tt)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">begin</span><br><span class="line">withing ttt</span><br><span class="line">after</span><br><span class="line"></span><br><span class="line">需要显式处理异常</span><br></pre></td></tr></table></figure><h1 id="ContextDecorator"><a href="#ContextDecorator" class="headerlink" title="ContextDecorator"></a><code>ContextDecorator</code></h1><p>　　这是个基类，用于定义基于类的上下文管理器。这种上下文管理器也能用于装饰函数，在受管理的上下文中运行整个函数。</p><h1 id="ExitStack"><a href="#ExitStack" class="headerlink" title="ExitStack"></a><code>ExitStack</code></h1><p>　　这个上下文管理器能进入多个上下文管理器。with 块结束时，ExitStack 按照后进先出的顺序调用栈中各个上下文管理器的 <strong>exit</strong> 方法。如果事先不知道 with 块要进入多少个上下文管理器，可以使用这个类。例如，同时打开任意一个文件列表中的所有文件</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-context</title>
      <link href="/p/1658935636.html"/>
      <url>/p/1658935636.html</url>
      
        <content type="html"><![CDATA[<p>上下文管理器对象存在的目的是管理<code>with</code>语句</p><p><code>with</code> 语句的目的是简化 <code>try/finally</code> 模式。这种模式用于保证一段代码运行完毕后执行某项操作，即便那段代码由于异常、<code>return</code> 语句或 <code>sys.exit()</code> 调用而中止，也会执行指定的操作。<code>`finally</code> 子句中的代码通常用于释放重要的资源，或者还原临时变更的状态。</p><p>上下文管理器协议包含<code>__enter__</code>和<code>__exit__</code>两个方法，<code>with</code>语句开始运行时，会在上下文管理器对象上吊用<code>__enter__</code>方法，结束后会调用<code>__exit__</code>方法</p><span id="more"></span><p>最常见的例子是确保关闭文件对象。使用 with 语句关闭文件<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">content = f.read()</span><br><span class="line"><span class="built_in">print</span>(content)</span><br></pre></td></tr></table></figure><br><strong>执行 <code>with</code> 后面的表达式得到的结果是上下文管理器对象，不过，把值绑定到目标变量上（as 子句）是在上下文管理器对象上调用 <code>__enter__</code> 方法的结果。不管控制流程以哪种方式退出 with 块，都会在上下文管理器对象上调用 <strong>exit</strong> 方法，而不是在 <strong>enter</strong> 方法返回的对象上调用。</strong></p><p>如果 <code>__exit__</code> 方法返回<code>True</code> 之外的值，with 块中的任何异常都会向上冒泡。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-lib-itertools,生成器</title>
      <link href="/p/2033046112.html"/>
      <url>/p/2033046112.html</url>
      
        <content type="html"><![CDATA[<p>itertools中的函数大多是返回各种迭代器对象<br><span id="more"></span></p><h1 id="用于过滤的生成器函数"><a href="#用于过滤的生成器函数" class="headerlink" title="用于过滤的生成器函数"></a>用于过滤的生成器函数</h1><div class="table-container"><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">itertools</td><td style="text-align:center">compress(it, selector_it)</td><td style="text-align:center">并行处理两个可迭代对象，如果selector_it中的元素是真，产出it中对应的元素</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">dropwhile(predicate, it)</td><td style="text-align:center">处理 it，跳过 predicate 的计算结果为真值的元素，然后产出剩下的各个元素（不再进一步检查）</td></tr><tr><td style="text-align:center">内置</td><td style="text-align:center">filter(predicate, it)</td><td style="text-align:center">把 it 中的各个元素传给 predicate，如果 predicate(item) 返回真值，那么产出对应的元素；如果 predicate 是 None，那么只产出真值元素</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">filterfalse(predicate, it)</td><td style="text-align:center">与 filter 函数的作用类似，不过 predicate 的逻辑是相反的：predicate 返回假值时产出对应的元素</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">islice(it, stop) 或 islice(it, start, stop, step=1)</td><td style="text-align:center">产出 it 的切片，作用类似于 s[:stop] 或 s[start:stop:step]，不过 it 可以是任何可迭代的对象，而且这个函数实现的是惰性操作</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">takewhile(predicate, it)</td><td style="text-align:center">predicate 返回真值时产出对应的元素，然后立即停止，不再继续检查</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">it = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">v</span>):</span><br><span class="line">    <span class="keyword">return</span> v % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">filter</span>(f, it), <span class="built_in">list</span>(<span class="built_in">filter</span>(f, it)))</span><br><span class="line"><span class="built_in">print</span>(itertools.filterfalse(f, it), <span class="built_in">list</span>(itertools.filterfalse(f, it)))</span><br><span class="line"><span class="built_in">print</span>(itertools.dropwhile(f, it), <span class="built_in">list</span>(itertools.dropwhile(f, it)))</span><br><span class="line"><span class="built_in">print</span>(itertools.takewhile(f, it), <span class="built_in">list</span>(itertools.takewhile(f, it)))</span><br><span class="line"><span class="built_in">print</span>(itertools.compress(it, [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]), <span class="built_in">list</span>(itertools.compress(it, [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>])))</span><br><span class="line"><span class="built_in">print</span>(itertools.islice(it, <span class="number">3</span>), <span class="built_in">list</span>(itertools.islice(it, <span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>(itertools.islice(it, <span class="number">3</span>, <span class="number">5</span>), <span class="built_in">list</span>(itertools.islice(it, <span class="number">3</span>, <span class="number">5</span>)))</span><br><span class="line"><span class="built_in">print</span>(itertools.islice(it, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>), <span class="built_in">list</span>(itertools.islice(it, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;<span class="built_in">filter</span> <span class="built_in">object</span> at <span class="number">0x10a00d550</span>&gt; [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">&lt;itertools.filterfalse <span class="built_in">object</span> at <span class="number">0x10a00d550</span>&gt; [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">&lt;itertools.dropwhile <span class="built_in">object</span> at <span class="number">0x10a4636c8</span>&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&lt;itertools.takewhile <span class="built_in">object</span> at <span class="number">0x10a4636c8</span>&gt; [<span class="number">1</span>]</span><br><span class="line">&lt;itertools.compress <span class="built_in">object</span> at <span class="number">0x10a00d550</span>&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">&lt;itertools.islice <span class="built_in">object</span> at <span class="number">0x109dc7d68</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&lt;itertools.islice <span class="built_in">object</span> at <span class="number">0x109dc7d68</span>&gt; [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&lt;itertools.islice <span class="built_in">object</span> at <span class="number">0x109dc7d68</span>&gt; [<span class="number">2</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h1 id="用于映射的生成器函数"><a href="#用于映射的生成器函数" class="headerlink" title="用于映射的生成器函数"></a>用于映射的生成器函数</h1><div class="table-container"><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">itertools</td><td style="text-align:center">accumulate(it, [func])</td><td style="text-align:center">把前两个元素传给func，如果没有提供func，默认是add。然后把计算结果和下一个元素传给它，以此类推，最后产出结果</td></tr><tr><td style="text-align:center">内置</td><td style="text-align:center">enumerate(iterable, start=0)</td><td style="text-align:center">产出由两个元素组成的元组，结构是 (index, item)，其中 index 从 start 开始计数，item 则从 iterable 中获取</td></tr><tr><td style="text-align:center">内置</td><td style="text-align:center">map(func, it1, [it2, …, itN])</td><td style="text-align:center">把 it 中的各个元素传给func，产出结果；如果传入 N 个可迭代的对象，那么 func 必须能接受 N 个参数，而且要并行处理各个可迭代的对象</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">starmap(func, it)</td><td style="text-align:center">把 it 中的各个元素传给 func，产出结果；输入的可迭代对象应该产出可迭代的元素 iit，然后以 func(*iit) 这种形式调用 func</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">it = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pt</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="built_in">print</span>(m,<span class="built_in">list</span>(m))</span><br><span class="line"></span><br><span class="line">m = itertools.accumulate(it)</span><br><span class="line">pt(m)</span><br><span class="line">m = itertools.accumulate(it,operator.mul)</span><br><span class="line">pt(m)</span><br><span class="line">m = <span class="built_in">enumerate</span>(it,<span class="number">5</span>)</span><br><span class="line">pt(m)</span><br><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x:x*<span class="number">2</span>,it)</span><br><span class="line">pt(m)</span><br><span class="line">m = <span class="built_in">map</span>(<span class="keyword">lambda</span> x,y:x+<span class="number">2</span>*y,it,it[::-<span class="number">1</span>])</span><br><span class="line">pt(m)</span><br><span class="line">m =itertools.starmap(<span class="keyword">lambda</span> *x:x,<span class="built_in">enumerate</span>(it,<span class="number">5</span>))</span><br><span class="line">pt(m)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;itertools.accumulate <span class="built_in">object</span> at <span class="number">0x1072a2848</span>&gt; [<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">15</span>]</span><br><span class="line">&lt;itertools.accumulate <span class="built_in">object</span> at <span class="number">0x1072a28c8</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line">&lt;<span class="built_in">enumerate</span> <span class="built_in">object</span> at <span class="number">0x105fa4b88</span>&gt; [(<span class="number">5</span>, <span class="number">1</span>), (<span class="number">6</span>, <span class="number">2</span>), (<span class="number">7</span>, <span class="number">3</span>), (<span class="number">8</span>, <span class="number">4</span>), (<span class="number">9</span>, <span class="number">5</span>)]</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x105b59828</span>&gt; [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">&lt;<span class="built_in">map</span> <span class="built_in">object</span> at <span class="number">0x105f97588</span>&gt; [<span class="number">11</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">&lt;itertools.starmap <span class="built_in">object</span> at <span class="number">0x105b59550</span>&gt; [(<span class="number">5</span>, <span class="number">1</span>), (<span class="number">6</span>, <span class="number">2</span>), (<span class="number">7</span>, <span class="number">3</span>), (<span class="number">8</span>, <span class="number">4</span>), (<span class="number">9</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h1 id="合并多个可迭代对象的生成器函数"><a href="#合并多个可迭代对象的生成器函数" class="headerlink" title="合并多个可迭代对象的生成器函数"></a>合并多个可迭代对象的生成器函数</h1><div class="table-container"><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">itertools</td><td style="text-align:center">chain(it1, …, itN)</td><td style="text-align:center">先产出 it1 中的所有元素，然后产出 it2 中的所有元素，以此类推，无缝连接在一起</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">chain.from_iterable(it)</td><td style="text-align:center">产出 it 生成的各个可迭代对象中的元素，一个接一个，无缝连接在一起；it 应该产出可迭代的元素，例如可迭代的对象列表</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">product(it1, …, itN, repeat=1)</td><td style="text-align:center">计算笛卡儿积：从输入的各个可迭代对象中获取元素，合并成由 N 个元素组成的元组，与嵌套的 for 循环效果一样；repeat 指明重复处理多少次输入的可迭代对象</td></tr><tr><td style="text-align:center">内置</td><td style="text-align:center">zip(it1, …, itN)</td><td style="text-align:center">并行从输入的各个可迭代对象中获取元素，产出由 N 个元素组成的元组，只要有一个可迭代的对象到头了，就默默地停止</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">zip_longest(it1, …, itN, fillvalue=None)</td><td style="text-align:center">并行从输入的各个可迭代对象中获取元素，产出由 N 个元素组成的元组，等到最长的可迭代对象到头后才停止，空缺的值使用 fillvalue 填充</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"></span><br><span class="line">it1 = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">it2 = <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pt</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="built_in">print</span>(m,<span class="built_in">list</span>(m))</span><br><span class="line"></span><br><span class="line">m = itertools.chain(it1,it2)</span><br><span class="line">pt(m)</span><br><span class="line">m = itertools.chain.from_iterable([it1,it2])</span><br><span class="line">pt(m)</span><br><span class="line">m = itertools.product([<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>],repeat=<span class="number">2</span>)</span><br><span class="line">pt(m)</span><br><span class="line">m = <span class="built_in">zip</span>([<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">pt(m)</span><br><span class="line">m = itertools.zip_longest([<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],fillvalue=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">pt(m)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;itertools.chain <span class="built_in">object</span> at <span class="number">0x10b13b630</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">&lt;itertools.chain <span class="built_in">object</span> at <span class="number">0x10b13b588</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">&lt;itertools.product <span class="built_in">object</span> at <span class="number">0x10b148b88</span>&gt; [(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>), (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>)]</span><br><span class="line">&lt;<span class="built_in">zip</span> <span class="built_in">object</span> at <span class="number">0x10c4467c8</span>&gt; [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>)]</span><br><span class="line">&lt;itertools.zip_longest <span class="built_in">object</span> at <span class="number">0x10c40f598</span>&gt; [(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure><h1 id="输入扩展多输出的生成器函数"><a href="#输入扩展多输出的生成器函数" class="headerlink" title="输入扩展多输出的生成器函数"></a>输入扩展多输出的生成器函数</h1><div class="table-container"><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">itertools</td><td style="text-align:center">combinations(it, out_len)</td><td style="text-align:center">把 it 产出的 out_len 个元素组合在一起，然后产出</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">combinations_with_replacement(it, out_len)</td><td style="text-align:center">把 it 产出的 out_len 个元素组合在一起，然后产出,包含相同元素的组合</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">count(start=0, step=1)</td><td style="text-align:center">从 start 开始不断产出数字，按 step 指定的步幅增加</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">cycle(it)</td><td style="text-align:center">从 it 中产出各个元素，存储各个元素的副本，然后按顺序重复不断地产出各个元素</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">permutations(it, out_len=None)</td><td style="text-align:center">把 out_len 个 it 产出的元素排列在一起，然后产出这些排列；out_len 的默认值等于 len(list(it))</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">repeat(item, [times])</td><td style="text-align:center">重复不断地产出指定的元“素，除非提供 times，指定次数</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">it = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pt</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="built_in">print</span>(m,<span class="built_in">list</span>(m))</span><br><span class="line"></span><br><span class="line">m = itertools.combinations(it, <span class="number">2</span>)</span><br><span class="line">pt(m)</span><br><span class="line">m = itertools.combinations_with_replacement(it, <span class="number">3</span>)</span><br><span class="line">pt(m)</span><br><span class="line">m = itertools.count(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(m,itertools.islice(m,<span class="number">10</span>),<span class="built_in">list</span>(itertools.islice(m,<span class="number">10</span>)))</span><br><span class="line">m = itertools.cycle(it)</span><br><span class="line"><span class="built_in">print</span>(m,itertools.islice(m,<span class="number">10</span>),<span class="built_in">list</span>(itertools.islice(m,<span class="number">10</span>)))</span><br><span class="line">m = itertools.permutations(it)</span><br><span class="line">pt(m)</span><br><span class="line">m = itertools.repeat(it, <span class="number">3</span>)</span><br><span class="line">pt(m)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;itertools.combinations <span class="built_in">object</span> at <span class="number">0x10bdb1d68</span>&gt; [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">&lt;itertools.combinations_with_replacement <span class="built_in">object</span> at <span class="number">0x10bf2c5e8</span>&gt; [(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>), (<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>)]</span><br><span class="line">count(<span class="number">21</span>, <span class="number">2</span>) &lt;itertools.islice <span class="built_in">object</span> at <span class="number">0x10bf2c5e8</span>&gt; [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>]</span><br><span class="line">&lt;itertools.cycle <span class="built_in">object</span> at <span class="number">0x10c372b88</span>&gt; &lt;itertools.islice <span class="built_in">object</span> at <span class="number">0x10bf2c5e8</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">&lt;itertools.permutations <span class="built_in">object</span> at <span class="number">0x10d60fd58</span>&gt; [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>)]</span><br><span class="line">repeat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">0</span>) [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h1 id="重新排列元素的生成器函数"><a href="#重新排列元素的生成器函数" class="headerlink" title="重新排列元素的生成器函数"></a>重新排列元素的生成器函数</h1><div class="table-container"><table><thead><tr><th style="text-align:center">模块</th><th style="text-align:center">函数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">itertools</td><td style="text-align:center">groupby(it,key=None)</td><td style="text-align:center">产出由两个元素组成的元素，形式为 (key, group)，其中 key 是分组标准，group 是生成器，用于产出分组里的元素</td></tr><tr><td style="text-align:center">内置</td><td style="text-align:center">reversed(seq)</td><td style="text-align:center">从后向前，倒序产出 seq 中的元素；seq 必须是序列，或者是实现了 __reversed__ 特殊方法的对象</td></tr><tr><td style="text-align:center">itertools</td><td style="text-align:center">tee(it,n=2)</td><td style="text-align:center">产出一个由 n 个生成器组成的元组，每个生成器用于单独产出输入的可迭代对象中的元素</td></tr></tbody></table></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line">it = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;ab&#x27;</span>,<span class="string">&#x27;ac&#x27;</span>,<span class="string">&#x27;aba&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pt</span>(<span class="params">m</span>):</span><br><span class="line">    <span class="built_in">print</span>(m,<span class="built_in">list</span>(m))</span><br><span class="line"></span><br><span class="line">m = itertools.groupby(it)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    <span class="built_in">print</span>(i[<span class="number">0</span>],end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    pt(i[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">pt(<span class="built_in">reversed</span>(it))</span><br><span class="line"></span><br><span class="line">m = itertools.tee(it,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> m:</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        <span class="built_in">print</span>(j,end=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">a &lt;itertools._grouper <span class="built_in">object</span> at <span class="number">0x103eb65c0</span>&gt; [<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">ab &lt;itertools._grouper <span class="built_in">object</span> at <span class="number">0x103eb6898</span>&gt; [<span class="string">&#x27;ab&#x27;</span>]</span><br><span class="line">ac &lt;itertools._grouper <span class="built_in">object</span> at <span class="number">0x103eb65c0</span>&gt; [<span class="string">&#x27;ac&#x27;</span>]</span><br><span class="line">aba &lt;itertools._grouper <span class="built_in">object</span> at <span class="number">0x103eb6898</span>&gt; [<span class="string">&#x27;aba&#x27;</span>]</span><br><span class="line">&lt;list_reverseiterator <span class="built_in">object</span> at <span class="number">0x103eb65c0</span>&gt; [<span class="string">&#x27;aba&#x27;</span>, <span class="string">&#x27;ac&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">a,ab,ac,aba,</span><br><span class="line">a,ab,ac,aba,</span><br><span class="line">a,ab,ac,aba,</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>others-kafka</title>
      <link href="/p/2926927025.html"/>
      <url>/p/2926927025.html</url>
      
        <content type="html"><![CDATA[<p>在<em>0.10</em>版本之前,<strong>Kafka</strong>仅仅作为一个消息系统，主要用来解决应用解耦、异步消息、流量削峰等问题。<em>0.10</em>版本之后，<strong>Kafka</strong>提供了连接器与流处理能力，所以它也从分布式的消息系统逐渐成为一个流式数据平台</p><span id="more"></span><p>作为一个流式处理平台，最重要的是具备下面的3个特点。</p><ol><li>数据注入功能：类似消息系统，提供事件流的发布和订阅</li><li>数据存储功能：存储事件流数据的节点具有故障容错的特点</li><li>流处理功能：能够对实时对事件流进行流式处理和分析</li></ol><p><strong>Kafka</strong>是怎么实现并组合上面的3个功能特点的呢？</p><ol><li><p>消息系统<br>消息系统（也叫消息队列）主要有两种消息模型：队列和发布订阅。<strong>Kafka</strong>使用消费组（consumer group）同意上面两种消息模型，<strong>Kafka</strong>使用队列模型时，可以将处理工作平均非配给消费组中的消费者成员；使用发布订阅模式时，可以将消息广播给多个消费组。采用多个消费组结合多个消费者，既可以线性扩展消息的处理能力，也允许消息被多个消费组订阅。</p><ol><li><p>队列模式（也叫做点对点模式）<br> 多个消费者读取消息队列，每条消息只发送给一个消费者。</p></li><li><p>发布-订阅模式<br> 多个消费者订阅主题，主题的每条记录会发布给所有的消费者</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/2926927025/1.png" class="" title="[两种模型]"></li></ol></li><li><p>存储系统<br> 任何消息队列要做到“发布消息”和“消费消息”的解耦合， 实际上都要扮演一个存储系统的角色，负责保存还没有被消费的消息 。 否则，如果消息只是在内存中， 一旦机<br>器宕机或进程重启，内存中的消息就会全部丢失 。 Kafka也不例外，数据写入Kafka集群的服务器节点时，还会复制多份来保证出现故障时仍能可用 。 为了保证消息的可靠存储，<strong>Kafka</strong>还允许生产者的生产请求在收到应答结果之前，阻塞式地等待一条消息，直到它完全地复制到多个节点上，才认为这条消息写入成功 。 </p></li><li><p>流处理系统<br> 流式数据平台仅仅有消息的读取和写入、存储消息流是不够的，还需要有实时的流式数据处理能力 。 对于简单的处理，可以直接使用Kafka的生产者和消费者API来完成；<br>但对于复杂的业务逻辑处理，直接操作原始的API需要做的工作非常多。 Kafka流处理 （ KafkaStreams ）为开发者提供了完整的流处理API ，比如流的聚合、连接 、 各种转换操作 。 Kafka流处理框架内部解决很多流处理应用程序都会面临的问题 ：处理乱序或迟来的数据、重新处理输入数据 、 窗口和状态操作等 。</p></li><li><p>将消息系统、存储存储、流处理系统组合在一起：<br> 传统消息系统的流处理通常只会处理订阅动作发生之后才到达的新消息，无法处理订阅之前的历史数据 。 分布式文件存储系统一般存<br>储静态的历史数据，对历史数据的处理一般采用批处理的方式 。 现有的开源系统很难将这些系统无缝地整合起来， Kafka则将消息系统、存储系统 、 流处理系统都组合在一起，构成了以Kafka为中心的流式数据－处理平台 。 它既能处理最新的实时数据，也能处理过去的历史数据 。Kafka作为流式数据平台的核心组件，主要包括下面4种核心的 API 。<br> ·生产者 （ producer ）应用程序发布事件流到JKafka的一个或多个主题。<br> ·消费者 （ consumer ）应用程序订阅Kafka的一个或多个主题，并处理事件流。<br> ·连接器 （ connector ）将Kafka主题和已有数据源进行连接，数据’可以互相导入和导出 。<br> ·流处理 （ processor ) Kafka主题消费输入流，经过处理后，产生输出流到输出主题。 </p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/2926927025/2.png" class="" title="[4种核心API]"></li></ol>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>perceptron</title>
      <link href="/p/229648244.html"/>
      <url>/p/229648244.html</url>
      
        <content type="html"><![CDATA[<p>感知机（perceptron）是二类分类的线性分类模型，属于判别模型，其输入为实例的特征向量，输出为实例的类别，取+1和–1二值。感知机对应于输入空间（特征空间）中将实例划分为正负两类的分离超平面，属于判别模型，是神经网络(NN)与支持向量机(SVM)的基础。</p><span id="more"></span><p>输入空间$X \subseteq R^n$其中$x \in X$,输出空间$Y={+1,-1}$,输入空间到输出空间的函数如下:</p><script type="math/tex; mode=display">f(x) = sign(w \cdot x + b)</script><p>称为<strong>感知机</strong>,其中$w$和$b$为感知机模型的参数,$w \in R^n$叫做权值(weight)或权值向量(weight vector),$b \in R$叫做偏置(bias),$w \cdot x$表示$w$和$x$的内积，$sign$是符号函数:</p><script type="math/tex; mode=display">\operatorname { sign } ( x ) = \left\{ \begin{array} { l l } { + 1  } & { x \geqslant 0 } \\ { - 1  } & { x < 0 } \end{array} \right.</script><p>感知机模型的假设空间是定义在特征空间中的所有线性分类模型（linear classification model）或线性分类器(linear classifier)，即函数集合${f|f(x)=w \cdot x + b}​$</p><p>感知机几何解释为特征空间$R^n$中的一个超平面,称为分离超平面（separating hyperplane）,其中$w$是超平面的法向量，$b$是超平面的截距。</p><h1 id="数据的线性可分性"><a href="#数据的线性可分性" class="headerlink" title="数据的线性可分性"></a>数据的线性可分性</h1><p>给定一个数据集$T​$，如果存在某个$w \cdot x + b = 0​$能将测试机的正实例和负实例完全正确的划分到超平面两侧，即</p><script type="math/tex; mode=display">\begin{array} { l l } { w \cdot x_i +b > 0 } & { y_i = +1 } \\ {w \cdot x_i +b <0  } & { y_i = -1 } \end{array}</script><p>称数据集$T​$为线性可分数据集（linearly separable data set） 否则，称为线性不可分数据集</p><h1 id="感知机学习策略"><a href="#感知机学习策略" class="headerlink" title="感知机学习策略"></a>感知机学习策略</h1><p>损失函数的一个自然选择是误分类点的总数。但是，这样的损失函数不是参数w,b的连续可导函数，不易优化。损失函数的另一个选择是误分类点到超平面S的总距离，这是感知机所采用的。</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Model </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Statistical_Learning</title>
      <link href="/p/2307439981.html"/>
      <url>/p/2307439981.html</url>
      
        <content type="html"><![CDATA[<p>机器学习现在主要的流派是 统计学习<br>统计学习的主要特点:</p><blockquote><ol><li>统计学习以计算机及网络为平台,建立在计算机及网络之上</li><li>统计学习以数据为研究对象,是数据驱动的学科</li><li>统计学习的目的是对数据进行预测和分析</li><li>统计学习以方法为中心,构建模型并应用模型进行预测和分析</li><li>统计学习是概率论,统计学,信息论,计算理论,最优化理论,计算机科学多个领域的交叉学科,并且在发展中逐步形成了独自的理论体系和方法论</li></ol></blockquote><span id="more"></span><p>统计学习由<strong>supervised learning(监督学习)</strong>,<strong>unsupervised learning(非监督学习)</strong>,<strong>semi-supervised learning(半监督学习)</strong>,<strong>reinforcement learning(强化学习)</strong>等组成</p><p>输入$X$和输出$Y$有不同的类型,可以是连续,也可以是离散,通常根据输入、输出的不同类型,对预测任务给予不同的名称:</p><ol><li>回归问题:输入输出均为连续的预测问题</li><li>分类问题:输出为有限个离散变量的预测问题</li><li>标注问题:输入输出均为变量序列的预测问题</li></ol><p>一般输入实例$x$的特征向量记作</p><script type="math/tex; mode=display">x=(x^{(1)},x^{(2)},\cdots,x^{(n)})^T</script><p>$x^{(i)}$表示$x$的第$i$个特征,$x_i$表示多个输入变量的第$i$个,即</p><script type="math/tex; mode=display">x_i=(x_i^{(1)},x_i^{(2)},\cdots,x_i^{(n)})^T</script><p>训练集通常表示为</p><script type="math/tex; mode=display">T = \{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}</script><p>其中$(x_i,y_i)$称为样本或样本点,$x_i$是输入的观测值,也称为输入或实例,$y_i$是输出的观测值,也称为输出</p><p>监督学习的目的在于学习一个由输入到输出的映射,这一个映射关系称之为<strong>模型</strong>,监督学习的模型可以是概率或非概率模型,由<strong>条件概率分布$P(Y|X)$</strong>或<strong>decision function(决策函数)$Y=f(x)$</strong>表示</p><p>学习过程中系统利用给定的训练数据集,通过学习(训练)得到一个模型,表示为<strong>条件概率分布$\hat P(Y|X)$</strong>或<strong>decision function(决策函数)$Y=\hat f(x)$</strong>.</p><p>预测过程中,系统通过学习产生的模型如果有很好的预测能力,训练样本的输出$y_i$和模型输出$f(x_i)$之间的差就应该足够小.</p><p>模型就是所要学习的条件概率分布或者决策函数,模型的hypothesis space(假设空间)包含所有可能的条件概率分布或者决策函数,所以hypothesis space 中的模型一般由无穷多个</p><p>假设空间一般用$\mathcal { F }$表示,可以定义为决策函数的集合</p><script type="math/tex; mode=display">\mathcal { F } = \{ f | Y = f ( X ) \}</script><p>也可以定义为条件概率的集合</p><script type="math/tex; mode=display">\mathcal { F } = \{ P | P ( Y | X ) \}</script><p>决策函数表示的模型为非概率模型,条件概率表示的模型为概率模型</p><h1 id="loss-function-损失函数-和cost-function-风险函数"><a href="#loss-function-损失函数-和cost-function-风险函数" class="headerlink" title="loss function(损失函数)和cost function(风险函数)"></a>loss function(损失函数)和cost function(风险函数)</h1><p>通常用一个loss function 或者 cost function 来度量预测错误的程度,通常是$f(X)​$和$Y​$的非负实值函数,记作$L(Y,f(x))​$.</p><p>常用的有以下几种</p><ol><li><p>0-1 loss function</p><script type="math/tex; mode=display">L ( Y , f ( X ) ) = \left\{ \begin{array} { l l } { 1 , } & { Y \neq f ( X ) } \\ { 0 , } & { Y = f ( X ) } \end{array} \right.</script></li><li><p>quadratic(平方) loss function</p><script type="math/tex; mode=display">L ( Y , f ( X ) ) = ( Y - f ( X ) ) ^ { 2 }</script></li></ol><ol><li>absolute(绝对) loss function<script type="math/tex; mode=display">L ( Y , f ( X ) ) = | Y - f ( X ) |</script></li></ol><ol><li>logarithmic(对数) loss function 或者 log-likelihood(对数似然) loss function<script type="math/tex; mode=display">L ( Y , P ( Y | X ) ) = - \log P ( Y | X )</script>损失函数值越小,模型就越好,由于模型的输入输出是随机变量,遵循联合分布$P(X,Y)$,所以损失函数的期望是<script type="math/tex; mode=display">R _ { \mathrm { exp } } ( f ) = E _ { P } [ L ( Y , f ( X ) ) ] = \int _ { \mathcal { X } \times \mathcal { y } } L ( y , f ( x ) ) P ( x , y ) \mathrm { d } x \mathrm { d } y</script>这是理论上模型$f(x)​$关于联合分布$P(X,Y)​$平均意义下的损失称为risk funciton(风险函数)或者expected loss(期望损失)</li></ol><p><strong>学习的目标就是选择期望风险最小的模型</strong></p><p>给定一个训练集$T$,模型$f(X)$关于$T$的平均损失称为empirical risk(经验风险)或empirical loss(经验损失),记作$R_{emp}$</p><script type="math/tex; mode=display">R _ { \mathrm { emp } } ( f ) = \frac { 1 } { N } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , f \left( x _ { i } \right) \right)</script><p>所以,当样本$N​$趋于无穷时,$R<em>{emp}(f)​$趋于$R</em>{exp}(f)​$.但是由于现实中训练样本数目有限甚至很小,所以用$R<em>{emp}(f)​$估计$R</em>{exp}(f)​$常常并不理想要对empirical risk进行一定矫正,通常使用两个策略,<strong>empirical risk minimization(ERM,经验风险最小化)</strong>和<strong>structural risk minimization(SRM,结构风险最小化)</strong></p><h1 id="empirical-risk-minimization-and-structural-risk-minimization"><a href="#empirical-risk-minimization-and-structural-risk-minimization" class="headerlink" title="empirical risk minimization and  structural risk minimization"></a>empirical risk minimization and  structural risk minimization</h1><h2 id="ERM"><a href="#ERM" class="headerlink" title="ERM"></a>ERM</h2><p>ERM的策略认为,经验风险最小的模型就是最优的模型,所以按照$R_{emp}​$最小化求最优就是求最优化问题:</p><script type="math/tex; mode=display">\min _ { f \in \mathcal { F } } \frac { 1 } { N } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , f \left( x _ { i } \right) \right)</script><p>当样本足够大时,ERM能保证有很好的学习效果,在实际中被广泛采用,maximum likelihood estimation(极大似然估计)就是ERM的一个例子:当模型是条件概率分布,loss function是logarithmic loss function时,ERM就等价于maximum likelihood estimation.但是样本很小时,效果就未必,会产生over-fitting(过拟合)</p><h2 id="SRM"><a href="#SRM" class="headerlink" title="SRM"></a>SRM</h2><p>SRM就是为了防止over-fitting而提出来的策略,等价于regularization(正则化).结构风险是在经验风险上加上表示模型复杂度的regularizer(正则化项)或penalty term(惩罚项),结构风险的定义是</p><script type="math/tex; mode=display">R _ { \mathrm { srm } } ( f ) = \frac { 1 } { N } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , f \left( x _ { i } \right) \right) + \lambda J ( f )</script><p>$J(f)$为模型复杂度,模型$f$越复杂,$J(f)$就越大,$\lambda \ge0$是系数.贝叶斯估计中maximum posterior probability estimation(MAP,最大后验概率估计)就是SRM一个例子:当模型是条件概率分布,loss function是logarithmic loss function,模型复杂度由模型的先验概率表示时,SRM就等价于MAP.所以SRM求最优模型就是求解:</p><script type="math/tex; mode=display">\min _ { f \in \mathcal { F } } \frac { 1 } { N } \sum _ { i = 1 } ^ { N } L \left( y _ { i } , f \left( x _ { i } \right) \right) + \lambda J ( f )</script><p>统计学习问题归结为最优化问题，如果最优化问题有显式的解析解，这个最优化问题就比较简单，但通常解析解不存在，这就需要用数值计算的方法求解。</p><p>统计学习的目的是使学到的模型不仅对已知数据而且对未知数据都能有很好的预测能力。当损失函数给定时，基于损失函数的模型的训练误差（training error）和模型的测试误差（test error）就自然成为学习方法评估的标准。通常将学习方法对未知数据的预测能力称为泛化能力</p><h1 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h1><p>如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高。这种现象称为过拟合（over-fitting）</p><p>过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好,但对未知数据预测得很差的现象。可以说模型选择旨在避免过拟合并提高模型的预测能力。</p><h1 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h1><p>L0范数($||w||_0$),是指向量$w$中非0的元素的个数.</p><p>L1范数($||w||_0$),指向量中各个元素绝对值之和</p><p>L2范数($||w||_0$),又叫“岭回归”（Ridge Regression）,指向量中各元素的平方和然后开根号。</p><h1 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h1><p>正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大.</p><p>正则化项可以取不同的形式。例如，回归问题中，损失函数是平方损失，正则化项可以是参数向量的L2范数($||w||$表示参数向量w的$L_2$范数):</p><script type="math/tex; mode=display">L(w)= \frac { 1 } { N } \sum _ { i = 1 } ^ { N }(f(x_i;w)-y_i)^2 + \lambda||w||^2</script><p>也可以是$L_1$范数($||w||_1$表示参数向量w的$L_1$范数):</p><script type="math/tex; mode=display">L(w)= \frac { 1 } { N } \sum _ { i = 1 } ^ { N }(f(x_i;w)-y_i)^2 + \lambda||w||_1</script><p>第1项的经验风险较小的模型可能较复杂（有多个非零参数），这时第2项的模型复杂度会较大。正则化的作用是选择经验风险与模型复杂度同时较小的模型。<br>正则化符合奥卡姆剃刀（Occam’s razor）原理。</p><h1 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h1><p>另一种常用的模型选择方法是交叉验证(cross validation)。<br>交叉验证的基本想法是重复地使用数据；把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试以及模型选择。</p><ol><li><p>简单交叉验证<br>简单交叉验证方法是：首先随机地将已给数据分为两部分，一部分作为训练集，另一部分作为测试集（例如，70%的数据为训练集，30%的数据为测试集）；然后用训练集在各种条件下（例如，不同的参数个数）训练模型，从而得到不同的模型；在测试集上评价各个模型的测试误差，选出测试误差最小的模型。</p></li><li><p>S折交叉验证<br>应用最多的是S折交叉验证（S-fold cross validation），方法如下：首先随机地将已给数据切分为S个互不相交的大小相同的子集；然后利用S-1个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的S种选择重复进行；最后选出S次评测中平均测试误差最小的模型。</p></li><li><p>留一交叉验证</p><p>S折交叉验证的特殊情形是S＝N，称为留一交叉验证（leave-one-out cross validation），往往在数据缺乏的情况下使用。这里，N是给定数据集的容量。</p></li></ol><h1 id="生成模型与判别模型"><a href="#生成模型与判别模型" class="headerlink" title="生成模型与判别模型"></a>生成模型与判别模型</h1><p>监督学习方法又可以分为生成方法（generative approach）和判别方法（discriminative approach）。所学到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。</p><p>生成方法的特点：生成方法可以还原出联合概率分布$P(X,Y)$，而判别方法则不能；生成方法的学习收敛速度更快，即当样本容量增加的时候，学到的模型可以更快地收敛于真实模型；当存在隐变量时，仍可以用生成方法学习，此时判别方法就不能用。</p><p>典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型</p><p>判别方法的特点：判别方法直接学习的是条件概率P(Y|X)或决策函数f(X)，直接面对预测，往往学习的准确率更高；由于直接学习P(Y|X)或f(X)，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</p><p>典型的判别模型有：k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法和条件随机场等</p><h1 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h1><p>分类是监督学习的一个核心问题。在监督学习中，当输出变量Y取有限个离散值时，预测问题便成为分类问题。这时，输入变量X可以是离散的，也可以是连续的。监督学习从数据中学习一个分类模型或分类决策函数，称为分类器（classifier）。分类器对新的输入进行输出的预测（prediction），称为分类（classification）。可能的输出称为类（class）。分类的类别为多个时，称为多类分类问题。</p><p>评价分类器性能的指标一般是分类准确率（accuracy），其定义是：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。也就是损失函数是0-1损失时测试数据集上的准确率。</p><p>对于二类分类问题常用的评价指标是精确率（precision）与召回率（recall）。通常以关注的类为正类，其他类为负类，分类器在测试数据集上的预测或正确或不正确，4种情况出现的总数分别记作：<br>    TP——将正类预测为正类数；<br>    FN——将正类预测为负类数；<br>    FP——将负类预测为正类数；<br>    TN——将负类预测为负类数。<br>precision定义为</p><script type="math/tex; mode=display">P = \frac{TP}{TP+FP}</script><p>recall定义为</p><script type="math/tex; mode=display">R = \frac{TP}{TP+FN}</script><p>$F_1$值，即precision和recall的调和均值</p><script type="math/tex; mode=display">\frac{2}{F_1} = \frac{1}{P} + \frac{1}{R} \\F_1 = \frac{2TP}{2TP+FP+FN}</script><p>precision和recall都高时，$F_1$值也会高</p><p>许多统计学习方法可以用于分类，包括k近邻法、感知机、朴素贝叶斯法、决策树、决策列表、逻辑斯谛回归模型、支持向量机、提升方法、贝叶斯网络、神经网络、Winnow等</p><h1 id="标注问题"><a href="#标注问题" class="headerlink" title="标注问题"></a>标注问题</h1><p>标注(tagging)是一个监督学习问题，可以认为标注问题是分类问题的一个推广，标注问题又是更复杂的结构预测（structure prediction）问题的简单形式。标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。注意，可能的标记个数是有限的，但其组合所成的标记序列的个数是依序列长度呈指数级增长的。</p><h1 id="回归问题"><a href="#回归问题" class="headerlink" title="回归问题"></a>回归问题</h1><p>回归（regression）是监督学习的另一个重要问题。回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。回归模型正是表示从输入变量到输出变量之间映射的函数。回归问题的学习等价于函数拟合：选择一条函数曲线使其很好地拟合已知数据且很好地预测未知数据</p><p>回归问题最常用的 loss function 是quadratic(平方) loss function</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Statistical_Learning </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-weakref库</title>
      <link href="/p/2146129643.html"/>
      <url>/p/2146129643.html</url>
      
        <content type="html"><![CDATA[<p>弱引用模块,避免循环引用的GC问题,主要使用<br><code>WeakKeyDictionary</code>,<code>WeakValueDictionary</code>,<code>WeakSet</code>,<code>WeakMethod</code>,<code>finalize</code><br><code>ref</code>,<code>proxy</code>,<code>getweakrefcount</code>,<code>getweakrefs</code><br><span id="more"></span></p><h1 id="WeakValueDictionary"><a href="#WeakValueDictionary" class="headerlink" title="WeakValueDictionary"></a><code>WeakValueDictionary</code></h1><p>实现一种可变映射，里面的value值是对象的弱引用，被引用的对象在程序中的其他地方被当作垃圾回收后，对应的键会自动从 WeakValueDictionary 中删除。因此，WeakValueDictionary 经常用于缓存。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> weakref <span class="keyword">import</span> WeakValueDictionary</span><br><span class="line"></span><br><span class="line">wd = WeakValueDictionary()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items = [T(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    wd[item.v] = item</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(wd))</span><br><span class="line"><span class="keyword">del</span> items[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>(wd))</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&#123;<span class="number">0</span>: &lt;__main__.T <span class="built_in">object</span> at <span class="number">0x10b1427b8</span>&gt;, <span class="number">1</span>: &lt;__main__.T <span class="built_in">object</span> at <span class="number">0x10b6d1588</span>&gt;, <span class="number">2</span>: &lt;__main__.T <span class="built_in">object</span> at <span class="number">0x10b6d1860</span>&gt;&#125;</span><br><span class="line">&#123;<span class="number">1</span>: &lt;__main__.T <span class="built_in">object</span> at <span class="number">0x10b6d1588</span>&gt;, <span class="number">2</span>: &lt;__main__.T <span class="built_in">object</span> at <span class="number">0x10b6d1860</span>&gt;&#125;</span><br></pre></td></tr></table></figure><br>当<code>items[0]</code>被回收，<code>WeakValueDictionary</code>中对应的key-value也被删除</p><h1 id="WeakKeyDictionary"><a href="#WeakKeyDictionary" class="headerlink" title="WeakKeyDictionary"></a><code>WeakKeyDictionary</code></h1><p>与<code>WeakValueDictionary</code>类似,不过是key是对象的弱引用</p><h1 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a><code>WeakSet</code></h1><p>Set的弱引用版本<br>官方示例:如果一个类需要知道所有实例，一种好的方案是创建一个 WeakSet 类型的类属性，保存实例的引用</p><h1 id="WeakMethod"><a href="#WeakMethod" class="headerlink" title="WeakMethod"></a><code>WeakMethod</code></h1><p><code>version&gt;3.4</code><br>模拟对绑定方法的弱引用（即，在类上定义并在实例上查找的方法）。由于绑定方法是短暂的，因此标准的弱引用无法保持它。 WeakMethod有特殊代码重新创建绑定方法，直到对象或原始函数死亡<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line">t= T(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">wm1 = weakref.WeakMethod(t.__init__)</span><br><span class="line">r1 = weakref.ref(t.__init__)</span><br><span class="line"><span class="built_in">print</span>(r1)</span><br><span class="line"><span class="built_in">print</span>(wm1)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;weakref at <span class="number">0x1059f1188</span>; dead&gt; <span class="comment">#r1已经标注dead，也就是obj被GC了</span></span><br><span class="line">&lt;weakref at <span class="number">0x106c32b38</span>; to <span class="string">&#x27;T&#x27;</span> at <span class="number">0x1055b2828</span>&gt;</span><br></pre></td></tr></table></figure></p><h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a><code>finalize</code></h1><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a><code>ref</code></h1><p><code>ref(obj,callback)</code>,获取一个对象的弱引用,返回的是一个<code>weakref</code>类型,允许通过调用它来获取引用对象,对象被释放时调用<code>callback</code>。可以为一个对象构造多个弱引用,每个弱引用注册的回调将从最近注册的回调调用到最早注册的回调。传给回调的参数是弱引用对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = T(<span class="number">1</span>)</span><br><span class="line">r1 = weakref.ref(t)</span><br><span class="line"><span class="built_in">print</span>(r1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r1))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(r1()))</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;weakref at <span class="number">0x10cd09458</span>; to <span class="string">&#x27;T&#x27;</span> at <span class="number">0x10c8ca828</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;weakref&#x27;</span>&gt;</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.T&#x27;</span>&gt;</span><br></pre></td></tr></table></figure></p><h1 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a><code>proxy</code></h1><p><code>proxy(obj,callback)</code>,获取一个对象的代理对象,返回的是一个<code>ProxyType</code>或者<code>CallableProxyType</code>,可以直接当原对象使用,对象被释放时调用<code>callback</code><br>与<code>ref</code>创建的弱引用区别，如果被引用对象被删除，ref会返回None,而proxy则会报错：weakref.ReferenceError<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> weakref</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = T(<span class="number">1</span>)</span><br><span class="line">r1 = weakref.ref(t)</span><br><span class="line">wm1 = weakref.proxy(t)</span><br><span class="line"><span class="built_in">print</span>(r1)</span><br><span class="line"><span class="built_in">print</span>(wm1)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;weakref at <span class="number">0x10625d408</span>; to <span class="string">&#x27;T&#x27;</span> at <span class="number">0x105e1e828</span>&gt;</span><br><span class="line">&lt;__main__.T <span class="built_in">object</span> at <span class="number">0x105e1e828</span>&gt;</span><br></pre></td></tr></table></figure></p><h1 id="getweakrefcount"><a href="#getweakrefcount" class="headerlink" title="getweakrefcount"></a><code>getweakrefcount</code></h1><p><code>getweakrefcount(obj)</code>,返回引用object的弱引用和代理的数量。</p><h1 id="getweakrefs"><a href="#getweakrefs" class="headerlink" title="getweakrefs"></a><code>getweakrefs</code></h1><p><code>getweakrefs(obj)</code>,返回引用object的弱引用和代理的<code>list</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-functools库</title>
      <link href="/p/3627076479.html"/>
      <url>/p/3627076479.html</url>
      
        <content type="html"><![CDATA[<p>常用的一些<br><code>reduce</code>,<code>warps</code>,<code>partial</code>,<code>total_ordering</code>,<code>singledispatch</code>,<code>lru_cache</code><br><span id="more"></span></p><h1 id="reduce这个就没啥好说的了"><a href="#reduce这个就没啥好说的了" class="headerlink" title="reduce这个就没啥好说的了"></a><code>reduce</code>这个就没啥好说的了</h1><p>pass</p><h1 id="warps更好的装饰器"><a href="#warps更好的装饰器" class="headerlink" title="warps更好的装饰器"></a><code>warps</code>更好的装饰器</h1><p>调用<code>partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated)</code>的简写<br>可以将被装饰的函数的<code>__name__</code>、<code>module</code>、<code>__doc__</code>和 <code>__dict__</code>都复制到封装函数去(模块级别常量<code>WRAPPER_ASSIGNMENTS</code>, <code>WRAPPER_UPDATES</code>)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wrap</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;this is wrapper doc&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrapper call&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@wrap</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="string">&quot;this is fun doc&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;func call&#x27;</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span>,func.__name__)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;doc:&#x27;</span>,func.__doc__)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">使用wraps(func)的输出结果:</span><br><span class="line">wrapper call</span><br><span class="line">func call</span><br><span class="line">name: func</span><br><span class="line">doc: this <span class="keyword">is</span> fun doc</span><br><span class="line">不使用的输出结果:</span><br><span class="line">wrapper call</span><br><span class="line">func call</span><br><span class="line">name: wrapper</span><br><span class="line">doc: this <span class="keyword">is</span> wrapper doc</span><br></pre></td></tr></table></figure></p><h1 id="partial偏函数"><a href="#partial偏函数" class="headerlink" title="partial偏函数"></a><code>partial</code>偏函数</h1><p>用一些默认参数包装一个可调用对象,返回结果是可调用对象，并且可以像原始对象一样对待<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">a,*args,g=<span class="number">1</span>,**kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line">func2 = partial(func1,<span class="number">66</span>,<span class="number">77</span>,ww=<span class="number">1</span>,rr=<span class="number">2</span>)</span><br><span class="line">func2(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&#123;<span class="string">&#x27;kwargs&#x27;</span>: &#123;<span class="string">&#x27;ww&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;rr&#x27;</span>: <span class="number">2</span>&#125;, <span class="string">&#x27;args&#x27;</span>: (<span class="number">77</span>, <span class="number">2</span>, <span class="number">3</span>), <span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>: <span class="number">66</span>&#125;</span><br></pre></td></tr></table></figure></p><h1 id="total-ordering自动生成比较方法"><a href="#total-ordering自动生成比较方法" class="headerlink" title="total_ordering自动生成比较方法"></a><code>total_ordering</code>自动生成比较方法</h1><p>如果一个类如果定义了<code>__lt__</code>、<code>__le__</code>、<code>__gt__</code>、<code>__ge__</code>这些方法中的至少一个，使用该装饰器，则会自动的把其他几个比较函数也实现在该类中,但是<code>__eq__</code>必须自己定义，不定义会使用默认的<code>hash(id(obj))</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> total_ordering</span><br><span class="line"></span><br><span class="line"><span class="meta">@total_ordering</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">return</span> self.v &lt;= other.v</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = T(<span class="number">12</span>)</span><br><span class="line">t2 = T(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(t1 &lt; t2)</span><br><span class="line"><span class="built_in">print</span>(t1 == t2)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">不使用total_ordering时会报错：TypeError: <span class="string">&#x27;&lt;&#x27;</span> <span class="keyword">not</span> supported between instances of <span class="string">&#x27;T&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;T&#x27;</span></span><br><span class="line">使用时输出:</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h1 id="singledispatch-单分派范函数，类似重载"><a href="#singledispatch-单分派范函数，类似重载" class="headerlink" title="singledispatch 单分派范函数，类似重载"></a><code>singledispatch</code> 单分派范函数，类似重载</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">obj</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;te&#x27;</span>, obj)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@func.register(<span class="params"><span class="built_in">str</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">r</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;str&#x27;</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@func.register(<span class="params"><span class="built_in">tuple</span></span>)</span></span><br><span class="line"><span class="meta">@func.register(<span class="params"><span class="built_in">list</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_</span>(<span class="params">tu</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;tuple or list&#x27;</span>, tu)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">func((<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">func([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="comment">###</span></span><br><span class="line"><span class="built_in">str</span> a</span><br><span class="line"><span class="built_in">tuple</span> <span class="keyword">or</span> <span class="built_in">list</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">tuple</span> <span class="keyword">or</span> <span class="built_in">list</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>使用<code>singledispatch</code>可以把不同的处理模块分开不用在里面<code>if else</code>了</p><h1 id="lru-cacheLRU模型缓存装饰器"><a href="#lru-cacheLRU模型缓存装饰器" class="headerlink" title="lru_cacheLRU模型缓存装饰器"></a><code>lru_cache</code>LRU模型缓存装饰器</h1><p>可以将函数的处理结果缓存起来，减少调用次数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line"><span class="meta">@lru_cache()</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ff</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">global</span> cnt</span><br><span class="line">    cnt += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> ff(n-<span class="number">2</span>)+ff(n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">ff(<span class="number">21</span>)</span><br><span class="line"><span class="built_in">print</span>(cnt)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">使用lru_cache()的输出为 <span class="number">22</span> ,也就是说ff函数总共调用<span class="number">22</span>次</span><br><span class="line">不使用的输出为 <span class="number">35421</span>，可以看出差距还是有点大的</span><br></pre></td></tr></table></figure><br><code>lru_cache(maxsize=128,typed=False)</code>可以使用两个可选参数<br>第一个就是大小了，最好设为2的幂，如果设为<code>None</code>，那么会无限存储。<br>typed 参数如果设为 True，把不同参数类型得到的结果分开保存，即把通常认为相等的浮点数和整数参数（如 1 和 1.0）区分开。<br><strong><code>lru_cache</code>使用字典存储结果，而且键根据调用时传入的定位参数和关键字参数创建，所以被 <code>lru_cache</code> 装饰的函数，它的所有参数都必须是可散列的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linear_Algebra</title>
      <link href="/p/1766352834.html"/>
      <url>/p/1766352834.html</url>
      
        <content type="html"><![CDATA[<p>线性代数 复习记录</p><span id="more"></span><p>如果 $\overrightarrow{u} = a\overrightarrow{v}+b\overrightarrow{w} $ 在a,b取某些值的时候成立,那么称$\overrightarrow{u}$与$\overrightarrow{v}$,$\overrightarrow{w}$线性相关(Linearly dependent)<br>如果 $\overrightarrow{u} \ne a\overrightarrow{v}+b\overrightarrow{w} $ 对任意a,b成立,那么就称$\overrightarrow{u}$与$\overrightarrow{v}$,$\overrightarrow{w}$线性无关(Linearly independent)</p><p>向量的一组<em>基(basis)</em>是<em>张成(span)</em>该空间的一个<em>线性无关(linearly independent)</em>向量集</p><p>满足以下两个条件的变换称为<em>线性变换</em></p><ol><li>Lines remain lines(直线依旧是直线)</li><li>Origin remains fixed(原点保持不变)</li></ol><p>只满足1的称为<em>仿射变换</em></p><p>$\overrightarrow{u} = a\overrightarrow{v}+b\overrightarrow{w} ​$<br>$Transformed \ \overrightarrow{u} = a(Transformed \ \overrightarrow{v})+b(Transformed \ \overrightarrow{w}) ​$</p><p>线性变换其实就是基的变换,严格来说,线性变换是将向量作为输入和输出的一类函数,<br>将二维平面逆时针旋转90度,就是把<em>基</em>与平面上所有的点与行矩阵乘法</p><script type="math/tex; mode=display">\begin{bmatrix}   0 & -1 \\   1 & 0 \\  \end{bmatrix}  \begin{bmatrix}   x \\   y \\  \end{bmatrix}</script><p>是不是类似于 func([x,y])</p><p>如果变换后的<em>基</em>是线性相关,那么二维平面会变成一条直线(不可逆)</p><h1 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h1><p>n个矩阵相乘的几何意义其实就是n个线性变换相继作用,应用顺序为从右至左</p><script type="math/tex; mode=display">\underbrace {\left[ \begin{array} { c c } { 1 } & { 1 } \\ { 0 } & { 1 } \end{array} \right]} _ { \text { Shear}}\underbrace {\left[ \begin{array} { c c } { 0 } & { - 1 } \\ { 1 } & { 0 } \end{array} \right] } _ { \text { Rotation } } {\left[ \begin{array} { c c } { x } \\ { y }\end{array} \right] }= \underbrace { \left[ \begin{array} { c c } { 1 } & { - 1 } \\ { 1 } & { 0 } \end{array} \right] } _ { \text { Composition } }{\left[ \begin{array} { c c } { x } \\ { y }\end{array} \right] }</script><p>先 Rotaion 再 Shear, 参考函数调用顺序$f(g(x))$ </p><p>对三维空间来说,其实就是三维矩阵</p><p>$\overrightarrow{u} = a\overrightarrow{v}+b\overrightarrow{w}<br>+c\overrightarrow{z} $<br>$(Transformed \ \overrightarrow{u})= a(Transformed \ \overrightarrow{v})+b(Transformed \ \overrightarrow{w})+c(Transformed \ \overrightarrow{z} ) ​$</p><h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><p>其实就是代表<em>面积(三维就是体积)</em>的缩放<em>比例</em>,</p><script type="math/tex; mode=display">det[erminant] \left(\begin{bmatrix}3 & 2 \\0 & 2 \\\end{bmatrix}\right) = 6</script><p>行列式为负,二维下可理解为把空间翻转,三维就是坐标系手性改变了</p><script type="math/tex; mode=display">det \left(\begin{bmatrix}1 & 2 \\1 & -1 \\\end{bmatrix}\right) = -3</script><p>行列式为<strong>0</strong>空间会被降维</p><script type="math/tex; mode=display">det \left(\begin{bmatrix}1.0 & 0.0 & 1.0 \\0.5 & 1.0 & 1.5 \\1.0 & 0.0 & 1.0 \\\end{bmatrix}\right) = 0</script><p>行列式计算</p><script type="math/tex; mode=display">det \left(\begin{bmatrix}a & b \\c & d \\\end{bmatrix}\right) = (a+b)(c+d)-ac-bd-2bd=ad-bc</script><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/p/1766352834/1.png" class="" title="变换后面积图"><script type="math/tex; mode=display">det \left(\begin{bmatrix}a & b & c\\d & e & f\\g & h & i\\\end{bmatrix}\right) = a det \left(\begin{bmatrix}e & f \\h & i \\\end{bmatrix}\right) - b det \left(\begin{bmatrix}d & f \\g & i \\\end{bmatrix}\right) - c det \left(\begin{bmatrix}d & e \\g & h \\\end{bmatrix}\right)</script><script type="math/tex; mode=display">det(M_1M_2) = det(M_1)det(M_2)</script><h1 id="矩阵的用途"><a href="#矩阵的用途" class="headerlink" title="矩阵的用途"></a>矩阵的用途</h1><p>线性方程组</p><script type="math/tex; mode=display">\begin{array} { c }  {2 x + 5 y + 3 z = 0 \\ 4x+0y+8z = 0 \\ 1x +3y +0z = 2}\end{array} \Longrightarrow \underbrace {\overbrace {\left[ \begin{array} { c c c } { 2 } & { 5 } & { 3 } \\ { 4 } & { 0 } & { 8 } \\ { 1 } & { 3 } & { 0 } \end{array} \right] }^{Coefficients(系数)}}_{A}\underbrace {\overbrace {\left[ \begin{array} { l } { x } \\ { y } \\ { z } \end{array} \right] }^{Variables(变量)}}_{\overrightarrow{x}}= \underbrace {\overbrace {\left[ \begin{array} { c } { - 3 } \\ { 0 } \\ { 2 } \end{array} \right] }^{Constants(常数)}}_{\overrightarrow{v}}</script><p>A代表一个线性变换,$A\overrightarrow{x}=\overrightarrow{v}$就是寻找一个$\overrightarrow{x}$,使它在变换后可以与$\overrightarrow{v}$重合</p><p>Inverse matrices(逆矩阵)</p><p>所以当$det(A) \ne 0​$,那么其实就是$\overrightarrow{v}​$进行一个A的逆向变换就能得到$\overrightarrow{x}​$,这个逆变换通常被称为A的逆,也就是$A^{-1}​$,所以$A^{-1}A​$其实是一个什么都没有做的变换,所以$A^{-1}A = \left[ \begin{matrix} 1 &amp; 0 \\ 0 &amp; 1\end{matrix}\right]​$,也就是单位基,也称为单位矩阵.</p><p>但是当$det(A)=0$,也就是降维的时候,那么没有一个变换可以将其复原,因为降维是一个多对一段关系,升维是一个一对多的关系.只有正好$\overrightarrow{v}$也在降维过的维度上才能存在解</p><p>所以只有$det(A)\ne0$,$A^{-1}$才存在.$det(A) = 0$,$A^{-1}$不存在,但是可能有解</p><p>Rank(秩)</p><p>当变换的结果是一条直线,也就是一维时,我们称这个变换的rank为1<br>当变换的结果是一个平面,也就是二维时,我们称这个变换的rank为2<br>所以rank代表变换后空间的维数</p><p>一个2x2的矩阵,它的rank为2时,意味着基向量依旧能张成整个二维空间<br>但是对于3x3的矩阵,它的rank为2时,意味着空间被压缩,也就是降维了</p><h1 id="Column-space-列空间"><a href="#Column-space-列空间" class="headerlink" title="Column space(列空间)"></a>Column space(列空间)</h1><p>所有可能的输出向量$A\overrightarrow{v}$构成的集合称为A的Column space,<br>为什么叫做列空间呢,因为矩阵的列告诉我们基向量变换后的位置,而变换后的基向量张成的空间就是有所可能的变换结果</p><p>所以更精确的rank的定义是column space的维</p><p>数<br>当rank达到最大时,意味着rank与列数相等,称之为<strong>full rank(满秩)</strong><br><strong>$\overrightarrow{0}​$ 一定在column space中,因为线性变换必须保持原点位置不变</strong></p><p>对于full rank来说,唯一能在变换后落在原点的就是$\overrightarrow{0}$自身,<br>而非full rank 来说,因为将空间压缩到了一个更低的维度上,所以会有一系列向量在变换后成为$\overrightarrow{0}$</p><p>举个例子,如果一个二维线性变换的rank为1,也就是将空间压缩到一条直线,那么与column sspace构成的直线不同方向的直线上所有的向量都被压缩到原点</p><p>而一个三维线性变换rank为2,那么同样会有一整条线上的向量在变换后落在原点<br>而rank为1的时候,也就是将空间压缩到一条直线,那么会有一整个平面上的向量会被压缩到原点</p><h1 id="null-space-零空间-or-kernel-核"><a href="#null-space-零空间-or-kernel-核" class="headerlink" title="null space(零空间) or kernel(核)"></a>null space(零空间) or kernel(核)</h1><p>变换后的一些向量落在$\overrightarrow{0}$上,null space 就是这些向量构成的空间</p><p>对于$A\overrightarrow{x}=\overrightarrow{0}$,null space 就是这个方程所有可能的解</p><p>所以,当$A^{-1}$存在时,就能用逆变换求解方程组<br>而不存在时,column space可以让我们知道什么时候存在解<br>而null space 可以帮助我们理解所有可能的解的集合是什么样的</p><h1 id="非方阵"><a href="#非方阵" class="headerlink" title="非方阵"></a>非方阵</h1><p>其实是把空间的映射</p><p>比如$\left[ \begin{matrix} 3 &amp; 1 \\ 4 &amp; 1 \\ 5 &amp; 9 \end{matrix} \right]​$其实是把二维平面映射到三维空间中去了,但是仍然是一个平面,两列代表两个基向量,三行表明每一个基向量在变换后用三个独立坐标表示.</p><p>而$\left[ \begin{matrix} 3 &amp; 1 &amp; 4 \\ 1 &amp; 5 &amp; 9 \end{matrix} \right]$,三列代表三个基向量,也就是说原始空间是三维的,两行代表变换后是二维的,所以这是一个三维到二维的转换</p><h1 id="Dot-product-内积"><a href="#Dot-product-内积" class="headerlink" title="Dot product (内积)"></a>Dot product (内积)</h1><script type="math/tex; mode=display">\left[ \begin{matrix} a \\ b  \\ c \end{matrix} \right] \cdot\left[ \begin{matrix}d \\ e \\ f \end{matrix} \right]=ad+be+cf</script><p>就是将两个矩阵对应位置的数相乘的和</p><p>几何意义,$\overrightarrow{w}$在$\overrightarrow{v}$上的正交投影 * $\overrightarrow{v}$的长度</p><script type="math/tex; mode=display">\overrightarrow{a}\cdot\overrightarrow{b} = |a||b|cos\theta \\ \theta为\overrightarrow{a} \overrightarrow{b}夹角</script><p>所以</p><p>$\overrightarrow{a} \cdot \overrightarrow{b} &gt; 0$,方向同向</p><p>$\overrightarrow{a} \cdot \overrightarrow{b} = 0$,两向量垂直</p><p>$\overrightarrow{a} \cdot \overrightarrow{b} &lt; 0$,方向相反</p>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> Linear_Algebra </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-inspect库</title>
      <link href="/p/4095598488.html"/>
      <url>/p/4095598488.html</url>
      
        <content type="html"><![CDATA[<p><code>inspect</code> 模块主要用来 </p><ol><li>type checking</li><li>getting source code</li><li>inspecting classes and functions</li><li>examining the interpreter stack</li></ol><span id="more"></span><p>常用函数<br><code>isxxx()</code> 判断是不是某个类别<br>eg.<br><code>ismodule isclass ismethod isfunction ...</code></p><p><code>getxxx()</code> 获取信息<br>eg.</p><blockquote><p>getmembers(obj[,predicate]) 获取obj的所有成员，perdicate可以用来传入一个func来过滤 比如getmembers(obj,isfunction) 获取obj的所有函数<br>getfile(obj) 获取obj定义的文件<br>getsource(obj) 获取obj定义的源码<br><del>getargspec</del>(callable_obj) 即将弃用，专用signature(),获取一个可调用obj的参数信息，不支持指定的kw参数(def t(*,g=1))<br>getfullargspec(callable_obj) 获取一个可调用obj的参数信息，支持指定的kw参数</p></blockquote><p><code>signature(callable_obj,*,follow_wrapped=True)</code> 这个在python3.3新引入的函数,会返回一个<code>Signature</code>对象,如果是实例方法不会返回<code>self</code>,但是<code>getfullargspec</code>会:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ttt</span>(<span class="params">self,a,b=<span class="number">1</span>,*args,g=<span class="number">1</span>,**kw</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">t = T()</span><br><span class="line"><span class="built_in">print</span>(inspect.getfullargspec(T.ttt))</span><br><span class="line"><span class="built_in">print</span>(inspect.signature(T.ttt))</span><br><span class="line"><span class="built_in">print</span>(inspect.getfullargspec(t.ttt))</span><br><span class="line"><span class="built_in">print</span>(inspect.signature(t.ttt))</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">FullArgSpec(args=[<span class="string">&#x27;self&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], varargs=<span class="string">&#x27;args&#x27;</span>, varkw=<span class="string">&#x27;kw&#x27;</span>, defaults=(<span class="number">1</span>,), kwonlyargs=[<span class="string">&#x27;g&#x27;</span>], kwonlydefaults=&#123;<span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>&#125;, annotations=&#123;&#125;)</span><br><span class="line">(self, a, b=<span class="number">1</span>, *args, g=<span class="number">1</span>, **kw)</span><br><span class="line">FullArgSpec(args=[<span class="string">&#x27;self&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>], varargs=<span class="string">&#x27;args&#x27;</span>, varkw=<span class="string">&#x27;kw&#x27;</span>, defaults=(<span class="number">1</span>,), kwonlyargs=[<span class="string">&#x27;g&#x27;</span>], kwonlydefaults=&#123;<span class="string">&#x27;g&#x27;</span>: <span class="number">1</span>&#125;, annotations=&#123;&#125;)</span><br><span class="line">(a, b=<span class="number">1</span>, *args, g=<span class="number">1</span>, **kw)</span><br></pre></td></tr></table></figure></p><p>一个校验器:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">typeassert</span>(<span class="params">*ty_args, **ty_kargs</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">        sig = inspect.signature(func)</span><br><span class="line">        btypes = sig.bind_partial(*ty_args, **ty_kargs).arguments</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kargs</span>):</span><br><span class="line">            <span class="keyword">for</span> name, obj <span class="keyword">in</span> sig.bind(*args, **kargs).arguments.items():</span><br><span class="line">                <span class="keyword">if</span> name <span class="keyword">in</span> btypes:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(obj, btypes[name]):</span><br><span class="line">                        <span class="keyword">raise</span> TypeError(<span class="string">&#x27;&quot;%s&quot; must be &quot;%s&quot;&#x27;</span> % (name, btypes[name]))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@typeassert(<span class="params"><span class="built_in">int</span>, <span class="built_in">str</span>, <span class="built_in">list</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">1</span>, [])</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-抽象-abc模块</title>
      <link href="/p/1366314061.html"/>
      <url>/p/1366314061.html</url>
      
        <content type="html"><![CDATA[<p>abc 模块  抽象相关</p><p>abc.ABCMeta 抽象元类<br>__subclasshook__ 虚拟子类<br><span id="more"></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDuck</span>(metaclass = abc.ABCMeta):</span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__subclasshook__</span>(<span class="params">cls, other</span>):</span><br><span class="line">quack = <span class="built_in">getattr</span>(other, <span class="string">&#x27;quack&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">callable</span>(quack)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Duck</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quack</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NotDuck</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">quack = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>issu bclass(Duck, AbstractDuck)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(NotDuck, AbstractDuck)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment"># 当 __subclasshook__方法被定义时，它优先于register方法。</span></span><br><span class="line"><span class="comment"># register 可以将一个类注册为自己的子类 可以当作装饰器使用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>AbstractDuck.register(NotDuck)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.NotDuck&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(NotDuck, AbstractDuck)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment"># 如果__subclasshook__方法返回NotImplemented，然后（并且只有然后）传统检测的路径就会查看已注册的类是否已被选中。</span></span><br><span class="line"><span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractDuck</span>(metaclass = abc.ABCMeta):</span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__subclasshook__</span>(<span class="params">cls, other</span>):</span><br><span class="line">quack = <span class="built_in">getattr</span>(other, <span class="string">&#x27;quack&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">callable</span>(quack):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(NotDuck, AbstractDuck)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>AbstractDuck.register(NotDuck)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.NotDuck&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">issubclass</span>(NotDuck, AbstractDuck)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-抽象-metaclass</title>
      <link href="/p/2265551918.html"/>
      <url>/p/2265551918.html</url>
      
        <content type="html"><![CDATA[<p><strong>元类用于创建类，而类用于创建实例</strong><br>python解释器在遇到类定义的时候，其实是用<code>type()</code>函数动态创建的类类型</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(A))</span><br><span class="line"><span class="built_in">print</span>(A.__bases__)</span><br><span class="line"><span class="comment">### 输出</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;,)</span><br><span class="line"><span class="comment">#类似执行了下面的代码</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">A = <span class="built_in">type</span>(<span class="string">&#x27;A&#x27;</span>,(<span class="built_in">object</span>,),<span class="built_in">dict</span>(test=f))</span><br></pre></td></tr></table></figure><p>  所以类<code>A</code>其实也是一个对象，继承于<code>object</code>，而且是<code>type</code>的一个对象(<code>type</code>也是一个类哦！)<br>  <code>metaclass</code>(元类)又是什么呢，上面<code>A = type(&#39;A&#39;,(object,),dict(test=f))</code>使用<code>type</code>来创建的类，那么如果我声明一个类去继承<code>type</code>，是不是可以<code>A = mytype(&#39;A&#39;,(object,),dict(test=f))</code>来创建类呢，bingo，其实就是这样.<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AMetaclass</span>(<span class="title class_ inherited__">type</span>):<span class="comment">#一般元类以Metaclass结尾</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">A = AMetaclass(<span class="string">&#x27;A&#x27;</span>,(<span class="built_in">object</span>,),<span class="built_in">dict</span>())</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(A))</span><br><span class="line"><span class="built_in">print</span>(A.__bases__)</span><br><span class="line"><span class="comment">### 输出</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.AMetaclass&#x27;</span>&gt;</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;,)</span><br></pre></td></tr></table></figure><br>  可以看到，<code>A</code>变成了<code>AMetaclass</code>的一个对象<br>  那么<code>type</code>又是一个什么呢，和<code>object</code>又是什么关系?<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span>.__class__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">object</span>.__bases__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>.__class__)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>.__bases__)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line">()</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;type&#x27;</span>&gt;</span><br><span class="line">(&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;,)</span><br></pre></td></tr></table></figure><br>  可以看出来，<code>object</code>是<code>type</code>的一个对象，<code>type</code>继承于<code>object</code>，所以说,<code>object</code> 和 <code>type</code> 的关系很像鸡和蛋的关系，先有<code>object</code>还是先有<code>type</code>没法说，<code>object</code>和<code>type</code>是共生的关系，必须同时出现的.</p><p>下面是一个实现示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DemoMetaClass</span>(<span class="title class_ inherited__">type</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, name,bases,attrs</span>) -&gt; <span class="built_in">type</span>:</span><br><span class="line">        attrs[<span class="string">&#x27;true_name&#x27;</span>] = <span class="string">&#x27;demo&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls, name,bases,attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(metaclass=DemoMetaClass):</span><br><span class="line">    Atemp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ttttO</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">dir</span>(A))</span><br><span class="line"><span class="built_in">print</span>(A.true_name)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">[<span class="string">&#x27;Atemp&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;true_name&#x27;</span>, <span class="string">&#x27;ttttO&#x27;</span>]</span><br><span class="line">demo</span><br></pre></td></tr></table></figure><p>可以看到，动态的往<code>A</code>里面添加了一个<code>true_name</code>的属性</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-抽象-概念与基础</title>
      <link href="/p/4279072962.html"/>
      <url>/p/4279072962.html</url>
      
        <content type="html"><![CDATA[<p>python中的抽象被称为 <code>duck typing</code>模式，如果它看起来像一只鸭子并且叫起来像一只鸭子，那么它大概就是一只鸭子。<br>有很多种方式实现抽象，特点也不同<br><span id="more"></span></p><ol><li>使用<code>NotImplementedError</code>,这种也是最基础使用最多的方式<br> <strong><code>NotImplemented</code> <code>return</code>一个没有实现的标记，表示可以由其他对象实现</strong><br> <strong><code>NotImplementError</code> <code>raise</code>一个没有实现的错误，必须实现</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;A eq&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, A):</span><br><span class="line">            <span class="keyword">return</span> self.v == other.v</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, B):</span><br><span class="line">            <span class="keyword">return</span> other.v == self.v</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other,C):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, v</span>):</span><br><span class="line">        self.v = v</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;B eq&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, B):</span><br><span class="line">            <span class="keyword">return</span> self.v == other.v</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NotImplemented</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError</span><br><span class="line"></span><br><span class="line">a = A(<span class="number">1</span>)</span><br><span class="line">b = B(<span class="number">3</span>)</span><br><span class="line">c = C()</span><br><span class="line"><span class="built_in">print</span>(a == b)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(b == a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(a == c)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;-&#x27;</span>*<span class="number">20</span>)</span><br><span class="line"><span class="built_in">print</span>(b == c)</span><br><span class="line"><span class="comment">### 输出为</span></span><br><span class="line">A eq</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">--------------------</span><br><span class="line">B eq</span><br><span class="line">A eq</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">--------------------</span><br><span class="line">A eq</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">--------------------</span><br><span class="line">B eq</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/didi/code/python/test/pack.py&quot;</span>, line <span class="number">45</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">print</span>(b == c)</span><br><span class="line">  File <span class="string">&quot;/Users/didi/code/python/test/pack.py&quot;</span>, line <span class="number">34</span>, <span class="keyword">in</span> __eq__</span><br><span class="line">    <span class="keyword">raise</span> NotImplementedError</span><br><span class="line">NotImplementedError</span><br></pre></td></tr></table></figure></li></ol><p>可以看出来</p><blockquote><ol><li><code>a==b</code> 调用的过程是<code>A::__eq__</code>，因为<code>A::__eq__</code>里实现了与<code>B</code>的比较， </li><li>而<code>b==a</code>调用过程是<code>B::__eq__-&gt;A::__eq__</code>，因为<code>B::__eq__</code>中没有实现与<code>A</code>的比较，所以返回了一个<code>NotImplemented</code>，这样会去调用<code>A::__eq__</code>，所以得到了<code>False</code></li><li><code>a == c b == c</code>与上面类似，不过因为<code>C::__eq__</code>直接抛出了一个<code>NotImplementedError</code>所以程序直接报错了</li></ol></blockquote><ol><li>元类 见 <a href="/p/2265551918.html" title="python-抽象-metaclass">python-抽象-metaclass</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-字节操作</title>
      <link href="/p/2976155030.html"/>
      <url>/p/2976155030.html</url>
      
        <content type="html"><![CDATA[<p>有的时候需要操作到字节层面，需要<code>struct</code>模块的支持<br>而内置函数<code>memoryview</code>提供了按字节的内存访问接口，好处是不会有内存拷贝，类似于c指针<br>一般与<code>array.array</code> <code>bytearray</code> 一起使用<br><span id="more"></span><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># memoryview示例</span></span><br><span class="line">a = <span class="string">&#x27;aaaaaa&#x27;</span></span><br><span class="line">ma = <span class="built_in">memoryview</span>(a.encode()) <span class="comment">#只能传入一个支持buffer protocol的object，原生支持的只有bytes和bytearray 返回一个memoryview</span></span><br><span class="line"><span class="comment"># 比如 mb = memoryview(b&#x27;aaaaa&#x27;)</span></span><br><span class="line">ma.readonly <span class="comment"># 设为只读，不能修改</span></span><br><span class="line">mm = ma.toreadonly() <span class="comment"># mm是只读</span></span><br><span class="line">mb = ma[:<span class="number">2</span>] <span class="comment"># mb = [97,97]</span></span><br><span class="line">ma.tobytes() <span class="comment"># 转成bytes b&#x27;aaaaa&#x27;</span></span><br><span class="line">ma.tolist() <span class="comment"># 转成list [97,97,97,97]</span></span><br><span class="line"></span><br><span class="line">b = <span class="built_in">bytearray</span>(<span class="string">b&#x27;asdf&#x27;</span>) <span class="comment"># b&#x27;asdf&#x27;是一个bytes类型，bytearray和bytes不一样的地方在于，bytearray是可变的。</span></span><br><span class="line">mb = <span class="built_in">memoryview</span>(b)</span><br></pre></td></tr></table></figure></p><p><code>struct</code>中主要的三个函数<code>pack() unpack() calcsize()</code><br><code>pack(fmt,v1,v2,...)</code> 根据所给的fmt将v1,v2,…转换为一个bytes<br><code>unpack(fmt,bytes)</code> 根据所给的fmt将bytes 解析，转为元组<br><code>calcsize(fmt)</code> 根据所给fmt返回结构的大小</p><blockquote><p>fmt 列表如下<br>编码格式,放在<code>fmt</code>第一位</p><div class="table-container"><table><thead><tr><th style="text-align:left">Character</th><th>Byte order</th><th>Size and alignment</th></tr></thead><tbody><tr><td style="text-align:left">@(default)</td><td>native order</td><td>native            凑够4个字节</td></tr><tr><td style="text-align:left">=</td><td>native order</td><td>standard        按原字节数</td></tr><tr><td style="text-align:left">&lt;</td><td>little-endian</td><td>standard        按原字节数</td></tr><tr><td style="text-align:left">&gt;</td><td>big-endian</td><td>standard        按原字节数</td></tr><tr><td style="text-align:left">!</td><td>network(same as &gt;)</td><td>standard        按原字节数</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:left">Format</th><th>C Type</th><th>Python</th><th>字节数</th></tr></thead><tbody><tr><td style="text-align:left">x</td><td>pad byte</td><td>no value</td><td>1</td></tr><tr><td style="text-align:left">c</td><td>char</td><td>bytes of length 1</td><td>1</td></tr><tr><td style="text-align:left">b</td><td>signed char</td><td>integer</td><td>1</td></tr><tr><td style="text-align:left">B</td><td>unsigned char</td><td>integer</td><td>1</td></tr><tr><td style="text-align:left">?</td><td>_Bool</td><td>bool</td><td>1</td></tr><tr><td style="text-align:left">h</td><td>short</td><td>integer</td><td>2</td></tr><tr><td style="text-align:left">H</td><td>unsigned short</td><td>integer</td><td>2</td></tr><tr><td style="text-align:left">i</td><td>int</td><td>integer</td><td>4</td></tr><tr><td style="text-align:left">I</td><td>unsigned int</td><td>integer</td><td>4</td></tr><tr><td style="text-align:left">l</td><td>long</td><td>integer</td><td>4</td></tr><tr><td style="text-align:left">L</td><td>unsigned long</td><td>integer</td><td>4</td></tr><tr><td style="text-align:left">q</td><td>long long</td><td>integer</td><td>8</td></tr><tr><td style="text-align:left">Q</td><td>unsigned long long</td><td>integer</td><td>8</td></tr><tr><td style="text-align:left">f</td><td>float</td><td>float</td><td>4</td></tr><tr><td style="text-align:left">d</td><td>double</td><td>float</td><td>8</td></tr><tr><td style="text-align:left">s</td><td>char[]</td><td>bytes</td><td>1</td></tr><tr><td style="text-align:left">p</td><td>char[]</td><td>bytes</td><td>1</td></tr><tr><td style="text-align:left">P</td><td>void *</td><td>integer</td></tr></tbody></table></div><p>注意：</p><ol><li><p>c,s和p按照bytes对象执行转码操作，但是在使用UTF-8编码时，也支持str对象。</p></li><li><p>‘?’按照C99中定义的_Bool类型转码。如果该类型不可用，可使用一个char冒充。</p></li><li><p>‘q’和’Q’仅在64位系统上有用。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = struct.pack(<span class="string">&#x27;B2sII&#x27;</span>, <span class="number">0x04</span>, <span class="string">&#x27;aa&#x27;</span>, <span class="number">0x01</span>, <span class="number">0x0e</span>)</span><br><span class="line"><span class="comment"># &#x27;B2sII&#x27;指的就是 一个unsigned short,一个char[2],一个unsigned int,一个unsigned int</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># struct示例</span></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">fmt = <span class="string">&#x27;&lt;3s3sHH&#x27;</span>  <span class="comment"># &lt; 是小字节序，3s3s 是两个 3 字节序列，HH 是两个 16 位二进制整数。</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;filter.gif&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        img = <span class="built_in">memoryview</span>(fp.read())  <span class="comment"># 使用内存中的文件内容创建一个 memoryview 对象……</span></span><br><span class="line"></span><br><span class="line">header = img[:<span class="number">10</span>]  </span><br><span class="line"><span class="built_in">bytes</span>(header)  <span class="comment"># 转换成字节序列，这只是为了显示；这里复制了 10 字节</span></span><br><span class="line"><span class="comment"># b&#x27;GIF89a+\x02\xe6\x00&#x27;</span></span><br><span class="line">struct.unpack(fmt, header)</span><br><span class="line"><span class="comment"># (b&#x27;GIF&#x27;, b&#x27;89a&#x27;, 555, 230)</span></span><br><span class="line"><span class="keyword">del</span> header</span><br><span class="line"><span class="keyword">del</span> img</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python-logic</title>
      <link href="/p/3103981124.html"/>
      <url>/p/3103981124.html</url>
      
        <content type="html"><![CDATA[<p><code>and</code> <code>or</code> <code>not</code><br>优先级<br><code>not &gt; and &gt; or</code><br><span id="more"></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&#x27;s&#x27;</span></span><br><span class="line">w = <span class="string">&#x27;w&#x27;</span></span><br><span class="line"><span class="comment"># and or not</span></span><br><span class="line"><span class="comment"># 优先级</span></span><br><span class="line"><span class="comment"># not &gt; and &gt; or</span></span><br><span class="line"><span class="built_in">print</span>(s <span class="keyword">and</span> w)  <span class="comment"># w</span></span><br><span class="line"><span class="built_in">print</span>(s <span class="keyword">or</span> w)  <span class="comment"># s</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">and</span> s)  <span class="comment"># s</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">and</span> w)  <span class="comment"># w</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">and</span> <span class="literal">False</span> <span class="keyword">and</span> s)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span> <span class="keyword">and</span> <span class="literal">True</span> <span class="keyword">and</span> s)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(s <span class="keyword">and</span> <span class="literal">True</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(s <span class="keyword">and</span> <span class="literal">False</span>)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">True</span> <span class="keyword">or</span> s)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="literal">False</span> <span class="keyword">or</span> s)  <span class="comment"># s</span></span><br><span class="line"><span class="built_in">print</span>(s <span class="keyword">or</span> <span class="literal">False</span>)  <span class="comment"># s</span></span><br><span class="line"><span class="built_in">print</span>(s <span class="keyword">or</span> <span class="literal">True</span>)  <span class="comment"># s</span></span><br><span class="line"><span class="built_in">print</span>(s <span class="keyword">and</span> w <span class="keyword">or</span> <span class="literal">False</span>)  <span class="comment"># w</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python的__del__</title>
      <link href="/p/778424663.html"/>
      <url>/p/778424663.html</url>
      
        <content type="html"><![CDATA[<p>今天碰上了一个问题，先上代码<br><span id="more"></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlsxwriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.work = xlsxwriter.Workbook(<span class="string">&#x27;a.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;del&#x27;</span>)</span><br><span class="line">        self.work.close()</span><br><span class="line"></span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure><p>也没做什么特殊操作，就是在析构的时候调用一下<code>workbook</code>的<code>close</code>而已，然而这段代码会报一个错误<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Exception ignored <span class="keyword">in</span>: &lt;bound method A.__del__ of &lt;__main__.A <span class="built_in">object</span> at <span class="number">0x103633588</span>&gt;&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/Users/svz/code/python/test/t/a.py&quot;</span>, line <span class="number">10</span>, <span class="keyword">in</span> __del__</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.6/site-packages/xlsxwriter/workbook.py&quot;</span>, line <span class="number">306</span>, <span class="keyword">in</span> close</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.6/site-packages/xlsxwriter/workbook.py&quot;</span>, line <span class="number">649</span>, <span class="keyword">in</span> _store_workbook</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.6/site-packages/xlsxwriter/packager.py&quot;</span>, line <span class="number">132</span>, <span class="keyword">in</span> _create_package</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.6/site-packages/xlsxwriter/packager.py&quot;</span>, line <span class="number">189</span>, <span class="keyword">in</span> _write_worksheet_files</span><br><span class="line">  File <span class="string">&quot;/usr/local/lib/python3.6/site-packages/xlsxwriter/xmlwriter.py&quot;</span>, line <span class="number">41</span>, <span class="keyword">in</span> _set_xml_writer</span><br><span class="line">  File <span class="string">&quot;/usr/local/Cellar/python/3.6.5_1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/codecs.py&quot;</span>, line <span class="number">897</span>, <span class="keyword">in</span> <span class="built_in">open</span></span><br><span class="line">AttributeError: module <span class="string">&#x27;builtins&#x27;</span> has no attribute <span class="string">&#x27;open&#x27;</span></span><br><span class="line"><span class="comment"># 或者是另外一段错误，这是在另外一台电脑上执行的结果</span></span><br><span class="line">ModuleNotFoundError: <span class="keyword">import</span> of re halted; <span class="literal">None</span> <span class="keyword">in</span> sys.modules</span><br></pre></td></tr></table></figure></p><p>这就引发了我的好奇了，为什么直接调用<code>close()</code>不出错，但是在<code>__del__</code>里调用<code>close()</code>会出现错误呢，而且看报错信息都是和<code>Module</code>相关的?<br>查看了一些文档经过一些测试之后，发现问题还是出在<code>__del__</code>上面</p><p>首先我们得先知道<code>__del__</code>是在什么时候调用的呢，我们看看官方的说法</p><blockquote><p>Called when the instance is about to be destroyed. This is also called a finalizer or (improperly) a destructor. If a base class has a <strong>del</strong>() method, the derived class’s <strong>del</strong>() method, if any, must explicitly call it to ensure proper deletion of the base class part of the instance.<br>   It is possible (though not recommended!) for the <strong>del</strong>() method to postpone destruction of the instance by creating a new reference to it. This is called object resurrection. It is implementation-dependent whether <strong>del</strong>() is called a second time when a resurrected object is about to be destroyed; the current CPython implementation only calls it once.<br>   It is not guaranteed that <strong>del</strong>() methods are called for objects that still exist when the interpreter exits.<br>   Note del x doesn’t directly call x.<strong>del</strong>() — the former decrements the reference count for x by one, and the latter is only called when x’s reference count reaches zero.<br>  CPython implementation detail: It is possible for a reference cycle to prevent the reference count of an object from going to zero. In this case, the cycle will be later detected and deleted by the cyclic garbage collector. A common cause of reference cycles is when an exception has been caught in a local variable. The frame’s locals then reference the exception, which references its own traceback, which references the locals of all frames caught in the traceback.<br>    See also Documentation for the gc module.<br>  Warning Due to the precarious circumstances under which <strong>del</strong>() methods are invoked, exceptions that occur during their execution are ignored, and a warning is printed to sys.stderr instead. In particular:<br>  <strong>del</strong>() can be invoked when arbitrary code is being executed, including from any arbitrary thread. If <strong>del</strong>() needs to take a lock or invoke any other blocking resource, it may deadlock as the resource may already be taken by the code that gets interrupted to execute <strong>del</strong>().<br>  <strong>del</strong>() can be executed during interpreter shutdown. As a consequence, the global variables it needs to access (including other modules) may already have been deleted or set to None. Python guarantees that globals whose name begins with a single underscore are deleted from their module before other globals are deleted; if no other references to such globals exist, this may help in assuring that imported modules are still available at the time when the <strong>del</strong>() method is called.</p></blockquote><p>  注意看这一段</p><blockquote><p>can be executed during interpreter shutdown. As a consequence, the global variables it needs to access (including other modules) may already have been deleted or set to None</p></blockquote><p> 什么意思呢，意思就是<code>__del__</code>可以在解释器关闭期间执行，所以它可能已经删除了(设置为<code>None</code>)一些需要访问的全局变量(包括其它的模块)<br> 所以就是说，按照上面的写法，可能在执行<code>__del__</code>的时候，一些其它的模块已经被干掉了，所以<code>builtins</code>里的<code>open</code>已经被干掉了，所以会报找不到这个方法的错误。<br> 下面的<code>re</code>被干掉又是为什么呢？<br> python导入模块之后会在sys.module中添加上对应的信息，所以在<code>sys</code>被干掉的时候，这个信息也没了，所以<code>re</code>也被干掉了<br> 下面上验证代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> xlsxwriter</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.modules)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.work = xlsxwriter.Workbook(<span class="string">&#x27;a.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;del&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(sys.modules)</span><br><span class="line">        self.work.close()</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br></pre></td></tr></table></figure></p><p>这段代码执行结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;builtins&#x27;</span>: &lt;module <span class="string">&#x27;builtins&#x27;</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">&#x27;sys&#x27;</span>: &lt;module <span class="string">&#x27;sys&#x27;</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">&#x27;_frozen_importlib&#x27;</span>: &lt;module <span class="string">&#x27;importlib._bootstrap&#x27;</span> (frozen)&gt;, <span class="string">&#x27;_imp&#x27;</span>: &lt;module <span class="string">&#x27;_imp&#x27;</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">&#x27;_warnings&#x27;</span>: &lt;module <span class="string">&#x27;_warnings&#x27;</span> (built-<span class="keyword">in</span>)&gt;, <span class="string">&#x27;_thread&#x27;</span>: &lt;module <span class="string">&#x27;_thread&#x27;</span> (built-<span class="keyword">in</span>)&gt;...&#125;<span class="comment">#太长了省略一下</span></span><br><span class="line">end</span><br><span class="line"><span class="keyword">del</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到end会在del之前输出，也就是已经开始关闭解释器了，并且<strong>del</strong>中<code>sys.modules</code>已经是空的了</p><p>怎么可以避免这个问题呢？<br>第一种手动去调用<code>del a</code><br>第二种就是这么写<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    a=A()</span><br><span class="line">   </span><br><span class="line">test()</span><br></pre></td></tr></table></figure></p><p>这样的话a是一个局部变量，函数结束的时候就会释放掉<br>总之，就是确保在解释器关闭之前释放</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎对比</title>
      <link href="/p/1881314122.html"/>
      <url>/p/1881314122.html</url>
      
        <content type="html"><![CDATA[<h1 id="Solr"><a href="#Solr" class="headerlink" title="Solr"></a>Solr</h1><ol><li>支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式。</li><li>Solr比较成熟、稳定。</li><li>不考虑建索引的同时进行搜索，速度更快。</li></ol><h1 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h1><ol><li>Elasticsearch是分布式的。不需要其他组件，分发是实时的，被叫做”Push replication”。</li><li>Elasticsearch 完全支持 Apache Lucene 的接近实时的搜索。</li><li>处理多租户（multitenancy）不需要特殊配置，而Solr则需要更多的高级设置。</li><li>Elasticsearch 采用 Gateway 的概念，使得完备份更加简单。</li><li>各节点组成对等的网络结构，某些节点出现故障时会自动分配其他节点代替其进行工作。</li></ol><span id="more"></span><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ul><li><p>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</p></li><li><p>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</p></li><li><p>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</p></li><li><p>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。</p><blockquote><p> Solr 查询快，但更新索引时慢（即插入删除慢），eg：电商等查询多的应用；</p><p>ES建立索引快（即查询慢），即实时性查询快，eg：facebook新浪等搜索。</p></blockquote></li></ul><h2 id="solr-es的特点："><a href="#solr-es的特点：" class="headerlink" title="solr/es的特点："></a>solr/es的特点：</h2><ol><li>源自搜索引擎，侧重搜索与全文检索。</li><li>数据规模从几百万到几千万不等，数据量过亿的集群特别少。 Ps:有可能存在个别系统数据量过亿，但这并不是普遍现象（就像oracle的表里的数据规模有可能超过hive里一样，但需要小型机）。</li></ol><h2 id="solr-es的索引："><a href="#solr-es的索引：" class="headerlink" title="solr/es的索引："></a>solr/es的索引：</h2><ol><li>一级跳跃表是完全load在内存中的，除了需要消耗很多内存，首次打开索引的加载速度会特别慢，在solr\es中的索引是一直处于打开状态的，不会频繁的打开与关闭；这种模式会制约一台机器的索引数量与索引规模，通常一台机器固定负责某个业务的索引。</li><li>排序和统计（sum，max，min），是通过遍历倒排表，将某一列的全部值都load到内存里，然后基于内存数据进行统计即使一次查询只会用到其中的一条记录，也会将整列的全部值都load到内存里,台浪费资源，首次查询的性能太差。数据规模受物理内存限制很大，索引规模上千万后OOM是常事。</li><li>索引存储在本地硬盘，出现异常后，因为数据要恢复，copy的时间要太久。</li><li>支持master/slave模式，但是跟传统mysql数据库一样，集群规模并没有特别大的。</li><li>这种模式处理集群规模受限外，每次扩容的数据迁移将是一件非常痛苦的事情，数据迁移时间太久。</li><li>倒排检索即使某个词语存在数据倾斜，因数据量比较小，也可以将全部的doclist都读取过来（比如说男、女），这个doclist会占用较大的内存进行cache，当然在数据规模较小的情况下占用内存不是特别多，查询命中率很高，会提升检索速度，但是数据规模上来后，这里的内存问题越来越严重。</li><li>Merger server只能是一个，制约了查询的节点数量；数据不能进行动态分区，数据规模上来后单个索引太大。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow</title>
      <link href="/p/453637644.html"/>
      <url>/p/453637644.html</url>
      
        <content type="html"><![CDATA[<p>问题汇总<br><span id="more"></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.</span><br><span class="line">  from ._conv import register_converters as _register_converters</span><br><span class="line"></span><br><span class="line">#解决方案</span><br><span class="line">pip install h5py==2.8.0rc1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>coroutine</title>
      <link href="/p/1555438704.html"/>
      <url>/p/1555438704.html</url>
      
        <content type="html"><![CDATA[<p>协程的语法和生成器类似，都是定义体中包含<code>yield</code>关键字的函数。在协程中，<code>yield</code>通常出现在表达式右边。可以产出值，也可以不产出——如果 yield 关键字后面没有表达式，那么生成器产出 None。协程可能会从调用方接收数据，不过调用方把数据提供给协程使用的是 <code>.send(value)</code> 方法，而不是<code>next(...)</code> 函数。通常，调用方会把值推送给协程。</p><span id="more"></span><p>生成器的调用方可以使用 .send(…) 方法发送数据，发送的数据会成为生成器函数中 yield 表达式的值。因此，生成器可以作为协程使用。协程是指一个过程，这个过程与调用方协作，产出由调用方提供的值。生成器可以返回一个值 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">simple_coro</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro begin&#x27;</span>)</span><br><span class="line">    x = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x:&#x27;</span>,x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;begin&#x27;</span>)</span><br><span class="line">a = simple_coro()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;init coro&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line">    <span class="built_in">print</span>(a.send(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">begin</span><br><span class="line">init coro</span><br><span class="line">coro begin</span><br><span class="line"><span class="number">1</span></span><br><span class="line">x: a</span><br><span class="line">coro end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>协程可以身处四个状态中的一个。当前状态可以使用 <code>inspect.getgeneratorstate(...)</code> 函数确定，该函数会返回下述字符串中的一个。<br><code>GEN_CREATED</code> 等待开始执行。<br><code>GEN_RUNNING</code> 解释器正在执行。<br><code>GEN_SUSPENDED</code> 在 yield 表达式处暂停。<br><code>GEN_CLOSED</code> 执行结束。</p><p>因为 <code>send</code> 方法的参数会成为暂停的 <code>yield</code> 表达式的值，所以，仅当协程处于暂停状态时才能调用 <code>send</code> 方法，例如 <code>my_coro.send(42)</code>。不过，如果协程还没激活（即，状态是 <code>GEN_CREATED</code>），情况就不同了。因此，始终要调用 <code>next(my_coro)</code> 激活协程——也可以调用 <code>my_coro.send(None)</code>,如果创建协程对象后立即把 None 之外的值发给它,会抛出<code>TypeError: can&#39;t send non-None value to a just-started generator</code></p><p>最先调用 next(my_coro) 函数这一步通常称为“预激”（prime）协程（即，让协程向前执行到第一个 yield 表达式，准备好作为活跃的协程使用）。</p><p>协程中未处理的异常会向上冒泡，传给 next 函数或 send 方法的调用方（即触发协程的对象）</p><p><code>coro.throw(exc_type[, exc_value[, traceback]])</code><br>致使生成器在暂停的 yield 表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个 yield 表达式，而产出的值会成为调用 generator.throw 方法得到的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。<br><code>coro.close()</code><br>致使生成器在暂停的 yield 表达式处抛出 GeneratorExit 异常。如果生成器没有处理这个异常，或者抛出了 StopIteration 异常（通常是指运行到结尾），调用方不会报错。如果收到 GeneratorExit 异常，生成器一定不能产出值，否则解释器会抛出 RuntimeError 异常。生成器抛出的其他异常会向上冒泡，传给调用方。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestExcept</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_coro</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro begin&#x27;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> TestExcept:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;deal&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;begin&#x27;</span>)</span><br><span class="line">a = simple_coro()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;init coro&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>,<span class="built_in">next</span>(a))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;2&#x27;</span>,a.throw(TestExcept))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;3&#x27;</span>,<span class="built_in">next</span>(a))</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;except e:&#x27;</span>,e.value)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line"><span class="comment">###</span></span><br><span class="line">begin</span><br><span class="line">init coro</span><br><span class="line">coro begin</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line">deal</span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line">coro end</span><br><span class="line"><span class="keyword">except</span> e: <span class="number">10</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>把 <code>TestExcept</code> 异常传入 <code>simple_coro</code> 不会导致协程中止,但是，如果传入协程的异常没有处理，协程会停止，即状态变成 <code>GEN_CLOSED</code>。异常对象的 <code>value</code> 属性保存着返回的值。注意，<code>return</code> 表达式的值会偷偷传给调用方，赋值给 <code>StopIteration</code> 异常的一个属性。这样做有点不合常理，但是能保留生成器对象的常规行为——耗尽时抛出 <code>StopIteration</code> 异常。</p><p>对 <code>yield from</code> 结构来说，解释器不仅会捕获 <code>StopIteration</code> 异常，还会把 <code>value</code> 属性的值变成 <code>yield from</code> 表达式的值</p><p>在生成器 <code>gen</code> 中使用 <code>yield from subgen()</code> 时<code>`subgen</code> 会获得控制权，把产出的值传给 <code>gen</code> 的调用方，即调用方可以直接控制 <code>subgen</code>。与此同时，<code>gen</code> 会阻塞，等待 <code>subgen</code> 终止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">yf_coro</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;end&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_coro</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro begin&#x27;</span>)</span><br><span class="line">    gg = <span class="keyword">yield</span> <span class="keyword">from</span> yf_coro()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;gg&#x27;</span>,gg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;coro end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = simple_coro()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">next</span>(a))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment">###</span></span><br><span class="line">coro begin</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">gg end</span><br><span class="line">coro end</span><br></pre></td></tr></table></figure><p>子生成器可能是简单的迭代器，只实现了 <code>__next__</code> 方法；但是，<code>yield from</code> 也能处理这种子生成器。不过，引入 <code>yield from</code> 结构的目的是为了支持实现了 <code>__next__</code>、<code>send</code>、<code>close</code> 和 <code>throw</code> 方法的生成器。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>channel</title>
      <link href="/p/2734263879.html"/>
      <url>/p/2734263879.html</url>
      
        <content type="html"><![CDATA[<p>使用通信来共享内存,而不是使用共享内存在通信</p><span id="more"></span><ol><li><p>基础</p><p> channel 只能使用 make 生成<br> <code>make(chan type, n int)</code>创建一个缓冲区大小为n的channel,超过n才会阻塞</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//c == nil</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="type">int</span> = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channel</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n := &lt;-c</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 不指明方向默认是双向的,可以指定方向</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="type">int</span> <span class="comment">//只能发送</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span> <span class="comment">//只能接收</span></span><br></pre></td></tr></table></figure></li><li><p>channel 是可以close的<br> <strong>永远是发送方close</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channel</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> n, ok := &lt;-c; ok &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 除了用ok判断是否关闭还可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">channel</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">c &lt;- <span class="number">2</span></span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>select</p><p> 每个case都必须是一个通信</p><p> 所有channel表达式都会被求值</p><p> 所有被发送的表达式都会被求值</p><p> 如果任意某个通信可以进行，它就执行；其他被忽略。</p><p> 如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。</p><p> 否则：</p><blockquote><p>如果有default子句，则执行该语句。<br>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</p></blockquote><ol><li><p>基础</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">c2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">c1 &lt;- <span class="number">1</span></span><br><span class="line">c2 &lt;- <span class="number">2</span></span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">1500</span>)) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">tick := time.Tick(time.Second)</span><br><span class="line">end := time.After(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> n := &lt;-c1:</span><br><span class="line">fmt.Println(<span class="string">&quot;c1:&quot;</span>, n)</span><br><span class="line"><span class="keyword">case</span> n := &lt;-c2:</span><br><span class="line">fmt.Println(<span class="string">&quot;c2:&quot;</span>, n)</span><br><span class="line"><span class="keyword">case</span> t := &lt;-tick:</span><br><span class="line">fmt.Println(<span class="string">&quot;tick: &quot;</span>, t)</span><br><span class="line"><span class="keyword">case</span> &lt;-end:</span><br><span class="line">fmt.Println(<span class="string">&quot;bye&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">c1 -&gt; 1</span></span><br><span class="line"><span class="comment">c2 -&gt; 2</span></span><br><span class="line"><span class="comment">c1 -&gt; 1</span></span><br><span class="line"><span class="comment">c2 -&gt; 2</span></span><br><span class="line"><span class="comment">c1 -&gt; 1</span></span><br><span class="line"><span class="comment">c2 -&gt; 2</span></span><br><span class="line"><span class="comment">tick</span></span><br><span class="line"><span class="comment">c1 -&gt; 1</span></span><br><span class="line"><span class="comment">c2 -&gt; 2</span></span><br><span class="line"><span class="comment">c1 -&gt; 1</span></span><br><span class="line"><span class="comment">c2 -&gt; 2</span></span><br><span class="line"><span class="comment">tick</span></span><br><span class="line"><span class="comment">c1 -&gt; 1</span></span><br><span class="line"><span class="comment">c2 -&gt; 2</span></span><br><span class="line"><span class="comment">c1 -&gt; 1</span></span><br><span class="line"><span class="comment">c2 -&gt; 2</span></span><br><span class="line"><span class="comment">tick</span></span><br><span class="line"><span class="comment">bye</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>time 库</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.After(d Duration) &lt;-<span class="keyword">chan</span> Time <span class="comment">//d时间后发送一个channel</span></span><br><span class="line">time.Tick(d Duration) &lt;-<span class="keyword">chan</span> Time <span class="comment">//每d时间发送一个channel</span></span><br></pre></td></tr></table></figure></li><li><p>传统同步机制</p><p>  使用共享内存来通信</p><p>  WaitGroup</p><p>  Mutex</p><p>  Cond</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> atomicInt <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">mutex sync.Mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *atomicInt)</span></span> increment() &#123;</span><br><span class="line">i.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> i.mutex.Unlock()</span><br><span class="line">i.value++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i *atomicInt)</span></span> get() <span class="type">int</span> &#123;</span><br><span class="line">i.mutex.Lock()</span><br><span class="line"><span class="keyword">defer</span> i.mutex.Unlock()</span><br><span class="line"><span class="keyword">return</span> i.value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := atomicInt&#123;&#125;</span><br><span class="line">fmt.Println(i.get())</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> ii := <span class="number">0</span>; ii &lt; <span class="number">10</span>; ii++ &#123;</span><br><span class="line">i.increment()</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">for</span> ii := <span class="number">0</span>; ii &lt; <span class="number">10</span>; ii++ &#123;</span><br><span class="line">i.increment()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(i.get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>goroutine</title>
      <link href="/p/22695292.html"/>
      <url>/p/22695292.html</url>
      
        <content type="html"><![CDATA[<p><strong>非抢占式多任务</strong></p><p>任何函数前加上 go 即可送给调度器运行<code>go func()</code></p><p>main 函数也是一个goroutine</p><p>调度器在合适的时候进行切换</p><span id="more"></span><p><strong>可能的</strong>切换点:</p><blockquote><p>I/O,select</p><p>channel</p><p>等待锁</p><p>函数调用</p><p>runtime.Gosched()</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello from:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">//a[i]++ 语句是不需要协程切换的,如果不手动释放会一直占用</span></span><br><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">a[i]++</span><br><span class="line">runtime.Gosched()<span class="comment">//释放自己 交出控制权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(a)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文档</title>
      <link href="/p/180082406.html"/>
      <url>/p/180082406.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><code>go doc</code>可以查看文档</p><p><code>godoc -http :6060</code>可以在6060端口开一个go的文档web,可生成自己的项目文档</p><span id="more"></span><ol><li><p>文档书写</p><p> 在对应函数前加上注释</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this is a test doc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>示例代码</p><p> output对应每行的输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExampleXXXX</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//Output:</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试及调优</title>
      <link href="/p/3255085321.html"/>
      <url>/p/3255085321.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ol><li><p>传统测试<br> assert<br> 缺点:</p><blockquote><p>测试数据和逻辑混合在一起<br>出错信息不明确<br>一旦一个数据出错测试全部结束</p></blockquote></li><li><p>表格驱动测试<br> 优点:</p><blockquote><p>分离的测试数据和测试逻辑<br>明确的出错信息<br>可以部分失败</p></blockquote></li><li><p>测试编写<br> 将测试文件和源码放在相同目录下<br> 结果测试函数以Test开头,参数为<em>testing.T,并且不能返回任何值<br> 性能测试函数以Benchmark开头,参数为</em>testing.B,并且不能返回任何值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//func TestXXXX(t *testing.T)&#123;&#125;</span></span><br><span class="line"><span class="comment">//funcs.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//add_test.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAdd</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">a, b, c <span class="type">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>&#125;,</span><br><span class="line">&#123;math.MaxInt64, <span class="number">1</span>, math.MinInt64&#125;,</span><br><span class="line">&#123;math.MaxInt64, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, i := <span class="keyword">range</span> tests &#123;</span><br><span class="line"><span class="keyword">if</span> actual := funcs.Add(i.a, i.b); actual != i.c &#123;</span><br><span class="line">t.Errorf(<span class="string">&quot;%d+%d return: %d realvalue: %d&quot;</span>, i.a, i.b, actual, i.c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9223372036854775807+1 return: -9223372036854775808 realvalue: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">s := Add(math.MaxInt64, <span class="number">1</span>)</span><br><span class="line">ans := math.MinInt64</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> s != ans &#123;</span><br><span class="line">b.Errorf(<span class="string">&quot;%d %d&quot;</span>, s, ans)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">goos: darwin</span></span><br><span class="line"><span class="comment">goarch: amd64</span></span><br><span class="line"><span class="comment">pkg: study/tests/funcs</span></span><br><span class="line"><span class="comment">2000000000         0.66 ns/op</span></span><br><span class="line"><span class="comment">PASS</span></span><br><span class="line"><span class="comment">coverage: 100.0% of statements</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 也可以使用命令行启动测试</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go test .</span><br><span class="line">go test -bench .</span><br><span class="line">go test . -coverprofile c.out #可以生成cover详情文件</span><br></pre></td></tr></table></figure></li><li><p>pprof 性能调优</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go test -bench . -cpuprofile cpu.out #可以生成耗时详情文件</span><br></pre></td></tr></table></figure></li><li><p>go tool</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go tool cover -html c.out #可以以html查看c.out</span><br><span class="line">go tool pprof cpu.out #可以查看耗时详情文件</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>错误处理</title>
      <link href="/p/3252376470.html"/>
      <url>/p/3252376470.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ol><li><p>defer<br> defer 关键字,用于延迟执行一个函数在函数结束前执行<br> 其执行顺序为 <strong>先进后出</strong>，可以理解为栈</p>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="number">4</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//eg:写文件</span></span><br><span class="line">file, err := os.Create(<span class="string">&quot;a.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">writer := bufio.NewWriter(file)</span><br><span class="line"><span class="keyword">defer</span> writer.Flush()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">fmt.Fprintln(writer, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>错误处理</p><ol><li><p>panic</p><p> 停止当前函数执行</p><p> 向上返回,执行每一层的defer</p><p> 如果没有遇到revocer 程序退出</p></li><li><p>recover</p><p>  仅在 defer 中调用</p><p>  获取panic值</p><p>  如果无法处理,可以重新panic</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := <span class="built_in">recover</span>()</span><br><span class="line"><span class="keyword">if</span> err, ok := r.(<span class="type">error</span>); ok &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(fmt.Sprintln(<span class="string">&quot;unknown err:&quot;</span>, r))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"><span class="built_in">panic</span>(errors.New(<span class="string">&quot;this is an error&quot;</span>))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">this is an error</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="number">1234</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">panic: 123 [recovered]</span></span><br><span class="line"><span class="comment">panic: unknown err: 123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>error接口</li></ol></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口</title>
      <link href="/p/1498536549.html"/>
      <url>/p/1498536549.html</url>
      
        <content type="html"><![CDATA[<p>go 采用duck typing 模式<br>实现一个接口是隐式的,只用实现接口对应的方法即可,所以只用使用者定义需要实现的方法即可</p>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type name interface &#123;&#125;</span></span><br><span class="line"><span class="keyword">type</span> Downloader <span class="keyword">interface</span> &#123;</span><br><span class="line">Get(url <span class="type">string</span>) <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SimpleDownload <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl SimpleDownload)</span></span> Get(url <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;this is get &quot;</span> + url</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RealDownload <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dl RealDownload)</span></span> Get(url <span class="type">string</span>) <span class="type">string</span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">ret, err := httputil.DumpResponse(resp, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="type">string</span>(ret)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dl Downloader</span><br><span class="line">dl = interfaces.SimpleDownload&#123;&#125;</span><br><span class="line">dl = interfaces.RealDownload&#123;&#125;</span><br><span class="line">fmt.Println(dl.Get(<span class="string">&quot;http://svz7.cn&quot;</span>))</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口的组合</title>
      <link href="/p/1714105159.html"/>
      <url>/p/1714105159.html</url>
      
        <content type="html"><![CDATA[<p>在接口的声明内包含想要包含的接口即可<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Requests <span class="keyword">interface</span> &#123;</span><br><span class="line">Downloader</span><br><span class="line">Post()</span><br><span class="line">Session()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>常用系统接口</p><ol><li>Stringer</li><li>Reader</li><li>Writer</li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>空接口 interface{}</title>
      <link href="/p/2799208780.html"/>
      <url>/p/2799208780.html</url>
      
        <content type="html"><![CDATA[<p>空接口没有任何方法,所以所有的结构体都实现了空接口<br>空接口可以存储任何类型的值</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Queue []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Push(v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">*q = <span class="built_in">append</span>(*q, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">i := (*q)[<span class="number">0</span>]</span><br><span class="line">*q = (*q)[<span class="number">1</span>:]</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(q *Queue)</span></span> Empty() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(*q) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">q := interfaces.Queue&#123;&#125;</span><br><span class="line">q.Push(<span class="number">1</span>)</span><br><span class="line">q.Push(<span class="literal">true</span>)</span><br><span class="line">q.Push(<span class="string">&quot;str&quot;</span>)</span><br><span class="line">fmt.Println(q.Pop())</span><br><span class="line">fmt.Println(q.Pop())</span><br><span class="line">fmt.Println(q.Empty())</span><br><span class="line">fmt.Println(q.Pop())</span><br><span class="line">fmt.Println(q.Empty())</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">str</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>接口的值的类型</title>
      <link href="/p/473036940.html"/>
      <url>/p/473036940.html</url>
      
        <content type="html"><![CDATA[<p>接口变量内部是存储的类型和值的指针,所以并不用是用接口的指针<br>接口变量也是值传递<br>指针接受者只能以指针方式使用,值接受者都可以</p><span id="more"></span><p>go 中 取接口的类型有两种方式</p><ol><li><p>switch</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inspect</span><span class="params">(dl Downloader)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> v := dl.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *interfaces.SimpleDownload:</span><br><span class="line">fmt.Println(<span class="string">&quot;sim:&quot;</span>, v)</span><br><span class="line"><span class="keyword">case</span> *interfaces.RealDownload:</span><br><span class="line">fmt.Println(<span class="string">&quot;real:&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dl Downloader</span><br><span class="line">dl = &amp;interfaces.SimpleDownload&#123;&#125;</span><br><span class="line">inspect(dl)</span><br><span class="line">dl = &amp;interfaces.RealDownload&#123;&#125;</span><br><span class="line">inspect(dl)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sim: &amp;&#123;&#125;</span></span><br><span class="line"><span class="comment">real: &amp;&#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>一种是type assertion 或者另外一种叫法是 comma-ok</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dl Downloader</span><br><span class="line">dl = &amp;interfaces.SimpleDownload&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> _ ,ok := dl.(*interfaces.SimpleDownload); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;SimpleDownload&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">dl = &amp;interfaces.RealDownload&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> _ ,ok := dl.(*interfaces.RealDownload); ok &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;RealDownload&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">SimpleDownload</span></span><br><span class="line"><span class="comment">RealDownload</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>扩展已有类型 - 继承 组合</title>
      <link href="/p/1870222374.html"/>
      <url>/p/1870222374.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ol><li><p>别名<br> type 不只是定义别名, 而是定义了一个新类型,所以两个类型是不能直接赋值的,要经过转换<br> <em>不会继承原类型的方法</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type newtypename oldtypename</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> name <span class="type">string</span></span><br><span class="line"><span class="keyword">type</span> age <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> n name = <span class="string">&quot;sdf&quot;</span></span><br><span class="line"><span class="keyword">var</span> s <span class="type">string</span> = <span class="string">&quot;wqerwr&quot;</span></span><br><span class="line"><span class="comment">//n = s 会报错</span></span><br><span class="line">fmt.Println(n, s)<span class="comment">//sdf wqerwr</span></span><br><span class="line">n = name(s)</span><br><span class="line">fmt.Println(n, s)<span class="comment">//wqerwr wqerwr</span></span><br></pre></td></tr></table></figure><p> 还有一种是 go1.9 新加入的 类型别名,比原始写法多了个=,这种写法可以继承原类型的方法,不过想扩展原类型<em>必须在一个包内</em></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type newtypename = oldtypename</span></span><br><span class="line"><span class="keyword">type</span> MyTree = Node</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *MyTree)</span></span> FirstTraverse() &#123;</span><br><span class="line"><span class="keyword">if</span> tree == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">tree.Print()</span><br><span class="line"><span class="keyword">if</span> tree.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">left := MyTree(*tree.Left)</span><br><span class="line">left.FirstTraverse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tree.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">right := MyTree(*tree.Right)</span><br><span class="line">right.FirstTraverse()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组合</p><p> 两种写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myTree <span class="keyword">struct</span> &#123;</span><br><span class="line">node *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *myTree)</span></span> lasttraverse()  &#123;</span><br><span class="line"><span class="keyword">if</span> tree.node == <span class="literal">nil</span>&#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">left ,right := &amp;myTree&#123;tree.node.Left&#125;,&amp;myTree&#123;tree.node.Right&#125;</span><br><span class="line">left.lasttraverse()</span><br><span class="line">right.lasttraverse()</span><br><span class="line">tree.node.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 匿名写法</p><p> 可以通过类名来访问匿名成员</p><p> 一个类型的匿名成员只能有一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myTreeComb <span class="keyword">struct</span> &#123;</span><br><span class="line">*structs.Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tree *myTreeComb)</span></span> lastTraverse() &#123;</span><br><span class="line"><span class="keyword">if</span> tree.Node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">left := &amp;myTreeComb&#123;tree.Node.Left&#125;</span><br><span class="line">right := &amp;myTreeComb&#123;tree.Right&#125;</span><br><span class="line">left.lastTraverse()</span><br><span class="line">right.lastTraverse()</span><br><span class="line">tree.Print()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>继承规则:</strong></p><p> 在子类没有改写父类的成员方法时，相应的成员方法被继承。</p><p> 子类可以直接调用父类的成员方法，eg:基类有个成员方法为Base.Func()，那么Derived.Func()等同于Derived.Base.Func()</p><p> 如果子类方法名与父类相同,父类方法被隐藏,可以通过 Derived.Base.Func()显式调用</p><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>包和封装</title>
      <link href="/p/941910722.html"/>
      <url>/p/941910722.html</url>
      
        <content type="html"><![CDATA[<ol><li><p>包</p><p> 每个目录只能有一个包,子目录算另外一个目录<br> main包包含入口文件也就是main函数<br> 给一个结构定义的方法必须放到同一个包(可不同文件)</p></li><li><p>封装</p><p> go 命名一般采用CamelCase<br> go中对包外可见不可见 都由大小写控制<br> 首字母大写为 public 小写为 private</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>结构体和方法</title>
      <link href="/p/2983756538.html"/>
      <url>/p/2983756538.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ol><li><p>基础</p><p>仅支持封装,不支持继承和多态,所以没有class只有struct<br>访问符号为. ,没有-&gt;</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NAME <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line">p :=point&#123;x:<span class="number">1</span>&#125;<span class="comment">//如果只想赋值部分可通过指定名称来赋值</span></span><br><span class="line">p1 := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">p2 := point&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p3 point</span><br><span class="line">fmt.Println(p)<span class="comment">//&#123;1,0&#125;</span></span><br><span class="line">fmt.Println(p1)<span class="comment">//&#123;1,2&#125;</span></span><br><span class="line">fmt.Println(p1.x)<span class="comment">//1</span></span><br><span class="line">fmt.Println(p2)<span class="comment">//&#123;0,0&#125; 不给初值 默认是zeroValue</span></span><br><span class="line">fmt.Println(p3)<span class="comment">//&#123;0,0&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者可以采用new的方式</span></span><br><span class="line">p4 := <span class="built_in">new</span>(point)</span><br><span class="line">fmt.Println(p4)<span class="comment">//&amp;&#123;0,0&#125;</span></span><br><span class="line"></span><br><span class="line">ap := []point&#123;</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,</span><br><span class="line">&#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(ap)<span class="comment">//[&#123;0 0&#125; &#123;1 2&#125; &#123;0 0&#125;]</span></span><br></pre></td></tr></table></figure><p> 没有构造函数,所以可以采用工厂函数的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPoint</span><span class="params">(x, y <span class="type">int</span>)</span></span> point &#123;</span><br><span class="line"><span class="keyword">return</span> point&#123;x,y&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createPointP</span><span class="params">(x, y <span class="type">int</span>)</span></span> *point &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;point&#123;x,y&#125;<span class="comment">//c/c++中这里会出错,因为是一个局部变量的地址,但是go不会,编译时由编译器决定创建在栈上还是堆上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(createPoint(<span class="number">2</span>,<span class="number">3</span>))<span class="comment">//&#123;2 3&#125;</span></span><br><span class="line">fmt.Println(createPointP(<span class="number">3</span>,<span class="number">4</span>))<span class="comment">//&amp;&#123;3 4&#125;</span></span><br></pre></td></tr></table></figure><p> example 二叉树</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">value <span class="type">int</span></span><br><span class="line">left,right *node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   func main() {<br>       root := node{value:3}</p><pre><code>   root.left = &amp;node&#123;value:5&#125;   root.right = new(node)   fmt.Println(root)//&#123;3 0xc42000a080 0xc42000a0a0&#125;</code></pre><p>   }<br>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 方法</span><br><span class="line"></span><br><span class="line">    go的方法并不是定义在struct内部</span><br><span class="line">    其实与函数只是语法上的区别,将参数提到了前面</span><br><span class="line">    值/指针接受者 均可以接受值/指针</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   func (NAME type) funcname(args) returnValue&#123;&#125;</span><br><span class="line">   //因为go都是值传递,所以如果要改变本身需要传递指针</span><br><span class="line">   func (NAME *type) funcname(arts) returnValue&#123;&#125;</span><br><span class="line"></span><br><span class="line">   func (self node) print() &#123;</span><br><span class="line">   self.value=777</span><br><span class="line">   fmt.Println(self.value)</span><br><span class="line">   &#125;</span><br><span class="line">   root := node&#123;value:3&#125;</span><br><span class="line">   root.print()</span><br><span class="line">   fmt.Println(root)</span><br><span class="line">   pRoot := &amp;root</span><br><span class="line">   PRoot.print()</span><br><span class="line">   fmt.Println(root)</span><br><span class="line">   /*</span><br><span class="line">   777</span><br><span class="line">   &#123;3 &lt;nil&gt; &lt;nil&gt;&#125;</span><br><span class="line">   777</span><br><span class="line">   &#123;3 &lt;nil&gt; &lt;nil&gt;&#125;</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">   func (self *node) printC(v int) &#123;</span><br><span class="line">   self.value=v</span><br><span class="line">   fmt.Println(self.value)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   root.printC()//不管是指针还是值,都直接.即可,go会自动处理传递地址</span><br><span class="line">   fmt.Println(root)</span><br><span class="line">   pRoot := &amp;root</span><br><span class="line">   pRoot.printC(666)</span><br><span class="line">   fmt.Println(root)</span><br><span class="line">   /*</span><br><span class="line">   777</span><br><span class="line">   &#123;777 &lt;nil&gt; &lt;nil&gt;&#125;</span><br><span class="line">   666</span><br><span class="line">   &#123;666 &lt;nil&gt; &lt;nil&gt;&#125;</span><br><span class="line">   */</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>    <strong><em>nil指针</em></strong>也能调用方法,所以最好判断一下</p>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *node</span><br><span class="line">p.printC(<span class="number">888</span>)<span class="comment">//!!可以调用,但是在self.value时会报错</span></span><br></pre></td></tr></table></figure><pre><code>example 二叉树 遍历</code></pre>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *node)</span></span> traverse() &#123;</span><br><span class="line"><span class="keyword">if</span> self == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">self.left.traverse()<span class="comment">//其他语言中得判断left是不是为null,go不用,因为nil指针一样可以调用方法</span></span><br><span class="line">self.<span class="built_in">print</span>()</span><br><span class="line">self.right.traverse()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   ​</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内建容器 - map</title>
      <link href="/p/4083513385.html"/>
      <url>/p/4083513385.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ol><li><p>基础<br>和python的dict一样是无序的<br>map使用hash表实现,所以key类型必须可以比较相等<br>除了slice map function 的内建类型都可以作为key<br>Struct 不包括上面的类型就可以作为key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//make(map[kType]vType)</span></span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)<span class="comment">// m == empty map</span></span><br><span class="line">fmt.Println(m)<span class="comment">//map[]</span></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>:<span class="string">&quot;svz&quot;</span>,</span><br><span class="line">    <span class="string">&quot;language&quot;</span>:<span class="string">&quot;go&quot;</span>,<span class="comment">//,不能省略,或者把&#125;提到这里</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(m1)<span class="comment">//map[name:svz]</span></span><br><span class="line"><span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="comment">// m2 == nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问 </span></span><br><span class="line">fmt.Println(m1[<span class="string">&quot;name&quot;</span>])<span class="comment">//svz</span></span><br><span class="line"><span class="comment">//如果访问的key不存在返回的是zeroValue</span></span><br><span class="line">fmt.Println(m1[<span class="string">&quot;names&quot;</span>])<span class="comment">//打印的是空串&quot;&quot;</span></span><br><span class="line"><span class="comment">//可以通过接受ok值判断是否有这个key</span></span><br><span class="line">name, ok := m1[<span class="string">&quot;name&quot;</span>]<span class="comment">//svz true</span></span><br><span class="line">fmt.Println(name, ok)</span><br><span class="line">names, ok := m1[<span class="string">&quot;names&quot;</span>]<span class="comment">// false  注意前面有个空串&quot;&quot;</span></span><br><span class="line">fmt.Println(names, ok)</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 同样可以用 _ 忽略</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1&#123;</span><br><span class="line">fmt.Println(k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name svz</span></span><br><span class="line"><span class="comment">language golang</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 相关函数</span><br><span class="line"></span><br><span class="line">    delete(map,key)</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   fmt.Println(m1)//map[name:123 language:321]</span><br><span class="line">   delete(m1,&quot;name&quot;)</span><br><span class="line">   fmt.Println(m1)//map[language:321]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>   ​</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内建容器 - Slice(切片)</title>
      <link href="/p/1436093335.html"/>
      <url>/p/1436093335.html</url>
      
        <content type="html"><![CDATA[<p>类似python,不过python的是拷贝,go类似于一个view</p><span id="more"></span><ol><li><p>基础</p><p> 类似python,不过python的是拷贝,go类似于一个view</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新建一个slice的方式</span></span><br><span class="line"><span class="comment">//s := []Type&#123;...v&#125;</span></span><br><span class="line"><span class="comment">//s := make([]Type[,len,cap])</span></span><br><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %d %d\n&quot;</span>,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))<span class="comment">//[0 0 0 0 0 0 0 0 0 0] 10 10</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">15</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %d %d\n&quot;</span>,<span class="built_in">len</span>(s2),<span class="built_in">cap</span>(s2))<span class="comment">//[0 0 0 0 0 0 0 0 0 0] 10 15</span></span><br><span class="line"><span class="keyword">var</span> s3 []<span class="type">int</span><span class="comment">//s3 == nil</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %d %d\n&quot;</span>, s3, <span class="built_in">len</span>(s3), <span class="built_in">cap</span>(s3))<span class="comment">//[] 0 0</span></span><br></pre></td></tr></table></figure><p> slice可以向后扩展,不可向前扩展 eg:s6 s7<br> s[]取值不可超过len(s)  向后扩展不可超过cap(s)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">change</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">arr[<span class="number">0</span>]=<span class="number">777</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr1 := [...]<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">s2 := arr1[<span class="number">2</span>:<span class="number">8</span>]</span><br><span class="line">s3 := arr1[:<span class="number">8</span>]</span><br><span class="line">s4 := arr1[<span class="number">2</span>:]</span><br><span class="line">s5 := arr1[:]</span><br><span class="line">s6 := arr1[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">s7 := s6[<span class="number">2</span>:<span class="number">7</span>]</span><br><span class="line"></span><br><span class="line">fmt.Println(arr1)<span class="comment">//[0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">fmt.Println(s2)<span class="comment">//[2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(s3)<span class="comment">//[0 1 2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(s4)<span class="comment">//[2 3 4 5 6 7 8 9]</span></span><br><span class="line">fmt.Println(s4[<span class="number">3</span>:])<span class="comment">//[5 6 7 8 9]</span></span><br><span class="line">fmt.Println(s5)<span class="comment">//[0 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">    fmt.Println(s6)<span class="comment">//[2 3 4]</span></span><br><span class="line">fmt.Println(s7)<span class="comment">//[4 5 6 7 8]</span></span><br><span class="line">change(arr1[:])</span><br><span class="line">fmt.Println(arr1)<span class="comment">//[777 1 2 3 4 5 6 7 8 9]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相关函数</p><ol><li><p>append(slice,…v) slice<br>  slice是引用类型<br>  添加元素时,如果超过cap,会重新分配一个更大的底层数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %d %d\n&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">printSlice(s)</span><br><span class="line">s = <span class="built_in">append</span>(s, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[] 0 0</span></span><br><span class="line"><span class="comment">[0] 1 1</span></span><br><span class="line"><span class="comment">[0 1] 2 2</span></span><br><span class="line"><span class="comment">[0 1 2] 3 4</span></span><br><span class="line"><span class="comment">[0 1 2 3] 4 4</span></span><br><span class="line"><span class="comment">[0 1 2 3 4] 5 8</span></span><br><span class="line"><span class="comment">[0 1 2 3 4 5] 6 8</span></span><br><span class="line"><span class="comment">[0 1 2 3 4 5 6] 7 8</span></span><br><span class="line"><span class="comment">[0 1 2 3 4 5 6 7] 8 8</span></span><br><span class="line"><span class="comment">[0 1 2 3 4 5 6 7 8] 9 16</span></span><br><span class="line"><span class="comment">每次cap扩容都是*2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> <strong>如果是数组中间的切片,append会把后面的元素覆盖</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line">s := a[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %d %d\n&quot;</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))<span class="comment">//[0 1 2 3 4 5 6 7] 8 8</span></span><br><span class="line">printSlice(s)<span class="comment">//[2 3 4] 3 6</span></span><br><span class="line">t := <span class="built_in">append</span>(s,<span class="number">666</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v %d %d\n&quot;</span>, a, <span class="built_in">len</span>(a), <span class="built_in">cap</span>(a))<span class="comment">//[0 1 2 3 4 666 6 7] 8 8</span></span><br><span class="line">printSlice(s)<span class="comment">//[2 3 4] 3 6</span></span><br><span class="line">printSlice(t)<span class="comment">//[2 3 4 666] 4 6</span></span><br></pre></td></tr></table></figure></li><li><p>copy(dst,src) int<br>  把src这个slice中的值拷贝到dst里面去,int返回的是拷贝的值的数量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">s4 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line">s5 :=[]<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">copy</span>(s4,s5))<span class="comment">//6</span></span><br><span class="line">printSlice(s4)<span class="comment">//[0 1 2 3 4 5 0 0 0 0] 10 10</span></span><br><span class="line">printSlice(s5)<span class="comment">//[0 1 2 3 4 5] 6 6</span></span><br><span class="line"></span><br><span class="line">s6 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">4</span>)</span><br><span class="line">s7 :=[]<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">copy</span>(s6,s7))<span class="comment">//4</span></span><br><span class="line">printSlice(s6)<span class="comment">//[0 1 2 3] 4 4</span></span><br><span class="line">printSlice(s7)<span class="comment">//[0 1 2 3 4 5] 6 6</span></span><br></pre></td></tr></table></figure></li><li><p>删除元素 </p><p>  官方没有实现,手动实现一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除中间一段</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delMiddleSlice</span><span class="params">(s []<span class="type">int</span>, start, end <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(s[:start],s[end:]...)<span class="comment">//...可转为可变参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除头尾</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delTrimSlice</span><span class="params">(s []<span class="type">int</span>,start, end <span class="type">int</span>)</span></span> []<span class="type">int</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(s[start:end])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s7 :=[]<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">printSlice(s7)<span class="comment">//[0 1 2 3 4 5] 6 6</span></span><br><span class="line">s7 = delMiddleSlice(s7,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">printSlice(s7)<span class="comment">//[0 1 4 5] 4 6</span></span><br><span class="line">printSlice(delTrimSlice(s7,<span class="number">1</span>,<span class="number">4</span>))<span class="comment">//[1 4 5] 3 5</span></span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内建容器 - 数组</title>
      <link href="/p/3961833544.html"/>
      <url>/p/3961833544.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ol><li><p>基础</p><p> 数组是值类型 [5]int 和 [10]int 是不同类型的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">arr2 := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">arr3 := [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">//[]int&#123;&#125;是切片</span></span><br><span class="line">fmt.Println(arr1)</span><br><span class="line">fmt.Println(arr2)</span><br><span class="line">fmt.Println(arr3)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> grid [<span class="number">4</span>][<span class="number">5</span>]<span class="type">int</span></span><br><span class="line">fmt.Println(grid)</span><br></pre></td></tr></table></figure></li><li><p>range</p><p> 返回两个值,第一个是index 第二个是value</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, v:= <span class="keyword">range</span> arr3&#123;</span><br><span class="line">fmt.Println(i,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v:= <span class="keyword">range</span> arr3&#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组作为参数</p><p> 函数<code>func(arr [10]int)</code>会拷贝数组<br> 函数<code>func(arr *[10]int)</code>是传递的数组指针<br> 函数<code>func(arr []int)</code>会传递切片</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识 - 指针</title>
      <link href="/p/1600255136.html"/>
      <url>/p/1600255136.html</url>
      
        <content type="html"><![CDATA[<p>go是有指针的</p><span id="more"></span><ol><li><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4></li></ol><p>与C/C++类似, 没有指针运算(unsafe除外)</p><ol><li><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p> go中只有值传递 ,没有引用传递的机制,但是可以用指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b *<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">*a,*b = *b,*a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a,b :=<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">swap(&amp;a,&amp;b)</span><br><span class="line">fmt.Println(a,b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//or 这种更优雅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a, b <span class="type">int</span>)</span></span>(<span class="type">int</span>, <span class="type">int</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识 - 函数</title>
      <link href="/p/1571604158.html"/>
      <url>/p/1571604158.html</url>
      
        <content type="html"><![CDATA[<p>go 中函数式一等公民</p><span id="more"></span><ol><li><h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4>函数可以返回多个值 和python类似,函数返回值可以取名并用在函数体中,返回时只用return即可,<strong>仅用于简单函数</strong><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func1</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func2</span><span class="params">(a, b <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func3</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func4</span><span class="params">(a, b <span class="type">int</span>, c <span class="type">string</span>)</span></span> (res <span class="type">int</span>) &#123;</span><br><span class="line">res = a + b</span><br><span class="line">fmt.Println(c)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func5</span><span class="params">(a, b <span class="type">int</span>)</span></span> (add, mul <span class="type">int</span>) &#123;</span><br><span class="line">add = a + b</span><br><span class="line">mul = a - b</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">func6</span><span class="params">(a, b <span class="type">int</span>)</span></span> (<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> add, mul <span class="type">int</span></span><br><span class="line">add = a + b</span><br><span class="line">mul = a - b</span><br><span class="line"><span class="keyword">return</span> add, mul</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常用于返回是否错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">andErr</span><span class="params">()</span></span> (<span class="type">int</span> , <span class="type">error</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>, fmt.Errorf(<span class="string">&quot;err1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="type">int</span>)</span></span>  <span class="type">int</span>&#123;</span><br><span class="line">s := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> numbers&#123;</span><br><span class="line">s+=i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. #### 函数是一等公民</span><br><span class="line"></span><br><span class="line">   ```go</span><br><span class="line">   //函数作为参数</span><br><span class="line">   func apply(op func(int,int) int ,a,b int) int&#123;</span><br><span class="line">   p := reflect.ValueOf(op).Pointer()</span><br><span class="line">   opName := runtime.FuncForPC(p).Name()</span><br><span class="line">   fmt.Println(opName)</span><br><span class="line">   fmt.Printf(&quot;call function %s with args (%d,%d)\n&quot;,opName,a,b)</span><br><span class="line">   return op(a,b)</span><br><span class="line">   &#125;</span><br><span class="line">   func main() &#123;</span><br><span class="line">   apply(func3,1,2)</span><br><span class="line">       //main.func3</span><br><span class="line">   //call function main.func3 with args (1,2)</span><br><span class="line">       //or</span><br><span class="line">       apply(func(i int, i2 int) int &#123;</span><br><span class="line">   return i+i2</span><br><span class="line">   &#125;,1,2)</span><br><span class="line">       //匿名函数第一个就是func1 第二个就是func2 以此类推</span><br><span class="line">       //main.main.func1</span><br><span class="line">   //call function main.main.func1 with args (1,2)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li><p>闭包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(v <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">sum += v</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add := adder()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">9</span>; i++ &#123;</span><br><span class="line">fmt.Println(add(i))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">21</span></span><br><span class="line"><span class="comment">28</span></span><br><span class="line"><span class="comment">36</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识 - 循环语句</title>
      <link href="/p/2802351690.html"/>
      <url>/p/2802351690.html</url>
      
        <content type="html"><![CDATA[<p>go中循环只有for</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToBin</span><span class="params">(n <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">res := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n/=<span class="number">2</span> &#123;</span><br><span class="line">k := n % <span class="number">2</span></span><br><span class="line">res = strconv.Itoa(k) + res</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">convertToBin(<span class="number">5</span>)</span><br><span class="line">convertToBin(<span class="number">14</span>)</span><br><span class="line">convertToBin(<span class="number">123123123</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//101</span></span><br><span class="line"><span class="comment">//1110</span></span><br><span class="line"><span class="comment">//111010101101011010110110011</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于while</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFile</span><span class="params">(filename <span class="type">string</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">if</span> file,err := os.Open(filename);err != <span class="literal">nil</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">scanner :=bufio.NewScanner(file)</span><br><span class="line"><span class="keyword">for</span> scanner.Scan()&#123;</span><br><span class="line">fmt.Println(scanner.Text())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">printFile(<span class="string">&quot;a.txt&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while true</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识 - 控制语句</title>
      <link href="/p/400397322.html"/>
      <url>/p/400397322.html</url>
      
        <content type="html"><![CDATA[<p>if switch</p><span id="more"></span><ol><li><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filename = <span class="string">&quot;a.txt&quot;</span></span><br><span class="line">contents,err :=ioutil.ReadFile(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>,contents)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简写版本</span></span><br><span class="line"><span class="keyword">const</span> filename = <span class="string">&quot;a.txt&quot;</span></span><br><span class="line"><span class="keyword">if</span> contents,err :=ioutil.ReadFile(filename) ; err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>,contents)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只在if 作用域内</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​</p></li><li><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p> switch 默认带上braek 除非显式指定fallthrough</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res <span class="type">int</span></span><br><span class="line"><span class="keyword">switch</span> op &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">res = a+b</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">res = a-b</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">res = a*b</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">res = a/b</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;p&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;undefine opcode:&quot;</span> + op)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res)</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//不携带参数</span></span><br><span class="line"><span class="keyword">var</span> res <span class="type">int</span></span><br><span class="line">flag := rand.Int()</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">res = a + b </span><br><span class="line"><span class="keyword">case</span> flag &gt; <span class="number">10000</span>:</span><br><span class="line">    res = <span class="number">1</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(res)</span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识 - 常量</title>
      <link href="/p/2362245896.html"/>
      <url>/p/2362245896.html</url>
      
        <content type="html"><![CDATA[<p>const 常量,可指出类型or不不显式指类型可以隐式转换类型</p><p>const 枚举  iota 自增符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a <span class="type">int</span> =<span class="number">1</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a = <span class="number">0</span></span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line"></span><br><span class="line">)</span><br><span class="line">fmt.Println(a,b,c,d)</span><br><span class="line"><span class="comment">// 0 0 0 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">a = <span class="literal">iota</span></span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">)</span><br><span class="line">fmt.Println(a,b,c,d)</span><br><span class="line"><span class="comment">//0 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//b kb mb gb tb pb</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">b  = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">kb</span><br><span class="line">mb</span><br><span class="line">gb</span><br><span class="line">tb</span><br><span class="line">pb</span><br><span class="line">)</span><br><span class="line">fmt.Println(b, kb, mb, gb, tb, pb)</span><br><span class="line"><span class="comment">//1 1024 1048576 1073741824 1099511627776 1125899906842624</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识 - 变量声明</title>
      <link href="/p/1254028196.html"/>
      <url>/p/1254028196.html</url>
      
        <content type="html"><![CDATA[<p>go 中变量声明遵从 名字在前 类型在后</p><span id="more"></span><p>两种声明方式 一种使用 var 关键字,声明时赋值的话可以不指定类型,会通过值的类型自动确认</p><p>另外一种是 := 用于赋值声明,同样可以不指定类型</p><p>但是声明后不可改变类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="type">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">a, b := <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line">fmt.Println(a, b)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程与线程</title>
      <link href="/p/4009646367.html"/>
      <url>/p/4009646367.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><ol><li><p>多线程库threading</p><ol><li><p>方法</p><p>Thread(target=func,args=()):创建一个线程对象</p><p>local():创建一个ThreadLocal对象</p><p>active_count():返回当前存活的线程对象的数量；通过计算len(threading.enumerate())长度而来</p><p>current_thread():返回当前线程对象</p><p>enumerate():返回当前存在的所有线程对象的列表</p><p>get_ident():返回线程pid</p><p>main_thread():返回主线程对象，类似 threading.current_thread()；只不过一个是返回当前线程对象，一个是返回主线程对象</p><p>is_alive():是否存活</p></li><li><p>同步</p><p>acquire()/release()：获得/释放 Lock</p></li><li><p>Lock</p><p>多个线程同时acquire时,只能获取一把锁,其他线程等待到获得锁为止</p></li><li><p>可重入锁，也叫做递归锁 RLock </p><p><strong>在需要重复获得锁的情况下（如：递归调用）避免死锁！！！</strong></p><p>多个线程同时acquire时,都可以获得锁,所以acquire,release必须成对</p></li><li><p>Condiftion</p><p>wait():线程挂起，直到收到一个notify通知或者超时（可选的，浮点数，单位是秒s）才会被唤醒继续运行。wait()必须在已获得Lock前提下才能调用，否则会触发RuntimeError。调用wait()会释放Lock，直至该线程被Notify()、NotifyAll()或者超时线程又重新获得Lock.</p><p>notify(n=1):通知其他线程，那些挂起的线程接到这个通知之后会开始运行，默认是通知一个正等待该condition的线程,最多则唤醒n个等待的线程。notify()必须在已获得Lock前提下才能调用，否则会触发RuntimeError。notify()不会主动释放Lock。</p><p>notifyAll():如果wait状态线程比较多，notifyAll的作用就是通知所有线程（这个一般用得少）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3.4</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> threading, time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Seeker</span>(<span class="params">cond, name</span>):</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    cond.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s :我已经把眼睛蒙上了！&#x27;</span>% name)</span><br><span class="line">    cond.notify()</span><br><span class="line">    cond.wait()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is finding!!!&#x27;</span>% name)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">    cond.notify()</span><br><span class="line">    cond.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s :我赢了！&#x27;</span>% name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Hider</span>(<span class="params">cond, name</span>):</span><br><span class="line">    cond.acquire()</span><br><span class="line">    cond.wait()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is hiding!!!&#x27;</span>% name)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s :我已经藏好了，你快来找我吧！&#x27;</span>% name)</span><br><span class="line">    cond.notify()</span><br><span class="line">    cond.wait()</span><br><span class="line">    cond.release()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s :被你找到了，唉~^~!&#x27;</span>% name)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">         cond = threading.Condition()</span><br><span class="line">         seeker = threading.Thread(target=Seeker, args=(cond, <span class="string">&#x27;seeker&#x27;</span>))</span><br><span class="line">         hider = threading.Thread(target=Hider, args=(cond, <span class="string">&#x27;hider&#x27;</span>))</span><br><span class="line">         seeker.start()</span><br><span class="line">         hider.start()</span><br><span class="line">     执行结果：</span><br><span class="line">     seeker :我已经把眼睛蒙上了！</span><br><span class="line">     hider <span class="keyword">is</span> hiding!!!</span><br><span class="line">     hider <span class="keyword">is</span> hiding!!!</span><br><span class="line">     hider :我已经藏好了，你快来找我吧！</span><br><span class="line">     seeker <span class="keyword">is</span> finding!!!</span><br><span class="line">     seeker <span class="keyword">is</span> finding!!!</span><br><span class="line">     seeker <span class="keyword">is</span> finding!!!</span><br><span class="line">     seeker :我赢了！</span><br><span class="line">     hider :被你找到了，唉~^~!</span><br></pre></td></tr></table></figure></li><li><p>Semaphore和BoundedSemaphore</p><p>Semaphore:Semaphore 在内部管理着一个计数器。调用 acquire() 会使这个计数器 -1，release() 则是+1(可以多次release()，所以计数器的值理论上可以无限).计数器的值永远不会小于 0，当计数器到 0 时，再调用 acquire() 就会阻塞，直到其他线程来调用release()</p><p>Bmaphore:类似于Semaphore；不同在于BoundedSemaphore 会检查内部计数器的值，并保证它不会大于初始值，如果超了，就引发一个 ValueError。多数情况下，semaphore 用于守护限制访问（但不限于 1）的资源，如果 semaphore 被 release() 过多次，这意味着存在 bug</p></li></ol></li><li><p>系统交互库subprocess</p><ol><li><p>特性</p><ol><li>多用于调用外部程序</li><li>只通过管道进行文本交流</li></ol></li><li><p>方法</p><p>call()：执行命令，并返回执行状态，其中shell参数为False时，命令需要通过列表的方式传入，当shell为True时，可直接传入命令</p><p>check_call()：用法与subprocess.call()类似，区别是，当返回值不为0时，直接抛出异常</p><p>check_output()：用法与上面两个方法类似，区别是，如果当返回值为0时，直接返回输出结果，如果返回值不为0，直接抛出异常。需要说明的是，该方法在python3.x中才有。</p><p>Popen():在一些复杂场景中，我们需要将一个进程的执行输出作为另一个进程的输入。在另一些场景中，我们需要先进入到某个输入环境，然后再执行一系列的指令等,该方法有以下参数：</p><p>args：shell命令，可以是字符串，或者序列类型，如list,tuple。</p><p>bufsize：缓冲区大小，可不用关心</p><p>stdin,stdout,stderr：分别表示程序的标准输入，标准输出及标准错误</p><p>shell：与上面方法中用法相同</p><p>cwd：用于设置子进程的当前目录</p><p>env：用于指定子进程的环境变量。如果env=None，则默认从父进程继承环境变量</p><p>universal_newlines：不同系统的的换行符不同，当该参数设定为true时，则表示使用\n作为换行符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen([<span class="string">&quot;python&quot;</span>], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">obj.stdin.write(<span class="string">&#x27;print 1 \n&#x27;</span>)</span><br><span class="line">obj.stdin.write(<span class="string">&#x27;print 2 \n&#x27;</span>)</span><br><span class="line">obj.stdin.write(<span class="string">&#x27;print 3 \n&#x27;</span>)</span><br><span class="line">obj.stdin.write(<span class="string">&#x27;print 4 \n&#x27;</span>)</span><br><span class="line">obj.stdin.close()</span><br><span class="line"></span><br><span class="line">cmd_out = obj.stdout.read()</span><br><span class="line">obj.stdout.close()</span><br><span class="line">cmd_error = obj.stderr.read()</span><br><span class="line">obj.stderr.close()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> cmd_out</span><br><span class="line"><span class="built_in">print</span> cmd_error</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将一个子进程的输出，作为另一个子进程的输入：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">child1 = subprocess.Popen([<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;/etc/passwd&quot;</span>], stdout=subprocess.PIPE)</span><br><span class="line">child2 = subprocess.Popen([<span class="string">&quot;grep&quot;</span>,<span class="string">&quot;0:0&quot;</span>],stdin=child1.stdout, stdout=subprocess.PIPE)</span><br><span class="line">out = child2.communicate()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li><li>异步高级封装接口<code>concurrent.futures</code><br> <code>ThreadPoolExecutor</code>,<code>ProcessPoolExecutor</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="keyword">as</span> executor:  </span><br><span class="line">       res = executor.<span class="built_in">map</span>(func, <span class="built_in">iter</span>)</span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">a = executor.submit(funca)</span><br><span class="line">b = executor.submit(funcb)</span><br><span class="line">resa = a.result()</span><br><span class="line">resb = b.result()</span><br></pre></td></tr></table></figure> <code>ProcessPoolExecutor</code>使用方式与<code>ThreadPoolExecutor</code>一样</li><li><p>多进程管理包multiprocessing</p><ol><li>待续</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>multiprocessing库-Pool</title>
      <link href="/p/4029437881.html"/>
      <url>/p/4029437881.html</url>
      
        <content type="html"><![CDATA[<p>关于 Pool 放在类内部无用 or 报错的问题</p><span id="more"></span><p>这是因为多进程之间要使用pickle来序列化并传递一些数据，但是实例方法并不能被pickle,pickle传递给pool的对象的时候，这个对象就包含pool这个实例变量，它不能被pickle，造成错误.<br>解决方法就是自己实现<strong>getstate</strong>方法，它是决定什么需要pickle的函数，我们删除掉pool，不让它pickle就好了。<strong>setstate</strong>作用是相反的，是用来增加实例变量的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing.pool import Pool</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">from multiprocessing import Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()</span><br><span class="line">        self.pool = Pool()</span><br><span class="line">        self.initPool()</span><br><span class="line"></span><br><span class="line">    def test(self, name):</span><br><span class="line">        while True:</span><br><span class="line">            print(name)</span><br><span class="line">            sleep(1)</span><br><span class="line"></span><br><span class="line">    def initPool(self):</span><br><span class="line">        self.pool.map_async(self.test, range(4))</span><br><span class="line">        self.pool.close()</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        self.pool.join()</span><br><span class="line"></span><br><span class="line">    def __getstate__(self):</span><br><span class="line">        self_dict = self.__dict__.copy()</span><br><span class="line">        del self_dict[&#x27;pool&#x27;]</span><br><span class="line">        return self_dict</span><br><span class="line"></span><br><span class="line">    def __setstate__(self, state):</span><br><span class="line">        self.__dict__.update(state)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    a = A()</span><br><span class="line">    a.run()</span><br></pre></td></tr></table></figure><p>子进程异常<br>apply_async返回的是AsyncResult，其中出现的异常只有在调用AsyncResult.get()的时候才会被重新引发</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib库</title>
      <link href="/p/1147879329.html"/>
      <url>/p/1147879329.html</url>
      
        <content type="html"><![CDATA[<p>乱码问题</p><span id="more"></span><p>matplotlib本身只支持ASCII,所以需要更改字体库<br>有几种方法可以解决中文乱码,这里采用更改配置一次到位<br>以下是mac环境,其他环境类似</p><ol><li>查看字体文件注册名字 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib</span><br><span class="line">from matplotlib import font_manager</span><br><span class="line">sorted([f.name for f in matplotlib.font_manager.fontManager.ttflist])</span><br></pre></td></tr></table></figure> 根据list找到对应字体库的注册名字…这里建议找能对应的上的</li><li>把对应字体tff文件拷贝到,matplotlib安装目录下的mpl-data/fonts/tff中</li><li><p>更改mpl-data/matplotlibrc</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#font.family         : sans-serif</span><br><span class="line">#font.style          : normal</span><br><span class="line">#font.variant        : normal</span><br><span class="line">#font.weight         : medium</span><br><span class="line">#font.stretch        : normal</span><br></pre></td></tr></table></figure><p> 改成</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font.family         : 对应的注册名</span><br></pre></td></tr></table></figure><p> 即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>淘宝自动登录</title>
      <link href="/p/2822056666.html"/>
      <url>/p/2822056666.html</url>
      
        <content type="html"><![CDATA[<p>最近帮别人做了一下淘宝客的小工具，总结一下其中碰到的登录的问题</p><span id="more"></span><p>淘宝的登录一直都比较麻烦,有比较特殊的验证方式,所以我选择了用扫码登录这种比较方便的办法(当然是写起来比较方便(≧▽≦)/)</p><ol><li><p>首先打开fiddler抓下登录请求,注意是https,所以得开启ssl模式,然后安装上fiddler的证书</p><ol><li>打开fiddler中的options<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2018/02/3485597889.png" alt="1.png"></li><li>在HTTPS选项中把对应项√上<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2018/02/3132656861.png" alt="2.png"></li><li>选择Actions中Trust Root Certificate</li><li>然后选择Export Root Certificate to Desktop<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2018/02/3037098416.png" alt="3.png"></li><li>打开自己的浏览器将对应证书导入即可</li><li>重启一下浏览器和fiddler</li></ol></li><li><p>然后开始抓包</p><ol><li>打开淘宝的登录页,开始抓包</li><li>可以看到,打开登录页面之后,首先会请求获取二维码的接口,然后会一直请求登录验证接口<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2018/02/3048658957.png" alt="4.png"></li><li>看一下对应的请求情况(这里我只留下对应的一个作为演示)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2018/02/3607852926.png" alt="5.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2018/02/1379534988.png" alt="6.png"></li><li>可以看到获取二维码的接口传入一个对应的from和appkey(这个测试完不传也没啥)即可,对应的from可以自行测试,返回的是二维码的Url链接和一个lgToken值.检测登录的接口传入的则是获取二维码接口得到的lgToken值,defaulturl是对应的默认网址,返回code码.确定的有几种<ul><li>10000 还未扫码</li><li>10001 已经扫描了二维码,在确认登录</li><li>10004 二维码过期了,请重新获取</li><li>10005 请求出错了</li><li>10006 登录成功,并且会返回一个跳转url</li></ul></li></ol></li></ol><ol><li>得到接口后就可以来写测试demo了,这里我用的requests+selenium配合来测试的,requests在登录跳转设置cookie的时候会出问题,selenium下载文件比较麻烦,后续再研究这两问题<ol><li>首先请求二维码获取接口,获得到二维码地址和对应的lgToken.因为没发现对应传参方法,所以只能直接拼接在url后面,selenium获取的page_source是自带了html标签的,所以手动需要提取一下.</li><li>将二维码下载到本地显示出来扫码.</li><li>循环请求登录验证接口 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的函数定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># url拼接参数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fomatUrlParams</span>(<span class="params">url, params</span>):</span><br><span class="line">    t = url + <span class="string">&quot;?&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> params:</span><br><span class="line">        t += <span class="string">f&quot;<span class="subst">&#123;i&#125;</span>=<span class="subst">&#123;params[i]&#125;</span>&amp;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> t[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回值转为dict方便使用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">html_json2dict</span>(<span class="params">page_source</span>):</span><br><span class="line">    bs = BeautifulSoup(page_source, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> json.loads(bs.find(<span class="string">&#x27;pre&#x27;</span>).get_text())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维码保存显示</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_qrcode_img</span>(<span class="params">img_src</span>):</span><br><span class="line">    res = requests.get(img_src, verify=<span class="literal">False</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;qrcode.png&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> imgfile:</span><br><span class="line">        src = res.content</span><br><span class="line">        imgfile.write(src)</span><br><span class="line">    img = Image.<span class="built_in">open</span>(<span class="string">&quot;qrcode.png&quot;</span>)</span><br><span class="line">    img.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    chrome_options = Options()</span><br><span class="line">    <span class="comment"># 下面两行可以开启无界面模式,方便后台运行</span></span><br><span class="line">    <span class="comment"># chrome_options.add_argument(&#x27;--headless&#x27;)</span></span><br><span class="line">    <span class="comment"># chrome_options.add_argument(&#x27;--disable-gpu&#x27;)</span></span><br><span class="line">    chrome = webdriver.Chrome(chrome_options=chrome_options)</span><br><span class="line">    chrome.get(fomatUrlParams(</span><br><span class="line">        <span class="string">&quot;https://qrlogin.taobao.com/qrcodelogin/generateQRCode4Login.do&quot;</span>, &#123;</span><br><span class="line">        <span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;tbTop&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;appkey&#x27;</span>: <span class="string">&#x27;00000000&#x27;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">    data = html_json2dict(chrome.page_source)</span><br><span class="line">    img_url=<span class="string">&quot;http:&quot;</span>+data[<span class="string">&#x27;url&#x27;</span>]</span><br><span class="line">    get_qrcode_img(img_url)</span><br><span class="line">    lgToken=data[<span class="string">&#x27;lgToken&#x27;</span>]</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        chrome.get(fomatUrlParams(</span><br><span class="line">            <span class="string">&quot;https://qrlogin.taobao.com/qrcodelogin/qrcodeLoginCheck.do&quot;</span>, &#123;</span><br><span class="line">            <span class="string">&quot;lgToken&quot;</span>: lgToken,</span><br><span class="line">            <span class="string">&quot;defaulturl&quot;</span>: <span class="string">&#x27;https://www.taobao.com/&#x27;</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">        check_data = html_json2dict(chrome.page_source)</span><br><span class="line">        code = <span class="built_in">int</span>(check_data[<span class="string">&quot;code&quot;</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="number">10000</span> == code:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;请扫描二维码登录&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">10001</span> == code:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已扫描二维码，请在确认登录&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">10004</span> == code:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;已过期请重新扫描&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> <span class="number">10006</span> == code:</span><br><span class="line">            successLoginURL = check_data[<span class="string">&quot;url&quot;</span>]</span><br><span class="line">            chrome.get(successLoginURL)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="number">10005</span> == code:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;请求错误&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;未知错误，退出执行&quot;</span>)</span><br><span class="line">            exit(-<span class="number">1</span>)</span><br><span class="line">        sleep(<span class="number">5</span>) </span><br><span class="line">    chrome.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>登录成功<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2018/02/3506568667.png" alt="7.png"></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> spider </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>centos 搭建nginx+php+mysql</title>
      <link href="/p/1006523276.html"/>
      <url>/p/1006523276.html</url>
      
        <content type="html"><![CDATA[<p>centos 7.2 nginx1.10.2 php mysql5.7</p><span id="more"></span><h1 id="1-安装nginx"><a href="#1-安装nginx" class="headerlink" title="1.安装nginx"></a>1.安装nginx</h1><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;yum install nginx</span><br></pre></td></tr></table></figure><p>设为自启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;chkconfig nginx on</span><br></pre></td></tr></table></figure></p><h1 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2. 安装php"></a>2. 安装php</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;yum install php </span><br><span class="line">&gt;yum install php-mysql php-gd libjpeg* php-imap php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-mcrypt &gt;php-bcmath php-mhash libmcrypt libmcrypt-devel php-fpm</span><br></pre></td></tr></table></figure><p>将php-fpm设为自启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;chkconfig php-fpm on</span><br></pre></td></tr></table></figure></p><h1 id="3-安装mysql"><a href="#3-安装mysql" class="headerlink" title="3.安装mysql"></a>3.安装mysql</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line">&gt;rpm -ivh mysql57-community-release-el7-11.noarch.rpm</span><br><span class="line">&gt;yum install mysql-community-server</span><br></pre></td></tr></table></figure><p>设为自启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;chkconfig mysqld on</span><br></pre></td></tr></table></figure></p><h1 id="4-配置"><a href="#4-配置" class="headerlink" title="4.配置"></a>4.配置</h1><h2 id="1-配置nginx支持php"><a href="#1-配置nginx支持php" class="headerlink" title="1.配置nginx支持php"></a>1.配置nginx支持php</h2><p>vim /etc/nginx/nginx.conf<br>第一行user nginx nginx;<br>location\后再加一个节点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location ~ \.php$ &#123;</span><br><span class="line">   root           html;</span><br><span class="line">   fastcgi_pass   127.0.0.1:9000;</span><br><span class="line">   fastcgi_index  index.php;</span><br><span class="line">   fastcgi_param  SCRIPT_FILENAME   $document_root$fastcgi_script_name;</span><br><span class="line">   include        fastcgi_params;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><br>重新载入配置<br>nginx -s reload </p><h2 id="2-配置php-fpm"><a href="#2-配置php-fpm" class="headerlink" title="2.配置php-fpm"></a>2.配置php-fpm</h2><p>user group改为和nginx一样<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;user  = nginx</span><br><span class="line">&gt;group = nginx</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="5-重启所有服务"><a href="#5-重启所有服务" class="headerlink" title="5.重启所有服务"></a>5.重启所有服务</h1><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;service mysqld restart</span><br><span class="line">&gt;service nginx restart</span><br><span class="line">&gt;service php-fpm restart</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx 配置php 出现Access denied</title>
      <link href="/p/224599295.html"/>
      <url>/p/224599295.html</url>
      
        <content type="html"><![CDATA[<p>将php配置文件中的<br>open_basedir 注释掉即可</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql + amoeba 配置主从 和读写分离</title>
      <link href="/p/2184409172.html"/>
      <url>/p/2184409172.html</url>
      
        <content type="html"><![CDATA[<p>版本：amoeba2.20 JDK1.8</p><span id="more"></span><ol><li><p>首先配置MYSQL的主从</p><ol><li><p>配置Master主服务器</p><ol><li><p>创建slave用户</p><ol><li>在主服务器上新建一个用户slave，给上对应权限,并允许其他slava服务器可以远程访问主服务器<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>; </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li><li><p>找到my.ini,在[mysqld]下添加几行代码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server-id</span>=<span class="number">1</span> <span class="comment">#标识ID，不重复就行，</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin <span class="comment">#slava基于此log-bin做replication</span></span><br><span class="line"><span class="attr">binlog-do-db</span> = test <span class="comment">#指定数据库</span></span><br><span class="line"><span class="attr">binlog-format</span>=MIXED <span class="comment">#指定binlog格式</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>重启mysql服务</li><li>查看日志<br><code>show matser status;</code>  </li><li><p>创建一个新用户amoeba,给上所有权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;amoeba&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>; </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> . <span class="keyword">TO</span> <span class="string">&#x27;amoeba&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>配置Slave从服务器</p><ol><li><p>找到my.ini,在[mysqld]下添加几行代码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server-id</span>=<span class="number">2</span> <span class="comment">#标识ID，不重复就行，</span></span><br><span class="line"><span class="attr">log-bin</span>=mysql-bin <span class="comment">#slava基于此log-bin做replication</span></span><br><span class="line"><span class="attr">relay_log</span>=mysql-relay-bin</span><br><span class="line"><span class="attr">read_only</span>=<span class="number">1</span> <span class="comment">#只读</span></span><br></pre></td></tr></table></figure></li><li><p>重启mysql服务</p></li><li><p>连接Master</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;192.168.1.1&#x27;</span>, <span class="operator">/</span><span class="operator">/</span>Master 服务器Ip</span><br><span class="line">master_port<span class="operator">=</span><span class="number">3306</span>,</span><br><span class="line">master_user<span class="operator">=</span><span class="string">&#x27;slave&#x27;</span>,</span><br><span class="line">master_password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>, </span><br><span class="line">master_log_file<span class="operator">=</span><span class="string">&#x27;master-bin.000001&#x27;</span>,<span class="operator">/</span><span class="operator">/</span>Master服务器产生的日志</span><br><span class="line">master_log_pos<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>启动 Slave<br><code>start slave</code></p></li><li><p>查看Slave状态<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/2645563501.png" alt="1.png"></p><p> Slave_IO_Running: Yes<br> Slave_SQL_Running: Yes<br> 这两个为YES则表示成功</p></li><li><p>创建一个新用户amoeba,给上所有权限,并允许Master服务器访问</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;amoeba&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>; </span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> . <span class="keyword">TO</span> <span class="string">&#x27;amoeba&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>搭建amoeba 实现读写分离</p><ol><li><p>安装JDK环境，并配好环境变量</p></li><li><p>配置amoeba</p><ol><li><p>下载amoeba2.20</p></li><li><p>下载完成后解压，进入bin文件夹，打开命令行<br>显示这样即为成功</p></li><li><p>配置参数<br>进入conf文件夹，修改dbServer.xml和amoeba.xml</p><p>dbServer.xml</p></li></ol></li></ol></li></ol></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/3677788542.png" alt="2.png"></p><p>配置连接所有服务器的帐号密码及各服务器IP</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/405592970.png" alt="3.png"></p><p>配置轮询池</p><p>amoeba.xml</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/434632696.png" alt="5.png"></p><p>配置连接amoeba的帐号密码</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/3234966371.png" alt="6.png"></p><p>配置读写池</p><ol><li><p>测试</p><ol><li><p>开始amoeba</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/3036182717.png" alt="7.png"></p><p>显示这样即为成功</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/2131081568.png" alt="8.png"></p><p>打开mysql命令行连接上amoeba</p><p>注意指定端口为8066</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/1432898767.png" alt="9.png"></p><p>成功</p></li><li><p><em>注：常见错误及解决方法</em></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/08/215735873.png" alt="10.png"></p><p>权限没给齐，或者帐号密码错误，注意，所有的服务器，都得允许主服务器远程访问，并给齐所有权限</p></li></ol><p>​<br>​</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我还是很喜欢你</title>
      <link href="/p/1921127721.html"/>
      <url>/p/1921127721.html</url>
      
        <content type="html"><![CDATA[<p>我还是很喜欢你，像酒曲巷深不及，难掩心迹。<br>我还是很喜欢你，像细雨飘落湖心，廖无声息。<br>我还是很喜欢你，像日光洒满天地，温柔惬意。<br>我还是很喜欢你，像风走了八千里，不问归期。<br>我还是很喜欢你，像雨下到了南极，不远万里。<br>我还是很喜欢你，像日月轮回交替，不理朝夕。<br>我还是很喜欢你，像海浪拥抱礁石，竭尽全力。<br>我还是很喜欢你，像千里戎马单骑，八方为敌。<br>我还是很喜欢你，像珊瑚沉在海底，生死不理。<br>我还是很喜欢你，像星辰砸向大地，不惧成泥。<br>我还是很喜欢你，像孤星伴着落月，不忍相弃。<br>我还是很喜欢你，像鹿隐深林无迹，怯极望极。<br>我还是很喜欢你，像霸王别了虞姬，情非得已。<br>我还是很喜欢你，像红豆心生黯淡，相思成疾。<br>我还是很喜欢你，像寺中青灯古佛，不愿渡己。<br>我还是很喜欢你，像红帐入梦无息，犹恐念及。<br>我还是很喜欢你，像梦里呓语呢喃，全都是你。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AS各种错误总结</title>
      <link href="/p/3389501617.html"/>
      <url>/p/3389501617.html</url>
      
        <content type="html"><![CDATA[<p>针对各种错误的解决方案记录</p><span id="more"></span><ol><li><p>构建gradle卡在Refreshing Gradle Project<br>在项目目录中的<em>gradle\wrapper\gradle-wrapper.properties</em> 中查看gradle版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Mon Jun 05 22:32:46 CST 2017</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip</span><br></pre></td></tr></table></figure><p>手动下载对应版本<a href="http://services.gradle.org/distributions/">gradle库</a>,放在对应用户目录下的<em>.gradle\wrapper\dists\gradle-x.x\xxxxxxxxxx\</em>中,解压<br>重启AS即可</p></li><li><p>Session ‘app’: Error Installing APK<br>File&gt;Setting&gt;Instant Run 去掉第一个复选框Enable Instant Run。。的勾即可</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 新建android工程,gradle报错</title>
      <link href="/p/3123322156.html"/>
      <url>/p/3123322156.html</url>
      
        <content type="html"><![CDATA[<p>错误信息<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Gradle sync failed: The newly created daemon process has a different context than expected.</span><br><span class="line">It won&#x27;t be possible to reconnect to this daemon. Context mismatch: </span><br><span class="line">Java home is different.</span><br><span class="line">Wanted: DefaultDaemonContext[uid=null,javaHome=H:\code\IntelliJ IDEA 2016.3.4\jre,daemonRegistryDir=C:\Users\Administrator\.gradle\daemon,pid=8844,idleTimeout=null,daemonOpts=-Xmx1536m,-Dfile.encoding=GBK,-Duser.country=CN,-Duser.language=zh,-Duser.variant]</span><br><span class="line">Actual: DefaultDaemonContext[uid=2fe606bd-f834-4bcc-a005-e8fd4d5cf5cc,javaHome=C:\Program Files\Java\jdk1.7.0_04,daemonRegistryDir=C:\Users\Administrator\.gradle\daemon,pid=8332,idleTimeout=60000,daemonOpts=-Xmx1536m,-Dfile.encoding=GBK,-Duser.country=CN,-Duser.language=zh,-Duser.variant]</span><br><span class="line">Consult IDE log for more details (Help | Show Log)</span><br></pre></td></tr></table></figure></p><span id="more"></span><p>解决办法:<br>在<em>gradle.properties</em>中加上<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.java.home=C:/Program Files/Java/jdk1.8.0_121</span><br></pre></td></tr></table></figure><br>注意路径分隔符为<em>/</em>,用\仍然报错</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程共享变量</title>
      <link href="/p/1099678226.html"/>
      <url>/p/1099678226.html</url>
      
        <content type="html"><![CDATA[<p>使用multiprocessing库,涉及到进程间共享数据</p><span id="more"></span><p>Manager支持以下类型:<br>list, dict, Namespace, Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Queue, Value and Array.</p><p>1.当使用进程池Pool时,得使用Manager来进行进程池中通信管理<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">arg1,arg2,flag</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> flag.value&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span>(arg1&lt;<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> a:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;os.getpid()&#125;</span>errod:<span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag.value=arg1+arg2</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;os.getpid()&#125;</span>else,&quot;</span>,flag.value)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool=multiprocessing.Pool()</span><br><span class="line">    manager=multiprocessing.Manager()</span><br><span class="line">    flag=manager.Value(<span class="string">&quot;i&quot;</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">        pool.apply_async(test,(i,i+<span class="number">1</span>,flag))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;flag:<span class="subst">&#123;flag.value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><br>2不使用进程池时可以不用Manager类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">arg1,arg2,flag</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> flag.value&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span>(arg1&lt;<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">raise</span> Exception(<span class="string">&quot;xxx&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> a:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;os.getpid()&#125;</span>errod:<span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line">            sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag.value=arg1+arg2</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;os.getpid()&#125;</span>else,&quot;</span>,flag.value)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    flag=multiprocessing.Value(<span class="string">&quot;i&quot;</span>,<span class="number">0</span>)</span><br><span class="line">    ps = [multiprocessing.Process(target=test, args=(x, x+<span class="number">1</span>, flag)) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> ps:</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;flag:<span class="subst">&#123;flag.value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql导入导出sql文件</title>
      <link href="/p/2726329688.html"/>
      <url>/p/2726329688.html</url>
      
        <content type="html"><![CDATA[<p>导出为sql文件<br>mysqldump -u用户名 -p密码 数据库名 [表名] &gt; 导出文件名</p><p>导入sql文件<br>mysql -u用户名 -p密码 数据库名 &lt; 数据库名.sql</p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.NET中Model virtual属性值的修改</title>
      <link href="/p/3784258668.html"/>
      <url>/p/3784258668.html</url>
      
        <content type="html"><![CDATA[<p>如果是直接在页面中修改传参回来会因为类已经改变过所以不能修改</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public ActionResult Edit([Bind(Include = &quot;ID,which&quot;)] DutyTable dutyTable)</span><br><span class="line">&#123;</span><br><span class="line">    if (ModelState.IsValid)</span><br><span class="line">    &#123;</span><br><span class="line">        int soldierID = int.Parse(Request.Form[&quot;soldierID&quot;]);</span><br><span class="line">        Soldier soldier = db.Soldiers.Find(soldierID);</span><br><span class="line">        dutyTable.soldier = soldier;</span><br><span class="line">        db.Entry(dutyTable).State = EntityState.Modified;</span><br><span class="line">        db.SaveChanges();</span><br><span class="line">        return RedirectToAction(&quot;Index&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return RedirectToAction(&quot;Edit&quot;,dutyTable.ID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这么做就会导致更新不了<br>正确做法如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public ActionResult Edit([Bind(Include = &quot;ID,which&quot;)] DutyTable dutyTable)</span><br><span class="line">&#123;</span><br><span class="line">    if (ModelState.IsValid)</span><br><span class="line">    &#123;</span><br><span class="line">        DutyTable d = db.DutyTables.Find(dutyTable.ID);</span><br><span class="line">        int soldierID = int.Parse(Request.Form[&quot;soldierID&quot;]);</span><br><span class="line">        Soldier soldier = db.Soldiers.Find(soldierID);</span><br><span class="line">        d.soldier = soldier;</span><br><span class="line">        db.Entry(d).State = EntityState.Modified;</span><br><span class="line">        db.SaveChanges();</span><br><span class="line">        return RedirectToAction(&quot;DutyTableManager&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return View(dutyTable);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> DotNET </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>将mysql设为utf8编码格式</title>
      <link href="/p/2332468265.html"/>
      <url>/p/2332468265.html</url>
      
        <content type="html"><![CDATA[<p>windows下修改my.ini,linux下修改my.cnf</p><span id="more"></span><p>show variables like ‘character%’;<br>查看编码格式</p><ol><li><p>在[client]下添加default-character-set=utf8</p></li><li><p>在[mysqld]下添加<br>init_connect=’SET collation_connection = utf8_unicode_ci’<br>init_connect=’SET NAMES utf8’<br>character-set-server=utf8<br>collation-server=utf8_unicode_ci<br>skip-character-set-client-handshake</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.NET MVC 数据库 多对多关系存储</title>
      <link href="/p/4004133183.html"/>
      <url>/p/4004133183.html</url>
      
        <content type="html"><![CDATA[<p>直接上代码</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">student.user = (User)Session[&quot;user&quot;];</span><br><span class="line">student.user.admin=3;</span><br><span class="line">db.Entry(student.user).State = EntityState.Modified;</span><br><span class="line">db.Students.Add(student);</span><br><span class="line">db.SaveChanges();</span><br></pre></td></tr></table></figure><p>重点是<em>db.Entry(student.user).State = EntityState.Modified;</em>.注明studen.user为修改<br>不加上的话,下面Add的时候会新建一个同样的user</p>]]></content>
      
      
      <categories>
          
          <category> DotNET </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>.NET 数据库 多对多映射声明</title>
      <link href="/p/1358838427.html"/>
      <url>/p/1358838427.html</url>
      
        <content type="html"><![CDATA[<p>.NET MVC 多对多</p><span id="more"></span><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Address</span> &#123;</span><br><span class="line">    [<span class="meta">Key</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Line1 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Line2 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Line3 &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Customer Customer &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> StoreLocation StoreLocation &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Employee Employee &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>? CustomerId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>? EmployeeId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span> &#123;</span><br><span class="line">    [<span class="meta">Key</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">ICollection</span>&lt;<span class="title">Address</span>&gt; Addresses</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StoreLocation</span> &#123;</span><br><span class="line">    [<span class="meta">Key</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ShortCode &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Description &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> Address Address &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span> &#123;</span><br><span class="line">    [<span class="meta">Key</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime Dob &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="title">ICollection</span>&lt;<span class="title">Address</span>&gt; Addresses</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DBContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ManyOneToManyContext</span> : <span class="title">DbContext</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">ManyOneToManyContext</span>()</span> &#123;</span><br><span class="line">        Database.SetInitializer&lt;ManyOneToManyContext&gt;(<span class="keyword">new</span> ManyOneToManyInitializer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Address</span>&gt; Addresses</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Customer</span>&gt; Customers</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">StoreLocation</span>&gt; StoreLocations</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DbSet</span>&lt;<span class="title">Employee</span>&gt; Employees</span> &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnModelCreating</span>(<span class="params">DbModelBuilder modelBuilder</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">        modelBuilder.Conventions.Remove&lt;IncludeMetadataConvention&gt;();</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;Customer&gt;().HasMany(c =&gt; c.Addresses).WithOptional(a =&gt; a.Customer).HasForeignKey(a =&gt; a.CustomerId);</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;StoreLocation&gt;().HasRequired(s =&gt; s.Address).WithOptional(a =&gt; a.StoreLocation).Map(t =&gt; t.MapKey(<span class="string">&quot;AddressId&quot;</span>));</span><br><span class="line"></span><br><span class="line">        modelBuilder.Entity&lt;Employee&gt;().HasMany(e =&gt; e.Addresses).WithOptional(a =&gt; a.Employee).HasForeignKey(e =&gt; e.EmployeeId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//init</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ManyOneToManyInitializer</span> : <span class="title">DropCreateDatabaseAlways</span>&lt;<span class="title">ManyOneToManyContext</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Seed</span>(<span class="params">ManyOneToManyContext context</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DotNET </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>删除 IIS部署网站本地文件</title>
      <link href="/p/1707586025.html"/>
      <url>/p/1707586025.html</url>
      
        <content type="html"><![CDATA[<p>启动cmd<br>进入<em>C:\Windows\System32\inetsrv</em><br>运行<em>appcmd.exe /?</em> 有详细命令</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 搭建 SSH框架</title>
      <link href="/p/1072021944.html"/>
      <url>/p/1072021944.html</url>
      
        <content type="html"><![CDATA[<p>折腾了一天之后,终于把SSH框架给搭好了,期间换了N个版本(ಥ _ ಥ)<br>Spring4.3.7 Struts2.3.20.1 Hibernate5.2.3</p><span id="more"></span><p>下面来讲讲本人的步骤</p><ol><li>我们用IDEA直接新建一个Spring工程<br>注意得选上MVC,因为web包在MVC模块中,单纯的直选Spring模块是没有web包的….这个折腾了N久〒▽〒,同样的选上Struts2和Hibernate模块,然后等待自动下载完成,这个时间视网络而定,如果下载失败就try again吧~~<br>这里我们可以选择只下载web模块<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/3473999402.png" alt="1.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/2562024283.png" alt="2.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/1943668766.png" alt="7.png"></li><li>因为IDEA下的模块或多或少会有一些残缺,所以残缺的这一块就只能自己去找啦..,IDEA下载的Struts2模块是2.3.10版本的,所以我们去下一个2.3.10的完整包,然后在lib中将<em>struts2-spring-plugin-2.3.20.1</em>包给拷贝到工程的lib中去,然后数据库连接<em>Mysql-jdbc</em>包,并在Project Structure中Libraries中加上依赖项<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/3715287336.png" alt="3.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/4162423395.png" alt="4.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/3260908704.png" alt="8.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/2427637302.png" alt="13.png"></li><li>在Artifacts选项中在右边右键所有的Lib包,加入到/WEB-INF/lib中<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/2562208996.png" alt="5.png"></li><li>在Facets中各点一下Spring和Struts 2选项,IDEA会自动载入对应的配置,然后OK即可<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/2768127572.png" alt="6.png"><br>注:如果只选了web模块的话,在WEB-INF下新建一个<em>applicationContext.xml</em>文件,再到Facets去配置<br>注:如果只选了web模块的话,在<em>web.xml</em>中加上Spring的配置<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>在启动配置中,配置Tomcat<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/3303242193.png" alt="9.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/2103466106.png" alt="10.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/2400793824.png" alt="11.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/03/1072808115.png" alt="12.png"></li><li>可以撸一段代码试试啦~</li></ol><p><strong>注:环境为JDK1.8,JDK1.7会报错</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>验证代理是否可用</title>
      <link href="/p/2647504717.html"/>
      <url>/p/2647504717.html</url>
      
        <content type="html"><![CDATA[<p>从代理网上获取代理IP之后,还得查看代理是否可用.有两种方法进行测试</p><span id="more"></span><ol><li>利用requests库挂上代理访问网站,监测是否访问成功<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">proxies=&#123;</span><br><span class="line">    &quot;http&quot;:&quot;http://185.44.15.228:3130&quot;,</span><br><span class="line">    &quot;https&quot;:&quot;http://185.44.15.228:3130&quot;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    requests.get(&#x27;http://www.baidu.com&#x27;, proxies=proxies)</span><br><span class="line">except:</span><br><span class="line">    print(&#x27;failed&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;success&#x27;)</span><br></pre></td></tr></table></figure></li><li>利用telnetlib库对代理ip进行测试,监测是否成功<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import telnetlib</span><br><span class="line">try:</span><br><span class="line">    tel=telnetlib.Telnet(&#x27;121.199.25.64&#x27;,port=&#x27;80&#x27;,timeout=10)</span><br><span class="line">except:</span><br><span class="line">    print(&#x27;failed&#x27;)</span><br><span class="line">else:</span><br><span class="line">    print(&#x27;success&#x27;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> spider </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>template库</title>
      <link href="/p/1155499293.html"/>
      <url>/p/1155499293.html</url>
      
        <content type="html"><![CDATA[<p><em>text/template和html/template</em>等模板包提供了一个将变量值填充到一个文本或HTML格式的模板的机制。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const templ = `&#123;&#123;.Year&#125;&#125; &#123;&#123;.Month&#125;&#125; &#123;&#123;.Day&#125;&#125; :</span><br><span class="line">---------------------&#123;&#123;.Safe_title | Function&#125;&#125;------------------------</span><br><span class="line">&#123;&#123;.Img&#125;&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure><p>对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”。当前值“.”最初被初始化为调用模板是的参数,|操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念<br>注意方法调用链的顺序：template.New先创建并返回一个模板；Funcs方法将自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func Test(title string) string&#123;</span><br><span class="line">return fmt.Sprintf(&quot;%s&quot;,title)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tmpl, err := template.New(&quot;templateName&quot;).Funcs(template.FuncMap&#123;&quot;Function&quot;:Test&#125;).Parse(templ)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line">tmpl, err := template.ParseFiles(&quot;templ.txt&quot;)  //建立一个模板，这里不需要new(&quot;name&quot;)的方式，因为name自动为文件名</span><br></pre></td></tr></table></figure><br>执行模板<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err = tmpl.ExecuteTemplate(os.Stdout, &quot;test&quot;, result)  //指定模板名，这次为test</span><br><span class="line">err = tmpl.Execute(os.Stdout, result)  //模板名省略，打印的是当前模板</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>json库</title>
      <link href="/p/662848913.html"/>
      <url>/p/662848913.html</url>
      
        <content type="html"><![CDATA[<p>Go的标准库<em>encoding/json、encoding/xml、encoding/asn1</em>对标准格式解码编码提供支持</p><span id="more"></span><p>一个JSON数组可以用于编码Go语言的数组和slice。<br>一个JSON对象是一个字符串到值的映射，写成以系列的name:value对形式，用花括号包含并以逗号分隔；<br>JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体<br>定义与JSON对应的结构体<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Info struct&#123;</span><br><span class="line">    Key T `json:&quot;jsonName&quot;`</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong><em>首字母大写</em></strong><br>允许嵌套<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">type User struct&#123;</span><br><span class="line">    Name string</span><br><span class="line">    Age int</span><br><span class="line">&#125;</span><br><span class="line">type Info struct&#123;</span><br><span class="line">    Key T `json:&quot;jsonName&quot;`</span><br><span class="line">    User *User</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>利用JSON中Decoder将输出流JSON解码转为Go中结构.Decode方法填充变量<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var result Info</span><br><span class="line">json.NewDecoder(resp.Body).Decode(&amp;result);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>centos 中文乱码</title>
      <link href="/p/2841973617.html"/>
      <url>/p/2841973617.html</url>
      
        <content type="html"><![CDATA[<p>在/etc/locale.conf中将<em>LANG=”C”</em>改为<em>LANG=”zh_CN.utf8”</em><br>在/etc/profile加上<em>export LC_ALL=”zh_CN.utf8”</em></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些常用语句</title>
      <link href="/p/3088716556.html"/>
      <url>/p/3088716556.html</url>
      
        <content type="html"><![CDATA[<p>查询数据库所有表<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = &#x27;数据库名&#x27;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vs2013 Qt5 静态编译</title>
      <link href="/p/722032407.html"/>
      <url>/p/722032407.html</url>
      
        <content type="html"><![CDATA[<p>这两玩意儿搞到一起日常各种报错,整理一下</p><span id="more"></span><ol><li>RuntimeLibraty不匹配:<br>项目属性-&gt;C/C++-&gt;代码生成-&gt;运行库选择为对应的.</li><li>附加库目录得加上<br><em>$(QTDIR)\plugins\platforms</em></li><li>附加依赖项得加上<br>qwindows.lib<br>Qt5PlatformSupport.lib</li><li>main.cpp中加上<h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <QtPlugin></h1>Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin);</li><li>openGL还得加上<br>opengl32.lib<br>glu32.lib</li></ol>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ASP.NET MVC 如何解决“上下文的模型已在数据库创建后发生更改”问题</title>
      <link href="/p/1275399438.html"/>
      <url>/p/1275399438.html</url>
      
        <content type="html"><![CDATA[<p>MVC会捕捉数据库的更改，并且自动的在数据库生成监视上下文模型发生改动的表，只需将其删除即可</p><span id="more"></span><p>定位到所用的数据库-表-系统表，删除“_MigrationXXX”开头的表，重新生成即可正常运行。​</p><p>或者更新一下Migration<br>操作流程：</p><p>步骤1： add-migration XXXXXXX</p><p>步骤2：update-database -script</p><p>步骤3： update-database</p>]]></content>
      
      
      <categories>
          
          <category> DotNET </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>定位属性position</title>
      <link href="/p/2287998450.html"/>
      <url>/p/2287998450.html</url>
      
        <content type="html"><![CDATA[<p>position属性说明</p><span id="more"></span><ol><li><p>absolute ：绝对定位；脱离文档流的布局，遗留下来的空间由后面的元素填充。定位的起始位置为最近的父元素(postion不为static)，否则为Body文档本身。</p></li><li><p>relative ：相对定位；不脱离文档流的布局，只改变自身的位置，在文档流原先的位置遗留空白区域。定位的起始位置为此元素原先在文档流的位置。</p></li><li><p>fixed ：固定定位；类似于absolute，以浏览器窗口作为参照</p></li><li><p>static ：默认值；默认布局。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前后台任务切换</title>
      <link href="/p/744132434.html"/>
      <url>/p/744132434.html</url>
      
        <content type="html"><![CDATA[<p>因为用服务器挂爬虫程序的时候前台开启的,但是要关电脑了还没有爬完,断开连接后任务就断了,所以需要前后台转换了</p><span id="more"></span><p>断开连接任务仍旧执行,执行命令时得用nohup指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#nohup python3 main.py &gt;log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><ol><li>&amp; 最经常被用到<br>这个用在一个命令的最后，可以把这个命令放到后台执行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#python3 main.py &amp;</span><br></pre></td></tr></table></figure></li></ol><ol><li>ctrl + z<br>　　可以将当前任务停止并放到后台</li></ol><ol><li>jobs<br>　　查看当前有多少在后台运行的命令</li></ol><ol><li>fg<br>　　将后台中的命令调至前台继续运行<br>　　如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)。</li></ol><ol><li>bg<br>　　将一个在后台暂停的命令，变成继续执行<br>　　如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)。</li></ol><p>比如我现在的爬虫程序运行到一半,然后按下ctrl+z 可以看到系统提示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1]+  Stopped                 python3 main.py</span><br></pre></td></tr></table></figure><br>然后把程序调度到后台执行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#bg 1</span><br></pre></td></tr></table></figure><br>调回前台的话<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#fg 1</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库用户处理</title>
      <link href="/p/3122813339.html"/>
      <url>/p/3122813339.html</url>
      
        <content type="html"><![CDATA[<p>mysql设置用户的一些命令</p><span id="more"></span><p>一, 创建用户: </p><p>命令:<strong>CREATE USER ‘username’@’host’ IDENTIFIED BY ‘password’; </strong></p><p>说明:username - 你将创建的用户名, host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%. password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器. </p><p>例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;dog&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;; </span><br><span class="line">CREATE USER &#x27;pig&#x27;@&#x27;192.168.1.101_&#x27; IDENDIFIED BY &#x27;123456&#x27;; </span><br><span class="line">CREATE USER &#x27;pig&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;; </span><br><span class="line">CREATE USER &#x27;pig&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;&#x27;; </span><br><span class="line">CREATE USER &#x27;pig&#x27;@&#x27;%&#x27;; </span><br><span class="line">若果想把现有的账号设置成任意远程主机登录,比如 root</span><br><span class="line">use mysql;</span><br><span class="line">update user set host = &#x27;%&#x27; where user =&#x27;root&#x27;; </span><br></pre></td></tr></table></figure></p><p>二,授权: </p><p>命令:<strong>GRANT privileges ON databasename.tablename TO ‘username’@’host’</strong></p><p>说明: privileges - 用户的操作权限,如SELECT , INSERT , UPDATE 等(详细列表见该文最后面).如果要授予所的权限则使用ALL.;databasename - 数据库名,tablename-表名,如果要授予该用户对所有数据库和表的相应操作权限则可用<em>表示, 如</em>.*. </p><p>例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT SELECT, INSERT ON test.user TO &#x27;pig&#x27;@&#x27;%&#x27;; </span><br><span class="line">GRANT ALL ON *.* TO &#x27;pig&#x27;@&#x27;%&#x27;; </span><br></pre></td></tr></table></figure></p><p>注意:用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:<br><strong>GRANT privileges ON databasename.tablename TO ‘username’@’host’ WITH GRANT OPTION;</strong></p><p>三.设置与更改用户密码 </p><p>命令:<strong>SET PASSWORD FOR ‘username’@’host’ = PASSWORD(‘newpassword’);</strong>如果是当前登陆用户用<strong>SET PASSWORD = PASSWORD(“newpassword”);</strong></p><p>例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR &#x27;pig&#x27;@&#x27;%&#x27; = PASSWORD(&quot;123456&quot;); </span><br></pre></td></tr></table></figure></p><p>四.撤销用户权限 </p><p>命令: <strong>REVOKE privilege ON databasename.tablename FROM ‘username’@’host’;</strong></p><p>说明: privilege, databasename, tablename - 同授权部分. </p><p>例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE SELECT ON *.* FROM &#x27;pig&#x27;@&#x27;%&#x27;; </span><br></pre></td></tr></table></figure><br>注意: 假如你在给用户’pig’@’%’授权的时候是这样的(或类似的):<strong>GRANT SELECT ON test.user TO ‘pig’@’%’</strong>, 则在使用<strong>REVOKE SELECT ON <em>.</em> FROM ‘pig’@’%’;</strong>命令并不能撤销该用户对test数据库中user表的SELECT 操作.相反,如果授权使用的是<strong>GRANT SELECT ON <em>.</em> TO ‘pig’@’%’;</strong>则<strong>REVOKE SELECT ON test.user FROM ‘pig’@’%’;</strong>命令也不能撤销该用户对test数据库中user表的Select 权限. </p><p>具体信息可以用命令<strong>SHOW GRANTS FOR ‘pig’@’%’;</strong>查看. </p><p>五.删除用户 </p><p>命令: <strong>DROP USER ‘username’@’host’;</strong></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typecho 归档页面</title>
      <link href="/p/1559953069.html"/>
      <url>/p/1559953069.html</url>
      
        <content type="html"><![CDATA[<p>直接用<strong>Widget_Contents_Post_Recent</strong>来查找所有的文章,然后对文章进行分批显示即可</p><span id="more"></span><p>1.首先在主题根目录下建立一个自定义模板<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">/**</span><br><span class="line"> * dateTree</span><br><span class="line"> *</span><br><span class="line"> * @package custom</span><br><span class="line"> * Created by IntelliJ IDEA.</span><br><span class="line"> * User: SVz7</span><br><span class="line"> * Date: 2017/2/6</span><br><span class="line"> * Time: 1:05</span><br><span class="line"> */</span><br><span class="line">if (!defined(&#x27;__TYPECHO_ROOT_DIR__&#x27;)) exit; ?&gt;</span><br><span class="line">&lt;?php $this-&gt;need(&#x27;inc/header.php&#x27;); ?&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;col-mb-12 col-12&quot; id=&quot;main&quot; role=&quot;main&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;datetree&quot; style=&quot;padding-top: 15px&quot;&gt;</span><br><span class="line">        &lt;?php $this-&gt;widget(&#x27;Widget_Contents_Post_Recent&#x27;, &#x27;pageSize=10000&#x27;)-&gt;to($arc);</span><br><span class="line">        $date=0;</span><br><span class="line">        while($arc-&gt;next()):</span><br><span class="line">            $date_tmp = date(&#x27;Y m&#x27;,$arc-&gt;created);</span><br><span class="line">            if ($date != $date_tmp &amp;&amp; $date &gt; 0) $output .= &#x27;&lt;/ul&gt;&lt;/div&gt;&#x27;;</span><br><span class="line">            if ($date != $date_tmp) &#123;</span><br><span class="line">                $date = $date_tmp;</span><br><span class="line">                $output .= &#x27;&lt;div class=&quot;widget&quot;&gt;&#x27;;</span><br><span class="line">                $output .= &#x27;&lt;h3 style=&quot;text-align: center&quot;&gt;&#x27;. $date .&#x27; &lt;/h3&gt;&#x27;;</span><br><span class="line">                $output .= &#x27;&lt;ul&gt;&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">            $output .= &#x27;&lt;li&gt;&#x27;.date(&#x27;m/d&#x27;,$arc-&gt;created).&#x27;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;a href=&quot;&#x27;.$arc-&gt;permalink .&#x27;&quot;&gt;&#x27;. $arc-&gt;title .&#x27;&lt;/a&gt;&lt;/li&gt;&#x27;;</span><br><span class="line">        endwhile;</span><br><span class="line">        $output .= &#x27;&lt;/ul&gt;&#x27;;</span><br><span class="line">        $output .= &#x27;&lt;/div&gt;&#x27;;</span><br><span class="line">        echo $output;</span><br><span class="line">        ?&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;&lt;!-- end #main--&gt;</span><br><span class="line"></span><br><span class="line">&lt;?php $this-&gt;need(&#x27;inc/footer.php&#x27;); ?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><strong>$date_tmp的格式对应归档方式,如以年份归档的话</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$date_tmp = date(&#x27;Y&#x27;,$arc-&gt;created);</span><br></pre></td></tr></table></figure><br>2.然后新建一个静态页面,模板选对应的自定义模板即可</p>]]></content>
      
      
      <categories>
          
          <category> Typecho </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Google AdSense</title>
      <link href="/p/2733490559.html"/>
      <url>/p/2733490559.html</url>
      
        <content type="html"><![CDATA[<p>折腾了3天之后,终于给我挂上广告了….不容易啊…</p><span id="more"></span><p>1.<a href="www.google.com/adsense">Google AdSense</a>注册开通<br>2.等待1天左右,邮箱内会有通知<br>3.设置中我的网页里加上自己的网站<br>4.在其他广告下开启内容广告<br>5.刷新一下页面<br>6.选择网页级广告,两个选项都打开,获取代码插入自己的页面之中<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/3009167260.png" alt="3.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/3307521518.png" alt="4.png"><br>7.选择测试看看有没有插入好<br>8.选择内容广告-&gt;广告单元-&gt;新建广告单元,根据自己的需求来设置-&gt;保存并获取代码,然后插入自己的页面之中<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/1999504366.png" alt="1.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/2207025125.png" alt="2.png"><br>9.over</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>requests库-常用设置选项</title>
      <link href="/p/2544864828.html"/>
      <url>/p/2544864828.html</url>
      
        <content type="html"><![CDATA[<p>最近写一个sina爬虫,然后爬了半天之后访问不上给我封掉了-.-,于是加上代理功能</p><span id="more"></span><ol><li>代理</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxies=&#123;</span><br><span class="line">    &#x27;http&#x27;: &#x27;http://127.0.0.1:8087&#x27;,</span><br><span class="line">    &#x27;https&#x27;: &#x27;http://127.0.0.1:8087&#x27;,</span><br><span class="line">&#125;</span><br><span class="line">requests.get(url,timeout=60,proxies=proxies)</span><br></pre></td></tr></table></figure><ol><li>证书</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认开启</span><br><span class="line">requests.get(url, verify=False)</span><br><span class="line">requests.get(&#x27;https://github.com&#x27;, verify=&#x27;certfile&#x27;)</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">s.verify = &#x27;certfile&#x27;</span><br></pre></td></tr></table></figure><ol><li>重定向<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response = request.get(url, allow_redirects=False)</span><br></pre></td></tr></table></figure></li><li>请求头<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.headers.update(dict)</span><br><span class="line"></span><br><span class="line">requests.get(url,headers=dict)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串分割与拼接</title>
      <link href="/p/3857124686.html"/>
      <url>/p/3857124686.html</url>
      
        <content type="html"><![CDATA[<p>python中对字符串进行分割或拼接处理用到string.split和string.join</p><span id="more"></span><p>string.split(str=’ ‘,num=string.count(str)):　　以str为分隔，符切片string，如果num有指定值，则仅分隔num个子字符串。<br>string.join(sep):　　以string作为分割符，将sep中所有的元素(字符串表示)合并成一个新的字符串。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 譬如对url参数进行分割处理</span><br><span class="line">data=&#x27;a=6&amp;b=7&amp;c=8&#x27;</span><br><span class="line">datas=data.split(&#x27;&amp;&#x27;)</span><br><span class="line">print(datas)</span><br><span class="line"># [&#x27;a=6&#x27;, &#x27;b=7&#x27;, &#x27;c=8&#x27;]</span><br><span class="line"># 将其拼接为一个字符串</span><br><span class="line">print(&#x27;&amp;&#x27;.join()</span><br><span class="line"># a=6&amp;b=7&amp;c=8</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux下aapt使用不了的问题</title>
      <link href="/p/811864738.html"/>
      <url>/p/811864738.html</url>
      
        <content type="html"><![CDATA[<p>执行aapt报错<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><br><span id="more"></span></p><p>支持库没有安装的问题.<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-multilib lib32z1 lib32stdc++6</span><br></pre></td></tr></table></figure><br>安装这3个库之后即可使用</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pip安装python库</title>
      <link href="/p/2139320329.html"/>
      <url>/p/2139320329.html</url>
      
        <content type="html"><![CDATA[<p>国内pip访问比较慢,所以切成国内的源会比较快</p><span id="more"></span><p>linux下~/.pip/pip.config(windows下则是pip\pip.ini)<br>在文件中加上<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span>  </span><br><span class="line"><span class="attr">index-url</span>=http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure><br>即可<br>附上源列表</p><ol><li><a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></li><li><a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a></li><li><a href="http://e.pypi.Python.org/simple">http://e.pypi.Python.org/simple</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>边框阴影 box-shadow</title>
      <link href="/p/2895702912.html"/>
      <url>/p/2895702912.html</url>
      
        <content type="html"><![CDATA[<p>box-shadow是向元素添加阴影.</p><span id="more"></span><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: X轴偏移量 Y轴偏移量 [阴影模糊半径] [阴影扩展半径] [阴影颜色] [投影方式];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 参数介绍</span></span><br><span class="line"><span class="comment">* X轴偏移量    水平阴影的位置 负数代表反方向</span></span><br><span class="line"><span class="comment">* Y轴偏移量    垂直阴影的位置 负数代表反方向</span></span><br><span class="line"><span class="comment">* 阴影模糊半径 只能是为正值，如果为0时，表示阴影不具有模糊效果，</span></span><br><span class="line"><span class="comment">* 阴影扩展半径 可正可负，如果值为正，则整个阴影都延展扩大，反之值为负值时，则缩小；</span></span><br><span class="line"><span class="comment">* 阴影颜色     默认为黑色</span></span><br><span class="line"><span class="comment">* 投影方式     默认为外部阴影,inset为内部阴影</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>inset写在最后,不然无效</strong><br><strong>X,Y轴偏移量都为0表示从四周产生阴影</strong><br>外阴影<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="number">5px</span> <span class="number">10px</span> <span class="number">6px</span> <span class="number">#333333</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/239958053.png" alt="2_1.png"></p><p>内阴影<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="number">5px</span> <span class="number">10px</span> <span class="number">6px</span> <span class="number">#333333</span> inset; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/3442318146.png" alt="2_2.png"></p><p>加多个阴影,用逗号,隔开即可<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>:<span class="number">5px</span> <span class="number">10px</span> <span class="number">6px</span>  <span class="number">#f00</span>, <span class="number">5px</span> <span class="number">10px</span> <span class="number">6px</span>  <span class="number">#0f0</span>, <span class="number">0px</span> <span class="number">0px</span> <span class="number">1px</span> <span class="number">5px</span> <span class="number">#00f</span> inset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/131806839.png" alt="2_3.png"></p>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>改变选中文字颜色及背景色</title>
      <link href="/p/2078286707.html"/>
      <url>/p/2078286707.html</url>
      
        <content type="html"><![CDATA[<p>使用::selection选择器即可</p><span id="more"></span><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::selection</span>&#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">68</span>, <span class="number">68</span>, <span class="number">68</span>, <span class="number">0.8</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#bdc9d5</span>;</span><br><span class="line">&#125;</span><br><span class="line">::-moz-selection &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">68</span>, <span class="number">68</span>, <span class="number">68</span>, <span class="number">0.8</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#bdc9d5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*两个不能写在一起用,隔开,我也不知道为啥*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>http转为https</title>
      <link href="/p/1145805404.html"/>
      <url>/p/1145805404.html</url>
      
        <content type="html"><![CDATA[<p>折腾了一下午,终于把blog挂上了小绿锁,折腾死了</p><span id="more"></span><p>本博客环境为apache2搭建的,网上大多为apache,所以资料查起来还是挺麻烦的,下面附上小绿锁过程<br>1.开启ssl<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod ssl</span><br></pre></td></tr></table></figure><br>2.将sites-available/default-ssl.conf 链接到sites-enabled/中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/apache2/sites-enabled/</span><br><span class="line">ln -s ../sites-available/default-ssl.conf default-ssl.conf</span><br><span class="line">vim default-ssl.conf //配置网站信息</span><br><span class="line">    &lt;IfModule mod_ssl.c&gt;</span><br><span class="line">        &lt;VirtualHost _default_:443&gt;</span><br><span class="line">                ServerAdmin webmaster@localhost</span><br><span class="line">                ServerName blog.svz777.top</span><br><span class="line">                DocumentRoot /var/www/svzblog</span><br><span class="line">                ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">                CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line">                SSLEngine on</span><br><span class="line">                SSLCertificateFile /etc/letsencrypt/live/对应域名/fullchain.pem</span><br><span class="line">                SSLCertificateKeyFile /etc/letsencrypt/live/对应域名/privkey.pem</span><br><span class="line">        &lt;/VirtualHost&gt;</span><br><span class="line">    &lt;/IfModule&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>3.制作证书,这里有两种,一种是自己自签证书,不过会被标记为不安全,第二种就是采用CA机构认证的,这里我使用了<a href="https://certbot.eff.org/">Let’s Encrypt(certbot)</a><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.下载Certbot提供的证书工具</span><br><span class="line">wget https://dl.eff.org/certbot-auto</span><br><span class="line">chmod a+x certbot-auto</span><br><span class="line">./certbot-auto -n //安装支持包</span><br><span class="line">./certbot-auto --apache //安装apache插件</span><br><span class="line">2.然后提示输入邮箱</span><br><span class="line">3.同意许可啥啥啥的我也看不懂-.-</span><br><span class="line">4.然后选择对应的站点</span><br><span class="line"></span><br><span class="line">IMPORTANT NOTES:</span><br><span class="line"> - Congratulations! Your certificate and chain have been saved at</span><br><span class="line">   /etc/letsencrypt/live/blog.svz777.top/fullchain.pem. Your cert will</span><br><span class="line">   expire on 2017-05-05. To obtain a new or tweaked version of this</span><br><span class="line">   certificate in the future, simply run certbot-auto again. To</span><br><span class="line">   non-interactively renew *all* of your certificates, run</span><br><span class="line">   &quot;certbot-auto renew&quot;</span><br><span class="line"> - If you lose your account credentials, you can recover through</span><br><span class="line">   e-mails sent to 903943711@qq.com.</span><br><span class="line"> - Your account credentials have been saved in your Certbot</span><br><span class="line">   configuration directory at /etc/letsencrypt. You should make a</span><br><span class="line">   secure backup of this folder now. This configuration directory will</span><br><span class="line">   also contain certificates and private keys obtained by Certbot so</span><br><span class="line">   making regular backups of this folder is ideal.</span><br><span class="line"> - If you like Certbot, please consider supporting our work by:</span><br><span class="line"></span><br><span class="line">   Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate</span><br><span class="line">   Donating to EFF:                    https://eff.org/donate-le</span><br><span class="line">显示这个即为成功</span><br></pre></td></tr></table></figure><br>4.重启apache2</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>apache2 域名重定向</title>
      <link href="/p/1668056228.html"/>
      <url>/p/1668056228.html</url>
      
        <content type="html"><![CDATA[<p>因为google adsense不能为二级域名,所以准备将blog映射到svz777.top上,于是进行页面重定向</p><span id="more"></span><p>在对应目录的.htaccess中最前面加上<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RewriteCond %&#123;HTTP_HOST&#125; ^svz777.top [NC]</span><br><span class="line">RewriteRule ^(.*)$ http://blog.svz777.top/$1 [R=301,L]</span><br></pre></td></tr></table></figure><br>即可<br>将http重定向到https<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RewriteCond %&#123;SERVER_PORT&#125; !^443$</span><br><span class="line">RewriteRule ^.*$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R=301]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>圆角边框</title>
      <link href="/p/3791006484.html"/>
      <url>/p/3791006484.html</url>
      
        <content type="html"><![CDATA[<p>利用border-radius属性实现圆角效果</p><span id="more"></span><p>使用方法:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.border-radius:10px /*四个角都使用10px的圆角*/</span><br></pre></td></tr></table></figure><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/888204384.png" alt="1_1.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.border-radius: 9px 8px 7px 6px; /* 四个半径值分别是左上角、右上角、右下角和左下角，顺时针 */ </span><br></pre></td></tr></table></figure><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/2435886410.png" alt="1_2.png"><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.border-radius:100px/10px;/* 水平100px 垂直10px*/ </span><br></pre></td></tr></table></figure><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/old//2017/02/2922993243.png" alt="1_3.png"></p>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jQuery中setInterval()方法</title>
      <link href="/p/3305924547.html"/>
      <url>/p/3305924547.html</url>
      
        <content type="html"><![CDATA[<p>setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式</p><span id="more"></span><p>setInterval() 方法会不停地调用函数<br>直到 clearInterval() 被调用或窗口被关闭<br>由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。<br>用法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setInterval( function() &#123;</span><br><span class="line">    $(&quot;div#headerTime&quot;).html(new Date().toLocaleString());</span><br><span class="line">&#125;,1000);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
          <category> js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 搭建apahce2+php+mysql环境</title>
      <link href="/p/2849073847.html"/>
      <url>/p/2849073847.html</url>
      
        <content type="html"><![CDATA[<p>ubuntu配置常用网站环境</p><span id="more"></span><h1 id="1-安装apache2"><a href="#1-安装apache2" class="headerlink" title="1.安装apache2"></a>1.安装apache2</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2</span><br><span class="line">//安装完后重启</span><br><span class="line">service apache2 restart</span><br></pre></td></tr></table></figure><h1 id="2-安装php"><a href="#2-安装php" class="headerlink" title="2.安装php"></a>2.安装php</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libapache2-mod-php5 php5</span><br><span class="line">//安装完后重启</span><br><span class="line">service apache2 restart</span><br></pre></td></tr></table></figure><h1 id="3-安装mysql"><a href="#3-安装mysql" class="headerlink" title="3.安装mysql"></a>3.安装mysql</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server mysql-client</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>urllib.request-url编码解码</title>
      <link href="/p/1408909868.html"/>
      <url>/p/1408909868.html</url>
      
        <content type="html"><![CDATA[<p>利用自带urllib.request模块<br>urllib.request.unquote()目的是对url编码进行解码，与该函数对应的是编码函数urllib.request.quote()</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Selenium WebDriver API：浏览器及元素的常用函数及变量整理总结</title>
      <link href="/p/731795944.html"/>
      <url>/p/731795944.html</url>
      
        <content type="html"><![CDATA[<p>由于网页自动化要操作浏览器以及浏览器页面元素，将浏览器及页面元素常用的函数及变量整理总结一下</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">driver=webdriver.Firefox()</span><br><span class="line">driver.get(r&#x27;http://www.baidu.com/&#x27;)</span><br><span class="line">print &#x27;driver attributes:&#x27;</span><br><span class="line">print dir(driver)</span><br><span class="line">elem=driver.find_element_by_id(&#x27;kw&#x27;)</span><br><span class="line">print &#x27;WebElement attributes:&#x27;</span><br><span class="line">print dir(elem)</span><br></pre></td></tr></table></figure><p>浏览器属性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver attributes:</span><br><span class="line">[&#x27;NATIVE_EVENTS_ALLOWED&#x27;, &#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__doc__&#x27;, &#x27;__format__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__module__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;_file_detector&#x27;, &#x27;_is_remote&#x27;, &#x27;_mobile&#x27;, &#x27;_switch_to&#x27;, &#x27;_unwrap_value&#x27;, &#x27;_wrap_value&#x27;, &#x27;add_cookie&#x27;, &#x27;application_cache&#x27;, &#x27;back&#x27;, &#x27;binary&#x27;, &#x27;capabilities&#x27;, &#x27;close&#x27;, &#x27;command_executor&#x27;, &#x27;create_web_element&#x27;, &#x27;current_url&#x27;, &#x27;current_window_handle&#x27;, &#x27;delete_all_cookies&#x27;, &#x27;delete_cookie&#x27;, &#x27;desired_capabilities&#x27;, &#x27;error_handler&#x27;, &#x27;execute&#x27;, &#x27;execute_async_script&#x27;, &#x27;execute_script&#x27;, &#x27;file_detector&#x27;, &#x27;find_element&#x27;, &#x27;find_element_by_class_name&#x27;, &#x27;find_element_by_css_selector&#x27;, &#x27;find_element_by_id&#x27;, &#x27;find_element_by_link_text&#x27;, &#x27;find_element_by_name&#x27;, &#x27;find_element_by_partial_link_text&#x27;, &#x27;find_element_by_tag_name&#x27;, &#x27;find_element_by_xpath&#x27;, &#x27;find_elements&#x27;, &#x27;find_elements_by_class_name&#x27;, &#x27;find_elements_by_css_selector&#x27;, &#x27;find_elements_by_id&#x27;, &#x27;find_elements_by_link_text&#x27;, &#x27;find_elements_by_name&#x27;, &#x27;find_elements_by_partial_link_text&#x27;, &#x27;find_elements_by_tag_name&#x27;, &#x27;find_elements_by_xpath&#x27;, &#x27;firefox_profile&#x27;, &#x27;forward&#x27;, &#x27;get&#x27;, &#x27;get_cookie&#x27;, &#x27;get_cookies&#x27;, &#x27;get_log&#x27;, &#x27;get_screenshot_as_base64&#x27;, &#x27;get_screenshot_as_file&#x27;, &#x27;get_screenshot_as_png&#x27;, &#x27;get_window_position&#x27;, &#x27;get_window_size&#x27;, &#x27;implicitly_wait&#x27;, &#x27;log_types&#x27;, &#x27;maximize_window&#x27;, &#x27;mobile&#x27;, &#x27;name&#x27;, &#x27;orientation&#x27;, &#x27;page_source&#x27;, &#x27;profile&#x27;, &#x27;quit&#x27;, &#x27;refresh&#x27;, &#x27;save_screenshot&#x27;, &#x27;session_id&#x27;, &#x27;set_page_load_timeout&#x27;, &#x27;set_script_timeout&#x27;, &#x27;set_window_position&#x27;, &#x27;set_window_size&#x27;, &#x27;start_client&#x27;, &#x27;start_session&#x27;, &#x27;stop_client&#x27;, &#x27;switch_to&#x27;, &#x27;switch_to_active_element&#x27;, &#x27;switch_to_alert&#x27;, &#x27;switch_to_default_content&#x27;, &#x27;switch_to_frame&#x27;, &#x27;switch_to_window&#x27;, &#x27;title&#x27;, &#x27;w3c&#x27;, &#x27;window_handles&#x27;]</span><br></pre></td></tr></table></figure><br>调用说明：<br>driver.属性值</p><p>变量说明：<br>1.driver.current_url：用于获得当前页面的URL<br>2.driver.title：用于获取当前页面的标题<br>3.driver.page_source:用于获取页面html源代码<br>4.driver.current_window_handle:用于获取当前窗口句柄<br>5.driver.window_handles:用于获取所有窗口句柄</p><p>函数说明：<br>1.driver.find_element*():定位元素<br>2.driver.get(url):浏览器加载url。<br>实例：driver.get(“http//:www.baidu.com”)<br>3.driver.forward()：浏览器向前（点击向前按钮）。<br>4.driver.back()：浏览器向后（点击向后按钮）。<br>5.driver.refresh()：浏览器刷新（点击刷新按钮）。<br>6.driver.close()：关闭当前窗口，或最后打开的窗口。<br>7.driver.quit():关闭所有关联窗口，并且安全关闭session。<br>8.driver.maximize_window():最大化浏览器窗口。<br>9.driver.set_window_size(宽，高)：设置浏览器窗口大小。<br>10.driver.get_window_size()：获取当前窗口的长和宽。<br>11.driver.get_window_position()：获取当前窗口坐标。<br>12.driver.get_screenshot_as_file(filename):截取当前窗口。<br>实例：driver.get_screenshot_as_file(‘D:/selenium/image/baidu.jpg’)<br>13.driver.implicitly_wait(秒)：隐式等待，通过一定的时长等待页面上某一元素加载完成。<br>若提前定位到元素，则继续执行。若超过时间未加载出，则抛出NoSuchElementException异常。<br>实例：driver.implicitly_wait(10) #等待10秒<br>14.driver.switch_to_frame(id或name属性值)：切换到新表单(同一窗口)。若无id或属性值，可先通过xpath定位到iframe，再将值传给switch_to_frame()<br>15.driver.switch_to.parent_content():跳出当前一级表单。该方法默认对应于离它最近的switch_to.frame()方法。<br>16.driver.switch_to.default_content():跳回最外层的页面。<br>17.driver.switch_to_window(窗口句柄)：切换到新窗口。<br>18.driver.switch_to.window(窗口句柄):切换到新窗口。<br>19.driver.switch_to_alert():警告框处理。处理JavaScript所生成的alert,confirm,prompt.<br>20.driver.switch_to.alert():警告框处理。<br>21.driver.execute_script(js):调用js。<br>22.driver.get_cookies():获取当前会话所有cookie信息。<br>23.driver.get_cookie(cookie_name)：返回字典的key为“cookie_name”的cookie信息。<br>实例：driver.get_cookie(“NET_SessionId”)<br>24.driver.add_cookie(cookie_dict):添加cookie。“cookie_dict”指字典对象，必须有name和value值。<br>25.driver.delete_cookie(name,optionsString):删除cookie信息。<br>26.driver.delete_all_cookies():删除所有cookie信息。</p><p>页面元素属性：<br>WebElement attributes:<br>[‘<strong>class</strong>‘, ‘<strong>delattr</strong>‘, ‘<strong>dict</strong>‘, ‘<strong>doc</strong>‘, ‘<strong>eq</strong>‘, ‘<strong>format</strong>‘, ‘<strong>getattribute</strong>‘, ‘<strong>hash</strong>‘, ‘<strong>init</strong>‘, ‘<strong>module</strong>‘, ‘<strong>ne</strong>‘, ‘<strong>new</strong>‘, ‘<strong>reduce</strong>‘, ‘<strong>reduce_ex</strong>‘, ‘<strong>repr</strong>‘, ‘<strong>setattr</strong>‘, ‘<strong>sizeof</strong>‘, ‘<strong>str</strong>‘, ‘<strong>subclasshook</strong>‘, ‘<strong>weakref</strong>‘, ‘_execute’, ‘_id’, ‘_parent’, ‘_upload’, ‘_w3c’, ‘clear’, ‘click’, ‘find_element’, ‘find_element_by_class_name’, ‘find_element_by_css_selector’, ‘find_element_by_id’, ‘find_element_by_link_text’, ‘find_element_by_name’, ‘find_element_by_partial_link_text’, ‘find_element_by_tag_name’, ‘find_element_by_xpath’, ‘find_elements’, ‘find_elements_by_class_name’, ‘find_elements_by_css_selector’, ‘find_elements_by_id’, ‘find_elements_by_link_text’, ‘find_elements_by_name’, ‘find_elements_by_partial_link_text’, ‘find_elements_by_tag_name’, ‘find_elements_by_xpath’, ‘get_attribute’, ‘id’, ‘is_displayed’, ‘is_enabled’, ‘is_selected’, ‘location’, ‘location_once_scrolled_into_view’, ‘parent’, ‘rect’, ‘screenshot’, ‘screenshot_as_base64’, ‘screenshot_as_png’, ‘send_keys’, ‘size’, ‘submit’, ‘tag_name’, ‘text’, ‘value_of_css_property’]</p><p>调用说明：<br>driver.find_element<em>.属性值<br>或<br>element=driver.find_element</em><br>element.属性值</p><p>变量说明：<br>1.element.size:获取元素的尺寸。<br>2.element.text：获取元素的文本。<br>3.element.tag_name:获取标签名称。</p><p>函数说明：<br>1.element.clear():清除文本。<br>2.element.send_keys(value):输入文字或键盘按键（需导入Keys模块）。<br>3.element.click()：单击元素。<br>4.element.get_attribute(name):获得属性值<br>5.element.is_displayed():返回元素结果是否可见（True 或 False）<br>6.element.is_selected():返回元素结果是否被选中（True 或 False）<br>7.element.find_element*():定位元素，用于二次定位。<br>转自:<a href="http://www.cnblogs.com/yufeihlf/p/5764807.html">http://www.cnblogs.com/yufeihlf/p/5764807.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫--利用PhantomJS获取动态JS数据</title>
      <link href="/p/226542425.html"/>
      <url>/p/226542425.html</url>
      
        <content type="html"><![CDATA[<p>对于许多利用JS来载入页面数据的网页来说,利用普通的urllib与requests库往往获取不到信息</p><span id="more"></span><p>所以可以利用PhantomJS来进行JS渲染处理<br>首先安装Selenium包<br>然后下载PhantomJS,解压至Python的scripts目录下<br>使用方法很简单<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">driver=webdriver.PhantomJS()</span><br><span class="line">driver.get(<span class="string">&#x27;https://s.taobao.com/search?q=rio&#x27;</span>)</span><br><span class="line">data=driver.page_source</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> spider </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typecho 文章统计</title>
      <link href="/p/1266189248.html"/>
      <url>/p/1266189248.html</url>
      
        <content type="html"><![CDATA[<p>文章统计又分为分类统计和日期归档统计</p><span id="more"></span><p>分类统计在<strong>Widget_Metas_Category_List</strong>中的<strong>listCategories</strong>函数中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;_categoryOptions-&gt;setDefault(array(</span><br><span class="line">           &#x27;wrapTag&#x27;           =&gt;  &#x27;ul&#x27;,</span><br><span class="line">           &#x27;wrapClass&#x27;         =&gt;  &#x27;&#x27;,</span><br><span class="line">           &#x27;itemTag&#x27;           =&gt;  &#x27;li&#x27;,</span><br><span class="line">           &#x27;itemClass&#x27;         =&gt;  &#x27;&#x27;,</span><br><span class="line">           &#x27;showCount&#x27;         =&gt;  true,</span><br><span class="line">           &#x27;showFeed&#x27;          =&gt;  false,</span><br><span class="line">           &#x27;countTemplate&#x27;     =&gt;  &#x27;(%d)&#x27;,</span><br><span class="line">           &#x27;feedTemplate&#x27;      =&gt;  &#x27;&lt;a href=&quot;%s&quot;&gt;RSS&lt;/a&gt;&#x27;</span><br><span class="line">       ));</span><br></pre></td></tr></table></figure></p><p><em>showCount</em>改为<em>true</em>即可<br>日期归档统计看源码可知调用的<strong>parse</strong>函数,所以在<strong>sidebar.php</strong>中将对应的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parse(&#x27;&lt;li&gt;&lt;a href=&quot;&#123;permalink&#125;&quot;&gt;&#123;date&#125;&lt;/a&gt;&lt;/li&gt;&#x27;);</span><br><span class="line">改为</span><br><span class="line">parse(&#x27;&lt;li&gt;&lt;a href=&quot;&#123;permalink&#125;&quot;&gt;&#123;date&#125;(&#123;count&#125;)&lt;/a&gt;&lt;/li&gt;&#x27;);</span><br></pre></td></tr></table></figure><br>即可达到效果</p>]]></content>
      
      
      <categories>
          
          <category> Typecho </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>php基础</title>
      <link href="/p/1758847229.html"/>
      <url>/p/1758847229.html</url>
      
        <content type="html"><![CDATA[<p>php中类的属性设置与python类似<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$class-&gt;key=value</span><br></pre></td></tr></table></figure><br>但未赋值前不能使用。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typecho RandDesc插件</title>
      <link href="/p/2058761292.html"/>
      <url>/p/2058761292.html</url>
      
        <content type="html"><![CDATA[<p>想要一个个性化签名插件,于是参照了一下官方开发文档</p><span id="more"></span><p>本来想通过接口来进行编写,结果实在没看懂<strong>header.php</strong>中的<strong>$this-&gt;options-&gt;description()</strong>该怎么通过接口触发修改<br>然后发现官方文档中提到<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Typecho_Plugin::factory(&#x27;Widget_Archive&#x27;)-&gt;___charactersNum = array(&#x27;MyPlugin&#x27;, &#x27;charactersNum&#x27;);</span><br></pre></td></tr></table></figure><br>通过<em>_</em>来注入内部方法,然后在模板中直接通过<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;?php $this-&gt;charactersNum(); ?&gt;</span><br></pre></td></tr></table></figure><br>进行调用<br>下面附上代码,插件编写的并不完整,后台数据库手动处理的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (!defined(&#x27;__TYPECHO_ROOT_DIR__&#x27;)) exit;</span><br><span class="line">/**</span><br><span class="line"> * RandDesc</span><br><span class="line"> *</span><br><span class="line"> * @package RandDesc</span><br><span class="line"> * @author svz</span><br><span class="line"> * @version 1.0</span><br><span class="line"> * @link http://blog.svz777.top</span><br><span class="line"> */</span><br><span class="line">class RandDesc_Plugin implements Typecho_Plugin_Interface</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 激活插件方法,如果激活失败,直接抛出异常</span><br><span class="line">     *</span><br><span class="line">     * @access public</span><br><span class="line">     * @return void</span><br><span class="line">     * @throws Typecho_Plugin_Exception</span><br><span class="line">     */</span><br><span class="line">    public static function activate()</span><br><span class="line">    &#123;</span><br><span class="line">        Typecho_Plugin::factory(&#x27;Widget_Archive&#x27;)-&gt;___desc = array(&#x27;RandDesc_Plugin&#x27;, &#x27;desc&#x27;);</span><br><span class="line">        $msg = RandDesc_Plugin::install();</span><br><span class="line">        return _t($msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 禁用插件方法,如果禁用失败,直接抛出异常</span><br><span class="line">     *</span><br><span class="line">     * @static</span><br><span class="line">     * @access public</span><br><span class="line">     * @return void</span><br><span class="line">     * @throws Typecho_Plugin_Exception</span><br><span class="line">     */</span><br><span class="line">    public static function deactivate()&#123;</span><br><span class="line">        $config = Typecho_Widget::widget(&#x27;Widget_Options&#x27;)-&gt;plugin(&#x27;RandDesc&#x27;);</span><br><span class="line">        $isDrop = $config-&gt;isDrop;</span><br><span class="line">        if ($isDrop == 0) &#123;</span><br><span class="line">            $db     = Typecho_Db::get();</span><br><span class="line">            $prefix = $db-&gt;getPrefix();</span><br><span class="line">            $db-&gt;query(&quot;DROP TABLE `&quot; . $prefix . &quot;RandDesc`&quot;, Typecho_Db::WRITE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取插件配置面板</span><br><span class="line">     *</span><br><span class="line">     * @access public</span><br><span class="line">     * @param Typecho_Widget_Helper_Form $form 配置面板</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public static function config(Typecho_Widget_Helper_Form $form)</span><br><span class="line">    &#123;</span><br><span class="line">        //TODO 加入后台添加签名功能</span><br><span class="line">        $isDrop = new Typecho_Widget_Helper_Form_Element_Radio(</span><br><span class="line">            &#x27;isDrop&#x27;, array(</span><br><span class="line">            &#x27;0&#x27; =&gt; &#x27;删除&#x27;,</span><br><span class="line">            &#x27;1&#x27; =&gt; &#x27;不删除&#x27;,</span><br><span class="line">        ), &#x27;1&#x27;, &#x27;删除数据表:&#x27;, &#x27;请选择是否在禁用插件时，删除日志数据表&#x27;);</span><br><span class="line">        $form-&gt;addInput($isDrop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 个人用户的配置面板</span><br><span class="line">     *</span><br><span class="line">     * @access public</span><br><span class="line">     * @param Typecho_Widget_Helper_Form $form</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public static function personalConfig(Typecho_Widget_Helper_Form $form)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插件实现方法</span><br><span class="line">     *</span><br><span class="line">     * @access public</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public static function desc()&#123;</span><br><span class="line">        $db = Typecho_Db::get();</span><br><span class="line">        //TODO 自动从数据库获取签名数量</span><br><span class="line">        $rand=rand(0,141);</span><br><span class="line">        $query= $db-&gt;select(&#x27;description&#x27;)-&gt;from(&#x27;table.RandDesc&#x27;)-&gt;where(&#x27;id = ?&#x27;,$rand);</span><br><span class="line">        echo $db-&gt;fetchRow($query)[&quot;description&quot;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function install()&#123;</span><br><span class="line">        $db = Typecho_Db::get();</span><br><span class="line">        $type      = explode(&#x27;_&#x27;, $db-&gt;getAdapterName());</span><br><span class="line">        $type      = array_pop($type);</span><br><span class="line">        $prefix    = $db-&gt;getPrefix();</span><br><span class="line">        $scripts   = &quot;CREATE TABLE `typecho_RandDesc` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL auto_increment,</span><br><span class="line">  `description` varchar(255) default NULL,</span><br><span class="line">  PRIMARY KEY  (`id`)</span><br><span class="line">) ENGINE=MYISAM  DEFAULT CHARSET=%charset%;&quot;;</span><br><span class="line">        $scripts = str_replace(&#x27;typecho_&#x27;, $prefix, $scripts);</span><br><span class="line">        $scripts = str_replace(&#x27;%charset%&#x27;, &#x27;utf8&#x27;, $scripts);</span><br><span class="line">        $scripts = explode(&#x27;;&#x27;, $scripts);</span><br><span class="line">        try &#123;</span><br><span class="line">            foreach ($scripts as $script) &#123;</span><br><span class="line">                $script = trim($script);</span><br><span class="line">                if ($script) &#123;</span><br><span class="line">                    $db-&gt;query($script, Typecho_Db::WRITE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return &#x27;成功创建数据表，插件启用成功&#x27;;</span><br><span class="line">        &#125; catch (Typecho_Db_Exception $e) &#123;</span><br><span class="line">            $code = $e-&gt;getCode();</span><br><span class="line">            if ((&#x27;Mysql&#x27; == $type &amp;&amp; $code == (1050 || &#x27;42S01&#x27;))) &#123;</span><br><span class="line">                $script = &#x27;SELECT * from `&#x27; . $prefix . &#x27;access`&#x27;;</span><br><span class="line">                $db-&gt;query($script, Typecho_Db::READ);</span><br><span class="line">                return &#x27;数据表已存在，插件启用成功&#x27;;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new Typecho_Plugin_Exception(&#x27;数据表建立失败，插件启用失败。错误号：&#x27; . $code);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>然后在<strong>header.php</strong>模板中将<strong>$this-&gt;options-&gt;description()</strong>改为<strong>$this-&gt;desc()</strong>即可</p>]]></content>
      
      
      <categories>
          
          <category> Typecho </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Typecho开启伪静态</title>
      <link href="/p/2917912480.html"/>
      <url>/p/2917912480.html</url>
      
        <content type="html"><![CDATA[<p>在Typecho后台设置中开启 地址重写功能</p><p>然后在.htaccess文件中加上如下</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_rewrite.c&gt;</span><br><span class="line">    RewriteEngine On</span><br><span class="line"></span><br><span class="line">    RewriteBase /</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; !-f</span><br><span class="line"></span><br><span class="line">    RewriteCond %&#123;REQUEST_FILENAME&#125; !-d</span><br><span class="line"></span><br><span class="line">    RewriteRule ^(.*)$ index.php [L,E=PATH_INFO:$1]</span><br><span class="line"></span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure><p>在apache2中开启.htaccess功能<br>在apahce2的000-default.conf中将需要应用.htaccess的目录下的AllowOverride属性改为All保存即可<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Directory /&gt;</span><br><span class="line">        AllowOverride All</span><br><span class="line">&lt;/Directory&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Typecho </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>particlesJS</title>
      <link href="/p/871915551.html"/>
      <url>/p/871915551.html</url>
      
        <content type="html"><![CDATA[<p>particlesJS是一个轻量级的JavaScript库，用来创建网页上的颗粒效果，易与大量参数进行配置。 </p><span id="more"></span><p>下面介绍一下参数配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">particles.number.value ： 粒子的数量</span><br><span class="line"></span><br><span class="line">particles.number.density ： 粒子的稀密程度</span><br><span class="line"></span><br><span class="line">particles.number.density.enable ： 启用粒子的稀密程度 （true 或 false）</span><br><span class="line"></span><br><span class="line">particles.number.density.value_area ： 每一个粒子占据的空间（启用粒子密度，才可用）</span><br><span class="line"></span><br><span class="line">particles.color.value ： 粒子的颜色 （支持16进制”#b61924”，rgb”&#123;r:182, g:25, b:36&#125;”，hsl，以及random）</span><br><span class="line"></span><br><span class="line">particles.shape.type： 粒子的形状 （”circle” “edge” “triangle” “polygon” “star” “image”）</span><br><span class="line"></span><br><span class="line">particles.opacity.value： 粒子的透明度</span><br><span class="line"></span><br><span class="line">particles.size.anim.enable： 是否启用粒子速度（true/false）</span><br><span class="line"></span><br><span class="line">particles.size.anim.speed： 粒子动画频率</span><br><span class="line"></span><br><span class="line">particles.size.anim.sync： 粒子运行速度与动画是否同步</span><br><span class="line"></span><br><span class="line">particles.move.speed： 粒子移动速度</span><br><span class="line"></span><br><span class="line">priticles.interactivity.detect_on: 粒子显示层级(canvas/window)</span><br></pre></td></tr></table></figure><p>附上自用配置<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;particles&quot;: &#123;</span><br><span class="line">            &quot;number&quot;: &#123;</span><br><span class="line">                &quot;value&quot;: 120,</span><br><span class="line">                &quot;density&quot;: &#123;</span><br><span class="line">                    &quot;enable&quot;: true,</span><br><span class="line">                    &quot;value_area&quot;: 800</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;color&quot;: &#123;</span><br><span class="line">                &quot;value&quot;: &quot;#ffffff&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;shape&quot;: &#123;</span><br><span class="line">                &quot;type&quot;: &quot;polygon&quot;,//粒子的形状 （”circle” “edge” “triangle” “polygon” “star” “image”）</span><br><span class="line">                &quot;stroke&quot;: &#123;</span><br><span class="line">                    &quot;width&quot;: 0,</span><br><span class="line">                    &quot;color&quot;: &quot;#000000&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;polygon&quot;: &#123;</span><br><span class="line">                    &quot;nb_sides&quot;: 5</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;image&quot;: &#123;</span><br><span class="line">                    &quot;src&quot;: &quot;img/github.svg&quot;,</span><br><span class="line">                    &quot;width&quot;: 100,</span><br><span class="line">                    &quot;height&quot;: 100</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;opacity&quot;: &#123;</span><br><span class="line">                &quot;value&quot;: 0.5,</span><br><span class="line">                &quot;random&quot;: false,</span><br><span class="line">                &quot;anim&quot;: &#123;</span><br><span class="line">                    &quot;enable&quot;: false,</span><br><span class="line">                    &quot;speed&quot;: 1,</span><br><span class="line">                    &quot;opacity_min&quot;: 0.1,</span><br><span class="line">                    &quot;sync&quot;: false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;size&quot;: &#123;</span><br><span class="line">                &quot;value&quot;: 2,</span><br><span class="line">                &quot;random&quot;: true,</span><br><span class="line">                &quot;anim&quot;: &#123;</span><br><span class="line">                    &quot;enable&quot;: false,</span><br><span class="line">                    &quot;speed&quot;: 20,</span><br><span class="line">                    &quot;size_min&quot;: 0.1,</span><br><span class="line">                    &quot;sync&quot;: false</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;line_linked&quot;: &#123;</span><br><span class="line">                &quot;enable&quot;: true,</span><br><span class="line">                &quot;distance&quot;: 40,</span><br><span class="line">                &quot;color&quot;: &quot;#fff&quot;,</span><br><span class="line">                &quot;opacity&quot;: 1,</span><br><span class="line">                &quot;width&quot;: 1</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;move&quot;: &#123;</span><br><span class="line">                &quot;enable&quot;: true,</span><br><span class="line">                &quot;speed&quot;: 3,</span><br><span class="line">                &quot;direction&quot;: &quot;none&quot;,</span><br><span class="line">                &quot;random&quot;: false,</span><br><span class="line">                &quot;straight&quot;: false,</span><br><span class="line">                &quot;out_mode&quot;: &quot;out&quot;,</span><br><span class="line">                &quot;attract&quot;: &#123;</span><br><span class="line">                    &quot;enable&quot;: false,</span><br><span class="line">                    &quot;rotateX&quot;: 600,</span><br><span class="line">                    &quot;rotateY&quot;: 1200</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;interactivity&quot;: &#123;</span><br><span class="line">            &quot;detect_on&quot;: &quot;window&quot;,</span><br><span class="line">            &quot;events&quot;: &#123;</span><br><span class="line">                &quot;onhover&quot;: &#123;</span><br><span class="line">                    &quot;enable&quot;: true,</span><br><span class="line">                    &quot;mode&quot;: &quot;grab&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;onclick&quot;: &#123;</span><br><span class="line">                    &quot;enable&quot;: true,</span><br><span class="line">                    &quot;mode&quot;: &quot;push&quot;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;resize&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;modes&quot;: &#123;</span><br><span class="line">                &quot;grab&quot;: &#123;</span><br><span class="line">                    &quot;distance&quot;: 120,</span><br><span class="line">                    &quot;line_linked&quot;: &#123;</span><br><span class="line">                        &quot;opacity&quot;: 1</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;bubble&quot;: &#123;</span><br><span class="line">                    &quot;distance&quot;: 400,</span><br><span class="line">                    &quot;size&quot;: 40,</span><br><span class="line">                    &quot;duration&quot;: 2,</span><br><span class="line">                    &quot;opacity&quot;: 8,</span><br><span class="line">                    &quot;speed&quot;: 3</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;repulse&quot;: &#123;</span><br><span class="line">                    &quot;distance&quot;: 300</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;push&quot;: &#123;</span><br><span class="line">                    &quot;particles_nb&quot;: 4</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;remove&quot;: &#123;</span><br><span class="line">                    &quot;particles_nb&quot;: 2</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;retina_detect&quot;: true,</span><br><span class="line">        &quot;config_demo&quot;: &#123;</span><br><span class="line">            &quot;hide_card&quot;: false,</span><br><span class="line">            &quot;background_color&quot;: &quot;#b61924&quot;,</span><br><span class="line">            &quot;background_image&quot;: &quot;&quot;,</span><br><span class="line">            &quot;background_position&quot;: &quot;50% 50%&quot;,</span><br><span class="line">            &quot;background_repeat&quot;: &quot;no-repeat&quot;,</span><br><span class="line">            &quot;background_size&quot;: &quot;cover&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
          <category> js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>鼠标点击穿透div</title>
      <link href="/p/1099468566.html"/>
      <url>/p/1099468566.html</url>
      
        <content type="html"><![CDATA[<p>有些时候网页中用到了一些绝对定位的Div，因为需要事先这个Div是隐藏的，但是它所在的位置会遮挡住鼠标点击事件。这个时候可以用CCS3中的pointer-events属性来解决。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//穿透该层</span><br><span class="line">pointer-events:none;</span><br><span class="line"></span><br><span class="line">//恢复点击处理</span><br><span class="line">pointer-events:auto;</span><br></pre></td></tr></table></figure><p>根据情况来动态修改Div的pointer-events属性即可。<br>例如用JQuery可以这样写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//穿透该层</span><br><span class="line">$(&#x27;#dvTest&#x27;).css(&#x27;pointer-events&#x27;, &#x27;none&#x27;); </span><br><span class="line">//恢复点击处理</span><br><span class="line">$(&#x27;#dvTest&#x27;).css(&#x27;pointer-events&#x27;, &#x27;auto&#x27;); </span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css+js实现顶部悬浮栏</title>
      <link href="/p/3844129715.html"/>
      <url>/p/3844129715.html</url>
      
        <content type="html"><![CDATA[<p>纯悬浮只需将需要悬浮的类style中加上<em>position:fixed</em>即可</p><span id="more"></span><p>动画效果依赖于css3中的transition过渡方法与transform 2D转换方法<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#header &#123;</span><br><span class="line">    border-bottom: 1px solid #EEE;</span><br><span class="line">    background-color: #444;</span><br><span class="line">    position: fixed;</span><br><span class="line">    z-index: 2;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 100%;</span><br><span class="line">    /* Force Hardware Acceleration */</span><br><span class="line">    -webkit-transform: translateZ(0);</span><br><span class="line">    transform: translateZ(0);</span><br><span class="line">    will-change: transform;</span><br><span class="line">    -webkit-transition: -webkit-transform .5s;</span><br><span class="line">    transition: -webkit-transform .5s;</span><br><span class="line">    transition: transform .5s;</span><br><span class="line">    transition: transform .5s, -webkit-transform .5s;</span><br><span class="line">&#125;</span><br><span class="line">#header.is-hidden &#123;</span><br><span class="line">    -webkit-transform: translateY(-80%);</span><br><span class="line">    -ms-transform: translateY(-80%);</span><br><span class="line">    transform: translateY(-80%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>利用JS在页面滑动是赋予类别即可<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(function($)&#123;</span><br><span class="line">    var mainHeader = $(&#x27;header#header&#x27;),</span><br><span class="line">        headerHeight = mainHeader.height();</span><br><span class="line"></span><br><span class="line">    //set scrolling variables</span><br><span class="line">    var scrolling = false,</span><br><span class="line">        previousTop = 0,</span><br><span class="line">        currentTop = 0,</span><br><span class="line">        scrollDelta = 10,</span><br><span class="line">        scrollOffset = 150;</span><br><span class="line"></span><br><span class="line">    $(window).on(&#x27;scroll&#x27;, function()&#123;</span><br><span class="line">        if( !scrolling ) &#123;</span><br><span class="line">            scrolling = true;</span><br><span class="line">            (!window.requestAnimationFrame)</span><br><span class="line">                ? setTimeout(autoHideHeader, 250)</span><br><span class="line">                : requestAnimationFrame(autoHideHeader);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    $(window).on(&#x27;resize&#x27;, function()&#123;</span><br><span class="line">        headerHeight = mainHeader.height();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    function autoHideHeader() &#123;</span><br><span class="line">        currentTop = $(window).scrollTop();</span><br><span class="line">         checkSimpleNavigation();</span><br><span class="line"></span><br><span class="line">        previousTop = currentTop;</span><br><span class="line">        scrolling = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkSimpleNavigation() &#123;</span><br><span class="line">        //there&#x27;s no secondary nav or secondary nav is below primary nav</span><br><span class="line">        if (previousTop - currentTop &gt; scrollDelta) &#123;</span><br><span class="line">            //if scrolling up...</span><br><span class="line">            mainHeader.removeClass(&#x27;is-hidden&#x27;);</span><br><span class="line">        &#125; else if( currentTop - previousTop &gt; scrollDelta &amp;&amp; currentTop &gt; scrollOffset) &#123;</span><br><span class="line">            //if scrolling down...</span><br><span class="line">            mainHeader.addClass(&#x27;is-hidden&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> FE </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>apache2 二级域名绑定</title>
      <link href="/p/2322275510.html"/>
      <url>/p/2322275510.html</url>
      
        <content type="html"><![CDATA[<p>突发奇想想将blog改为二级域名直接访问<br>在百度上搜索了半天终于找到办法</p><span id="more"></span><p>不过百度上都是apache在httpd.conf中更改<br>apache2中将apache中的httpd.conf拆分为3个类型,<em>conf</em>,<em>mods</em>,<em>sites</em><br>available目录中才是真正的配置文件<br>而enabled目录中存放的只是一些指向这里的文件的符号链接<br>所以在/etc/apache2/sites-enabled中000-default.conf中添加上<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">        ServerAdmin SVz@localhost</span><br><span class="line">        ServerName blog.svz777.top</span><br><span class="line">        DocumentRoot /var/www/svzblog</span><br><span class="line">        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</span><br><span class="line">        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><br>重启服务service apache2 restart就行了<br>记得在域名解析中加上blog指向服务器</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Bloom Filter</title>
      <link href="/p/327978249.html"/>
      <url>/p/327978249.html</url>
      
        <content type="html"><![CDATA[<p>简单讲它仍然是一种hash的方法，但是它的特点是，它可以使用固定的内存（不随url的数量而增长）以O(1)的效率判定url是否已经在set中。</p><span id="more"></span><p>可惜天下没有白吃的午餐，它的唯一问题在于，如果这个url不在set中，BF可以100%确定这个url没有看过。但是如果这个url在set中，它会告诉你：这个url应该已经出现过，不过我有2%的不确定性。注意这里的不确定性在你分配的内存足够大的时候，可以变得很小很少。</p><p>参考链接:<a href="http://blog.csdn.net/jiaomeng/article/details/1495500">http://blog.csdn.net/jiaomeng/article/details/1495500</a></p>]]></content>
      
      
      <categories>
          
          <category> Algothrim </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识-键盘输入</title>
      <link href="/p/4094699193.html"/>
      <url>/p/4094699193.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>python中对于获取键盘输入的函数是</p><pre><code>    input(&quot;msg&quot;)</code></pre><p>,与C语言中</p><pre><code>    scanf(&quot;标记值&quot;)</code></pre><p>不同</p><p>所以对于获取键盘输入的值需要通过强制转换来得到</p><p>比如获取一个float值 </p><pre><code>    f=float(input())</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爬虫初探</title>
      <link href="/p/1972472376.html"/>
      <url>/p/1972472376.html</url>
      
        <content type="html"><![CDATA[<p>作为一个基本的爬虫,主要分为由几个框架所组成</p><span id="more"></span><p>1.爬虫的调度端<br>2.爬虫的主程序<br>1.url管理器<br>2.网页下载器<br>3.网页解析器<br>3.爬虫获取的数据的存储</p><p>初步设计用到requests，beautifulsoup模块来爬取并解析网页数据，pymysql模块将爬取到的信息保存到数据库</p><ol><li><p>requests<br>基本使用</p><pre><code> res=requests.get(url,attr)</code></pre></li></ol><p>res.text来获取页面信息</p><p>注意：resquests默认用的‘ISO-8859-1’,所以需要转换一下字符集-&gt;res.text.encode(‘ISO-8859-1’).decode(‘utf-8’)</p><p>attr参数格式</p><p>例如传入请求头</p><pre><code>    header=&#123;    &#39;User-Agent&#39;:&#39;Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:47.0) Gecko/20100101 Firefox/47.0&#39;    &#125;    requests.get(url,headers=header)</code></pre><p>data参数传入post参数</p><p>params传入get参数</p><p>files传入文件的post参数</p><p>files={‘file’:open(‘ex.txt’,’rb’)}</p><p>requests.post(url,files=files)</p><ol><li>BeautifulSoup<br>在取文本的时候碰上的问题:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">123</span><br><span class="line">&lt;a&gt;456&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>取所有文本的话 直接 get_text()即可,<br>只取123 的话 可以使用contents[0]<br>contents中其实保存的该节点下所有节点信息,文本也视为节点</li></ol>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> spider </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识-切片</title>
      <link href="/p/1565126620.html"/>
      <url>/p/1565126620.html</url>
      
        <content type="html"><![CDATA[<p>python中并没有像c中的各种字符串处理函数库,但是python提供了一个特别强大的功能,那就是切片</p><span id="more"></span><pre><code>    s[start:end:step]</code></pre><p>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">&#x27;123456789&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[::<span class="number">1</span>])       <span class="comment">#123456789</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">9</span>:])      <span class="comment">#123456789</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">9</span>:<span class="number">1</span>])     <span class="comment">#123456789</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])      <span class="comment">#987654321</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">10</span>:<span class="number">0</span>:-<span class="number">1</span>])   <span class="comment">#98765432</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">3</span>:])       <span class="comment">#789</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">9</span>:<span class="number">0</span>:])      <span class="comment">#</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>:-<span class="number">9</span>:-<span class="number">1</span>])  <span class="comment">#98765432</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>:-<span class="number">10</span>:-<span class="number">1</span>]) <span class="comment">#987654321</span></span><br></pre></td></tr></table></figure><p>start指起始位置,end指结束位置(到第end为止不包括end位),step指每次迭代的布数</p><p>可以看出在不指定step的情况下 step默认为1 step为负数点情况下,start默认是-1,end默认是头部 </p><p>注意:<strong>-1是指倒数第一个,所以-1是9,及-9才是1,所以到-10位为止才是全部遍历完</strong></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础知识-正则表达式</title>
      <link href="/p/2981639667.html"/>
      <url>/p/2981639667.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="http://img.blog.csdn.net/20130515113723855" alt="正则表达式表"></p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>os.popen库</title>
      <link href="/p/2001009263.html"/>
      <url>/p/2001009263.html</url>
      
        <content type="html"><![CDATA[<p>python执行系统命令的方法 </p><p>output=os.popen(command).read()</p><p>os.popen()会执行command命令并且获取返回值</p><p>os.system(command)也可以执行系统命令但是不能获取返回值</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python库-requests-编码问题</title>
      <link href="/p/2734383399.html"/>
      <url>/p/2734383399.html</url>
      
        <content type="html"><![CDATA[<p>由于resquests默认是获取网页头content-type中点charset参数,如果头部没有指定charset,则采用默认的ISO-8859-1编码</p><span id="more"></span><p>编码格式可以通过</p><pre><code>    res=requests.get(url) print(res.encoding)</code></pre><p>来查看,所以有以下解决办法</p><pre><code>    res.text.encode(res.encoding).decode()</code></pre><p>将获取的信息用encoding来encode一次再用decode转换成所需要的编码即可(decode默认utf-8)</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>装饰器</title>
      <link href="/p/3662810771.html"/>
      <url>/p/3662810771.html</url>
      
        <content type="html"><![CDATA[<p>装饰器的作用就是在函数调用方法不变的情况下，把此函数包装成另一个函数来使用</p><span id="more"></span><p>假设我们要增强函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数的定义，</p><p>这种在代码运行期间动态增加功能的方式，称之为“装饰器”</p><p>例如我现在需要写一个求和的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def svzSum(*args):</span><br><span class="line">    sum=0</span><br><span class="line">    for i in args:</span><br><span class="line">        sum+=i</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure><p>我现在想要写一个log输出函数,来输出我们运行的函数的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def log(func):</span><br><span class="line">    def ptlog(*args):</span><br><span class="line">        print(func.__name__)</span><br><span class="line">        return func(*args)</span><br><span class="line">    return ptlog</span><br></pre></td></tr></table></figure><p>那么我们的调用方式就应该是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=log(svzSum)</span><br><span class="line">print(a(1,2,3))</span><br></pre></td></tr></table></figure><p>这种方式称之为闭包,python中提供了一一个更为简便的表示方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@log</span><br><span class="line">def svzSum(*args):</span><br><span class="line">    sum=0</span><br><span class="line">    for i in args:</span><br><span class="line">        sum+=i</span><br><span class="line">    return sum</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux命令ps aux|grep xxx详解</title>
      <link href="/p/3049575530.html"/>
      <url>/p/3049575530.html</url>
      
        <content type="html"><![CDATA[<p>要对进程进行监测和控制,首先必须要了解当前进程的情况,也就是需要查看当前进程, 而ps命令（Process Status）就是最基本同时也是非常强大的进程查看命令.</p><span id="more"></span><p>使用该命令 可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到的.</p><p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；<br>如果想对进程时间监控，应该用 top 工具。</p><p>如果直接用ps命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。<br>grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>使用示例：<br>[root@node20 updateDB]# ps aux|grep ./update_stock<br>root 14232 0.0 0.0 5928 724 pts/1 S+ 18:16 0:00 grep ./update_stock<br>root 25021 0.0 0.0 3056 816 ? S Apr12 0:03 ./update_stock</p><p>ps aux输出格式：<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND</p><p>格式说明：<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)</p><p>STAT: 该行程的状态，linux的进程有5种状态：<br>D 不可中断 uninterruptible sleep (usually IO)<br>R 运行 runnable (on run queue)<br>S 中断 sleeping<br>T 停止 traced or stopped<br>Z 僵死 a defunct (”zombie”) process<br>注: 其它状态还包括W(无驻留页), &lt;(高优先级进程), N(低优先级进程), L(内存锁页).</p><p>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql远程连接</title>
      <link href="/p/838786575.html"/>
      <url>/p/838786575.html</url>
      
        <content type="html"><![CDATA[<p>mysql的远程连接设置如下</p><span id="more"></span><p>1.将所需登录的用户名给上权限</p><p>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘user’@’%’IDENTIFIED BY ‘password’ WITH GRANT OPTION;</p><p>user，password填上对应的用户名及密码</p><p>2.将mysql的配置文件（一般在/etc/mysql/my.cnf）中的bind_adress注释掉</p><p>这个参数的意义是将访问ip绑定，这样其他的ip便访问不上</p><p>3.将mysql重启一下即可</p><p>参考连接:<a href="http://www.cnblogs.com/ycsfwhh/archive/2012/08/07/2626597.html">http://www.cnblogs.com/ycsfwhh/archive/2012/08/07/2626597.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>os库-文件目录</title>
      <link href="/p/2509071318.html"/>
      <url>/p/2509071318.html</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>os.sep 这个代表着当前系统下的目录分隔符</p><p>比如windows下是\ linux下是/</p><p>os.getcwd()获取当前目录</p><p>os.path.dirname()获取父级目录</p><p>os.makedirs()创建一个目录</p><p>os.ph.exists()判断路径是否存在</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>requests库-cookies处理</title>
      <link href="/p/3491123427.html"/>
      <url>/p/3491123427.html</url>
      
        <content type="html"><![CDATA[<p>python模拟登陆中,是保存服务器所返回的cookie值</p><span id="more"></span><p>requests库中获取cookies的方法为</p><p>res=requests.get(url,headers=header)</p><p>cookie=res.cookies</p><p>获取到cookie后</p><p>requests.get(url,headers=header,cookies=cookie)</p><p>requests 还有有一种用法是，通过一个 requests.Session 对象，来完成请求在上下文传递过程中的 Cookie 处理。<br>所以代码可以修改如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#coding=utf‐8</span><br><span class="line">import json</span><br><span class="line">import requests</span><br><span class="line">session = requests.session()</span><br><span class="line">url_login, url_test = &quot;http://192.168.0.162/login&quot;, &quot;http://192.168.0.162/getinfo&quot;</span><br><span class="line">login_data = &#123;&#x27;user&#x27;: &#x27;abc&#x27;, &#x27;psw&#x27;: 123&#125;</span><br><span class="line">session.post(url_login, data=login_data)</span><br><span class="line">test_data = &#123;&#x27;num&#x27;: &#x27;abc123&#x27;, &quot;name&quot;: u&quot;张三&quot;&#125;</span><br><span class="line">r = session.get(url_test, data=test_data)</span><br><span class="line">res_value = r.json()</span><br><span class="line">d1 = json.dumps(res_value, sort_keys=True, ensure_ascii=False, indent=4)</span><br></pre></td></tr></table></figure><br>手动设置cookies<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res=requests.session()</span><br><span class="line">requests.utils.add_dict_to_cookiejar(res.cookies,cookies)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> lib </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硬盘出现文件目录已损坏</title>
      <link href="/p/1794113148.html"/>
      <url>/p/1794113148.html</url>
      
        <content type="html"><![CDATA[<p>这种情况目前碰到的原因都是移动硬盘没有选择弹出就拔下来了,然而之前从来没碰到过-.-</p><span id="more"></span><p>解决办法如下 </p><p>打开CMD进入文件目录错误的根目录输入以下指令即可</p><pre><code>    CHKDSK /F    CHKDSK 即 check disk简写  /f为修复</code></pre><p>此时提示无法锁定的信息。输入”Y”即选择同意”强制卸下该卷”后回车。磁盘即继续扫描并进行修复。</p>]]></content>
      
      
      <categories>
          
          <category> Others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="/p/378589723.html"/>
      <url>/p/378589723.html</url>
      
        <content type="html"><![CDATA[<p>python中函数式编程支持:</p><span id="more"></span><p>filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。</p><pre><code>    &gt;&gt;&gt;a = [1,2,3,4,5,6,7] &gt;&gt;&gt;b = filter(lambda x: x &gt; 5, a) &gt;&gt;&gt;print b &gt;&gt;&gt;[6,7]</code></pre><p>map函数是对一个序列的每个项依次执行函数，下面是对一个序列每个项都乘以2：</p><pre><code>    &gt;&gt;&gt; a = map(lambda x:x*2,[1,2,3]) &gt;&gt;&gt; list(a)    [2, 4, 6]</code></pre><p>reduce函数是对一个序列的每个项迭代调用函数，下面是求3的阶乘：</p><pre><code>    &gt;&gt;&gt; reduce(lambda x,y:x*y,range(1,4)) 6</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> base </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux文件查看命令 tail 详解</title>
      <link href="/p/1098324898.html"/>
      <url>/p/1098324898.html</url>
      
        <content type="html"><![CDATA[<p>linux中tail命令—-用于查看文件内容<br><span id="more"></span></p><p>最基本的是cat、more和less。 </p><ol><li><p>如果你只想看文件的前5行，可以使用head命令，如： </p><pre><code> head -5 /etc/passwd</code></pre></li><li><p>如果你想查看文件的后10行，可以使用tail命令，如： </p><pre><code> tail -10 /etc/passwd or tail -n 10 /etc/passwd tail -f /var/log/messages</code></pre></li></ol><p>参数-f使tail不停地去读最新的内容，这样有实时监视的效果 用Ctrl＋c来终止！ </p><ol><li><p>查看文件中间一段，你可以使用sed命令，如： </p><pre><code> sed -n &#39;5,10p&#39; /etc/passwd </code></pre></li></ol><p>这样你就可以只查看文件的第5行到第10行。 </p><p>tail语法格式:<br>        tail [ -f ] [ -c Number | -n Number | -m Number | -b Number | -k Number ] [ File ]<br>        or<br>        tail [ -r ] [ -n Number ] [ File ]</p><p>使用说明：<br>    tail 命令从指定点开始将 File 参数指定的文件写到标准输出。如果没有指定文件，则会使用标准输入。 Number 变量指定将多少单元写入标准输出。 Number 变量的值可以是正的或负的整数。如果值的前面有 +（加号），从文件开头指定的单元数开始将文件写到标准输出。如果值的前面有 -（减号），则从文件末尾指定的单元数开始将文件写到标准输出。如果值前面没有 +（加号）或 -（减号），那么从文件末尾指定的单元号开始读取文件。<br>主要参数： </p><p>-b Number 从 Number 变量表示的 512 字节块位置开始读取指定文件。<br>-c Number 从 Number 变量表示的字节位置开始读取指定文件。<br>-f 如果输入文件是常规文件或如果 File 参数指定 FIFO（先进先出），那么 tail 命令不会在复制了输入文件的最后的指定单元后终止，而是继续从输入文件读取和复制额外的单元（当这些单元可用时）。如果没有指定 File 参数，并且标准输入是管道，则会忽略 -f 标志。tail -f 命令可用于监视另一个进程正在写入的文件的增长。<br>-k Number 从 Number 变量表示的1KB 块位置开始读取指定文件。<br>-m Number 从 Number 变量表示的多字节字符位置开始读取指定文件。使用该标志提供在单字节和双字节字符代码集环境中的一致结果。<br>-n Number 从首行或末行位置来读取指定文件，位置由 Number 变量的符号（+ 或 - 或无）表示，并通过行号 Number 进行位移。<br>-r 从文件末尾以逆序方式显示输出。-r 标志的缺省值是以逆序方式显示整个文件。   </p><p>如果文件大于 20,480 字节，那么-r标志只显示最后的 20,480 字节。 -r 标志只有   与 -n 标志一起时才有效。否则，就会将其忽略。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux命令 -alias</title>
      <link href="/p/578357201.html"/>
      <url>/p/578357201.html</url>
      
        <content type="html"><![CDATA[<p>linux可以通过alias 命令注册一个快捷命令</p><span id="more"></span><p>假如想执行cdw直接进入www目录：</p><pre><code>alias cdw=&#39;cd /data/www-data/www&#39; </code></pre><p>将上述设置写到home目录的.bashrc文件中（~/.bashrc）</p><p>保存文件后，关掉当前终端并重新打开一个新的终端，从而使上面的配置生效</p><p>或者运行:</p><pre><code>source ~/.bashrc</code></pre><p>以后每次进入后就可以执行了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> cmd </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
